[
  {
    "schema": "public",
    "nome_da_funcao": "agendar_salario_provisionado",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.agendar_salario_provisionado(p_funcionario_id bigint, p_mes_competencia date)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_funcionario record;\r\n    v_categoria_id bigint;\r\n    v_conta_id bigint;\r\n    v_valor_provisionado numeric;\r\n    v_dias_uteis integer;\r\n    v_data_vencimento date;\r\n    v_valor_diaria_numeric numeric;\r\n    v_salario_base_numeric numeric;\r\nBEGIN\r\n    -- Busca os dados do funcion√°rio que acabou de ser inserido\r\n    SELECT * INTO v_funcionario FROM public.funcionarios WHERE id = p_funcionario_id;\r\n    IF NOT FOUND THEN RETURN; END IF;\r\n\r\n    -- Converte os campos de texto (moeda BR) para n√∫mero\r\n    v_valor_diaria_numeric := COALESCE(NULLIF(REPLACE(REPLACE(v_funcionario.daily_value, '.', ''), ',', '.'), '')::numeric, 0);\r\n    v_salario_base_numeric := COALESCE(NULLIF(REPLACE(REPLACE(v_funcionario.base_salary, '.', ''), ',', '.'), '')::numeric, 0);\r\n\r\n    -- Define o valor provisionado\r\n    IF v_valor_diaria_numeric > 0 THEN\r\n        -- Se houver uma fun√ß√£o para calcular dias √∫teis, ela ser√° usada. Caso contr√°rio, assume 22 dias.\r\n        BEGIN\r\n            v_dias_uteis := public.calcular_dias_uteis(p_mes_competencia);\r\n        EXCEPTION WHEN undefined_function THEN\r\n            v_dias_uteis := 22; -- Valor padr√£o se a fun√ß√£o n√£o existir\r\n        END;\r\n        v_valor_provisionado := v_dias_uteis * v_valor_diaria_numeric;\r\n    ELSE\r\n        v_valor_provisionado := v_salario_base_numeric;\r\n    END IF;\r\n\r\n    -- Encontra o ID da categoria \"Folha de Pagamento\"\r\n    SELECT id INTO v_categoria_id \r\n    FROM public.categorias_financeiras \r\n    WHERE nome ILIKE 'Folha de Pagamento' AND organizacao_id = v_funcionario.organizacao_id;\r\n\r\n    -- Encontra uma conta banc√°ria associada √† empresa do funcion√°rio\r\n    SELECT id INTO v_conta_id \r\n    FROM public.contas_financeiras \r\n    WHERE empresa_id = v_funcionario.empresa_id AND organizacao_id = v_funcionario.organizacao_id\r\n    LIMIT 1;\r\n\r\n    IF v_conta_id IS NULL THEN\r\n        RAISE NOTICE 'Nenhuma conta financeira encontrada para a empresa ID: %. N√£o foi poss√≠vel provisionar o sal√°rio.', v_funcionario.empresa_id;\r\n        RETURN; -- N√£o para a execu√ß√£o com erro, apenas avisa e retorna.\r\n    END IF;\r\n\r\n    -- Calcula o vencimento para o 5¬∫ dia √∫til do m√™s seguinte\r\n    v_data_vencimento := (date_trunc('month', p_mes_competencia) + interval '1 month' + interval '4 days')::date;\r\n\r\n    -- Insere o lan√ßamento provisionado com a conta_id e a organizacao_id\r\n    INSERT INTO public.lancamentos (\r\n        empresa_id,\r\n        empreendimento_id,\r\n        categoria_id,\r\n        conta_id,\r\n        descricao,\r\n        valor,\r\n        data_vencimento,\r\n        mes_competencia,\r\n        status,\r\n        tipo,\r\n        funcionario_id,\r\n        organizacao_id -- <<< CORRE√á√ÉO APLICADA AQUI\r\n    )\r\n    VALUES (\r\n        v_funcionario.empresa_id,\r\n        v_funcionario.empreendimento_atual_id,\r\n        v_categoria_id,\r\n        v_conta_id,\r\n        'Sal√°rio Ref: ' || to_char(p_mes_competencia, 'MM/YYYY') || ' - ' || v_funcionario.full_name,\r\n        v_valor_provisionado,\r\n        v_data_vencimento,\r\n        p_mes_competencia,\r\n        'Pendente',\r\n        'Despesa',\r\n        p_funcionario_id,\r\n        v_funcionario.organizacao_id -- <<< CORRE√á√ÉO APLICADA AQUI\r\n    );\r\n\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "agendar_vale",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.agendar_vale(p_funcionario_id bigint, p_organizacao_id bigint, p_periodo_inicio date, p_periodo_fim date, p_data_pagamento date, p_valor_projetado numeric)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    novo_lancamento_id bigint;\r\n    nome_funcionario text;\r\nBEGIN\r\n    -- Busca o nome do funcion√°rio para a descri√ß√£o do lan√ßamento\r\n    SELECT full_name INTO nome_funcionario FROM public.funcionarios WHERE id = p_funcionario_id;\r\n\r\n    -- 1. Cria o lan√ßamento financeiro com o valor projetado\r\n    INSERT INTO public.lancamentos (\r\n        descricao,\r\n        valor,\r\n        tipo,\r\n        status,\r\n        data_transacao,\r\n        data_vencimento,\r\n        data_pagamento,\r\n        funcionario_id,\r\n        favorecido_contato_id,\r\n        conta_id, -- ATEN√á√ÉO: Definir uma conta padr√£o ou buscar uma. Usando NULL por enquanto.\r\n        organizacao_id\r\n    )\r\n    VALUES (\r\n        'Adiantamento (Vale) para ' || nome_funcionario,\r\n        p_valor_projetado,\r\n        'Despesa',\r\n        'Pendente',\r\n        p_data_pagamento,\r\n        p_data_pagamento,\r\n        NULL, -- Data de pagamento fica nula at√© a confirma√ß√£o\r\n        p_funcionario_id,\r\n        (SELECT contato_id FROM public.funcionarios WHERE id = p_funcionario_id),\r\n        NULL, -- DEFINIR UMA CONTA PADR√ÉO AQUI SE NECESS√ÅRIO\r\n        p_organizacao_id\r\n    ) RETURNING id INTO novo_lancamento_id;\r\n\r\n    -- 2. Cria o registro na tabela de controle de vales\r\n    INSERT INTO public.vales_agendados (\r\n        funcionario_id,\r\n        lancamento_id,\r\n        periodo_inicio,\r\n        periodo_fim,\r\n        data_pagamento_agendada,\r\n        valor_projetado,\r\n        organizacao_id\r\n    )\r\n    VALUES (\r\n        p_funcionario_id,\r\n        novo_lancamento_id,\r\n        p_periodo_inicio,\r\n        p_periodo_fim,\r\n        p_data_pagamento,\r\n        p_valor_projetado,\r\n        p_organizacao_id\r\n    );\r\n\r\n    -- Retorna sucesso\r\n    RETURN json_build_object('status', 'success', 'message', 'Vale agendado com sucesso!', 'lancamento_id', novo_lancamento_id);\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "agendar_vale",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.agendar_vale(p_funcionario_id bigint, p_organizacao_id bigint, p_periodo_inicio date, p_periodo_fim date, p_data_pagamento date, p_valor_projetado numeric, p_conta_id bigint, p_empresa_id bigint, p_empreendimento_id bigint)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    novo_lancamento_id bigint;\r\n    nome_funcionario text;\r\n    v_categoria_id bigint;\r\n    -- O PORQU√ä: Vari√°veis para guardar os dados do c√°lculo.\r\n    v_dias_trabalhados int;\r\n    v_valor_diaria numeric;\r\n    v_observacao text;\r\nBEGIN\r\n    -- Busca o nome do funcion√°rio para a descri√ß√£o\r\n    SELECT full_name INTO nome_funcionario FROM public.funcionarios WHERE id = p_funcionario_id;\r\n\r\n    -- Procura o ID da categoria \"Folha de Pagamento\"\r\n    SELECT id INTO v_categoria_id\r\n    FROM public.categorias_financeiras\r\n    WHERE nome ILIKE 'Folha de Pagamento' AND organizacao_id = p_organizacao_id\r\n    LIMIT 1;\r\n\r\n    -- =================================================================================\r\n    -- IN√çCIO DA CORRE√á√ÉO\r\n    -- O PORQU√ä: Esta √© a l√≥gica que estava faltando. Ela gera a \"mem√≥ria de c√°lculo\".\r\n    -- =================================================================================\r\n\r\n    -- 1. Busca a di√°ria mais recente do funcion√°rio\r\n    SELECT valor_diaria INTO v_valor_diaria\r\n    FROM public.historico_salarial\r\n    WHERE funcionario_id = p_funcionario_id AND data_inicio_vigencia <= p_periodo_fim\r\n    ORDER BY data_inicio_vigencia DESC LIMIT 1;\r\n    \r\n    -- Se n√£o encontrar di√°ria, define como 0 para evitar erros.\r\n    IF NOT FOUND THEN\r\n        v_valor_diaria := 0;\r\n    END IF;\r\n\r\n    -- 2. Calcula o n√∫mero de dias (evita divis√£o por zero)\r\n    IF v_valor_diaria > 0 THEN\r\n        v_dias_trabalhados := round(p_valor_projetado / v_valor_diaria);\r\n    ELSE\r\n        v_dias_trabalhados := 0;\r\n    END IF;\r\n\r\n    -- 3. Monta a string de observa√ß√£o com todos os detalhes\r\n    v_observacao := format(\r\n        'Referente a %s dias de trabalho no per√≠odo de %s a %s, com di√°ria de R$ %s.',\r\n        v_dias_trabalhados,\r\n        to_char(p_periodo_inicio, 'DD/MM/YYYY'),\r\n        to_char(p_periodo_fim, 'DD/MM/YYYY'),\r\n        to_char(v_valor_diaria, 'FM999G999D00') -- Formata para o padr√£o monet√°rio brasileiro\r\n    );\r\n    -- =================================================================================\r\n    -- FIM DA CORRE√á√ÉO\r\n    -- =================================================================================\r\n\r\n    -- Cria o lan√ßamento financeiro, agora incluindo a observa√ß√£o\r\n    INSERT INTO public.lancamentos (\r\n        descricao, valor, tipo, status, data_transacao, data_vencimento, data_pagamento,\r\n        funcionario_id, favorecido_contato_id, conta_id, categoria_id, empresa_id,\r\n        empreendimento_id, observacao, organizacao_id\r\n    )\r\n    VALUES (\r\n        'Adiantamento (Vale) para ' || nome_funcionario, p_valor_projetado, 'Despesa', 'Pendente', p_data_pagamento, p_data_pagamento, NULL,\r\n        p_funcionario_id, (SELECT contato_id FROM public.funcionarios WHERE id = p_funcionario_id), p_conta_id, v_categoria_id, p_empresa_id,\r\n        p_empreendimento_id, v_observacao, p_organizacao_id\r\n    ) RETURNING id INTO novo_lancamento_id;\r\n\r\n    -- Cria o registro na tabela de controle de vales\r\n    INSERT INTO public.vales_agendados (\r\n        funcionario_id, lancamento_id, periodo_inicio, periodo_fim,\r\n        data_pagamento_agendada, valor_projetado, organizacao_id\r\n    )\r\n    VALUES (\r\n        p_funcionario_id, novo_lancamento_id, p_periodo_inicio, p_periodo_fim,\r\n        p_data_pagamento, p_valor_projetado, p_organizacao_id\r\n    );\r\n\r\n    RETURN json_build_object('status', 'success', 'message', 'Vale agendado com sucesso!', 'lancamento_id', novo_lancamento_id);\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "agendar_vale",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.agendar_vale(p_funcionario_id bigint, p_organizacao_id bigint, p_periodo_inicio date, p_periodo_fim date, p_data_pagamento date, p_valor_projetado numeric, p_conta_id bigint)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    novo_lancamento_id bigint;\r\n    nome_funcionario text;\r\nBEGIN\r\n    -- Busca o nome do funcion√°rio para a descri√ß√£o do lan√ßamento\r\n    SELECT full_name INTO nome_funcionario FROM public.funcionarios WHERE id = p_funcionario_id;\r\n\r\n    -- Cria o lan√ßamento financeiro com o valor projetado\r\n    INSERT INTO public.lancamentos (\r\n        descricao,\r\n        valor,\r\n        tipo,\r\n        status,\r\n        data_transacao,\r\n        data_vencimento,\r\n        data_pagamento,\r\n        funcionario_id,\r\n        favorecido_contato_id,\r\n        conta_id, -- Valor agora vem do par√¢metro\r\n        organizacao_id\r\n    )\r\n    VALUES (\r\n        'Adiantamento (Vale) para ' || nome_funcionario,\r\n        p_valor_projetado,\r\n        'Despesa',\r\n        'Pendente',\r\n        p_data_pagamento,\r\n        p_data_pagamento,\r\n        NULL,\r\n        p_funcionario_id,\r\n        (SELECT contato_id FROM public.funcionarios WHERE id = p_funcionario_id),\r\n        p_conta_id, -- Usa o ID da conta recebido\r\n        p_organizacao_id\r\n    ) RETURNING id INTO novo_lancamento_id;\r\n\r\n    -- Cria o registro na tabela de controle de vales\r\n    INSERT INTO public.vales_agendados (\r\n        funcionario_id,\r\n        lancamento_id,\r\n        periodo_inicio,\r\n        periodo_fim,\r\n        data_pagamento_agendada,\r\n        valor_projetado,\r\n        organizacao_id\r\n    )\r\n    VALUES (\r\n        p_funcionario_id,\r\n        novo_lancamento_id,\r\n        p_periodo_inicio,\r\n        p_periodo_fim,\r\n        p_data_pagamento,\r\n        p_valor_projetado,\r\n        p_organizacao_id\r\n    );\r\n\r\n    RETURN json_build_object('status', 'success', 'message', 'Vale agendado com sucesso!', 'lancamento_id', novo_lancamento_id);\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "aplicar_cub_e_retornar_produtos",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.aplicar_cub_e_retornar_produtos(p_empreendimento_id bigint, p_novo_valor_cub numeric)\n RETURNS SETOF produtos_empreendimento\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Etapa 1: Salva ou atualiza o valor do CUB nas configura√ß√µes do empreendimento.\r\n    INSERT INTO public.configuracoes_venda (empreendimento_id, valor_cub)\r\n    VALUES (p_empreendimento_id, p_novo_valor_cub)\r\n    ON CONFLICT (empreendimento_id)\r\n    DO UPDATE SET valor_cub = p_novo_valor_cub;\r\n\r\n    -- Etapa 2: Atualiza todos os produtos do empreendimento, calculando o novo pre√ßo base.\r\n    UPDATE public.produtos_empreendimento\r\n    SET\r\n        -- AQUI EST√Å A L√ìGICA CORRETA: valor_base = √°rea * CUB\r\n        valor_base = area_m2 * p_novo_valor_cub,\r\n        -- O valor de venda tamb√©m √© recalculado na mesma opera√ß√£o.\r\n        valor_venda_calculado = (area_m2 * p_novo_valor_cub) * (1 + (COALESCE(fator_reajuste_percentual, 0) / 100.0))\r\n    WHERE\r\n        empreendimento_id = p_empreendimento_id;\r\n        \r\n    -- Etapa 3: Retorna a lista de produtos j√° com os valores atualizados.\r\n    RETURN QUERY\r\n    SELECT *\r\n    FROM public.produtos_empreendimento\r\n    WHERE empreendimento_id = p_empreendimento_id\r\n    ORDER BY unidade;\r\n\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "array_to_halfvec",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.array_to_halfvec(integer[], integer, boolean)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_halfvec$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "array_to_halfvec",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.array_to_halfvec(double precision[], integer, boolean)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_halfvec$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "array_to_halfvec",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.array_to_halfvec(numeric[], integer, boolean)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_halfvec$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "array_to_halfvec",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.array_to_halfvec(real[], integer, boolean)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_halfvec$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "array_to_sparsevec",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.array_to_sparsevec(real[], integer, boolean)\n RETURNS sparsevec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_sparsevec$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "array_to_sparsevec",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.array_to_sparsevec(numeric[], integer, boolean)\n RETURNS sparsevec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_sparsevec$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "array_to_sparsevec",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.array_to_sparsevec(double precision[], integer, boolean)\n RETURNS sparsevec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_sparsevec$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "array_to_sparsevec",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.array_to_sparsevec(integer[], integer, boolean)\n RETURNS sparsevec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_sparsevec$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "array_to_vector",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.array_to_vector(real[], integer, boolean)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_vector$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "array_to_vector",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.array_to_vector(numeric[], integer, boolean)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_vector$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "array_to_vector",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.array_to_vector(integer[], integer, boolean)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_vector$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "array_to_vector",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.array_to_vector(double precision[], integer, boolean)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_vector$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "atribuir_numero_contrato",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.atribuir_numero_contrato()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    ultimo_numero INTEGER;\r\nBEGIN\r\n    IF NEW.status_contrato = 'Assinado' AND NEW.numero_contrato IS NULL THEN\r\n        LOCK TABLE public.contratos IN EXCLUSIVE MODE;\r\n\r\n        SELECT COALESCE(MAX(numero_contrato), 0) -- Simplificado, pois a coluna agora √© INTEGER\r\n        INTO ultimo_numero\r\n        FROM public.contratos\r\n        WHERE organizacao_id = NEW.organizacao_id;\r\n\r\n        -- =================================================================================\r\n        -- MUDAN√áA AQUI: Removemos a convers√£o para TEXTO (::TEXT)\r\n        -- Agora, ele salva como um n√∫mero inteiro de verdade.\r\n        -- =================================================================================\r\n        NEW.numero_contrato := ultimo_numero + 1;\r\n    END IF;\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "atualizar_data_entrega_real",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.atualizar_data_entrega_real()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- A condi√ß√£o NEW.status = 'Entregue' verifica se o novo estado √© 'Entregue'.\r\n    -- A condi√ß√£o OLD.status <> 'Entregue' garante que isso s√≥ aconte√ßa na transi√ß√£o para 'Entregue',\r\n    -- e n√£o em outras atualiza√ß√µes de um pedido que j√° estava entregue.\r\n    IF NEW.status = 'Entregue' AND OLD.status <> 'Entregue' AND NEW.data_entrega_real IS NULL THEN\r\n        -- Define a data de entrega real como a data atual.\r\n        NEW.data_entrega_real := CURRENT_DATE;\r\n    END IF;\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "atualizar_nomes_meta_apos_insert",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.atualizar_nomes_meta_apos_insert()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    -- Como esta fun√ß√£o roda DEPOIS que o contato j√° foi inserido,\r\n    -- n√≥s executamos um comando UPDATE separado para a linha que acabou de ser criada (NEW.id).\r\n    UPDATE public.contatos\r\n    SET \r\n        -- Para cada campo, buscamos o nome correspondente nas tabelas da Meta\r\n        meta_ad_name = (SELECT name FROM public.meta_ads WHERE id = NEW.meta_ad_id),\r\n        meta_adset_name = (SELECT name FROM public.meta_adsets WHERE id = NEW.meta_adgroup_id),\r\n        meta_campaign_name = (SELECT name FROM public.meta_campaigns WHERE id = NEW.meta_campaign_id)\r\n    WHERE \r\n        -- A condi√ß√£o WHERE garante que estamos atualizando EXATAMENTE a linha que disparou o gatilho.\r\n        id = NEW.id;\r\n\r\n    -- Em um gatilho AFTER, o valor de retorno √© ignorado, mas √© boa pr√°tica retornar NEW.\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "atualizar_previsao_fatura_cartao",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.atualizar_previsao_fatura_cartao()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_conta_cartao_id BIGINT;\r\n    v_conta_debito_id BIGINT;\r\n    v_total_fatura NUMERIC;\r\n    v_nome_cartao TEXT;\r\n    v_lancamento_previsao_id BIGINT;\r\n    v_dia_pagamento INT;\r\n    v_data_vencimento_previsao DATE;\r\n    v_data_base DATE;\r\nBEGIN\r\n    -- 1. Identifica a conta do cart√£o\r\n    IF (TG_OP = 'DELETE') THEN\r\n        v_conta_cartao_id := OLD.conta_id;\r\n    ELSE\r\n        v_conta_cartao_id := NEW.conta_id;\r\n    END IF;\r\n\r\n    -- 2. Busca configura√ß√µes do cart√£o (Dia Pagamento e Conta D√©bito)\r\n    SELECT id, nome, conta_debito_fatura_id, dia_pagamento_fatura\r\n    INTO v_conta_cartao_id, v_nome_cartao, v_conta_debito_id, v_dia_pagamento\r\n    FROM public.contas_financeiras\r\n    WHERE id = v_conta_cartao_id AND tipo = 'Cart√£o de Cr√©dito';\r\n\r\n    -- Se n√£o for cart√£o ou n√£o tiver conta vinculada, para aqui\r\n    IF v_conta_cartao_id IS NULL OR v_conta_debito_id IS NULL THEN\r\n        RETURN NULL;\r\n    END IF;\r\n\r\n    -- Se o dia de pagamento n√£o estiver configurado, usa dia 10 como padr√£o (seguran√ßa)\r\n    IF v_dia_pagamento IS NULL THEN v_dia_pagamento := 10; END IF;\r\n\r\n    -- 3. Calcula a Data de Vencimento da Previs√£o\r\n    -- Pega o primeiro dia do m√™s atual\r\n    v_data_base := date_trunc('month', CURRENT_DATE)::DATE;\r\n    \r\n    -- Soma os dias para chegar no dia de pagamento (ex: 1 + (10-1) = dia 10)\r\n    -- Usamos intervalo para evitar erro em meses curtos (o banco ajusta automaticamente)\r\n    v_data_vencimento_previsao := (v_data_base + ((v_dia_pagamento - 1) || ' days')::INTERVAL)::DATE;\r\n\r\n    -- Se hoje j√° passou do dia de pagamento, a previs√£o √© para o m√™s que vem\r\n    IF CURRENT_DATE > v_data_vencimento_previsao THEN\r\n        v_data_vencimento_previsao := (v_data_vencimento_previsao + INTERVAL '1 month')::DATE;\r\n    END IF;\r\n\r\n    -- 4. Calcula o valor total pendente\r\n    SELECT COALESCE(SUM(valor), 0)\r\n    INTO v_total_fatura\r\n    FROM public.lancamentos\r\n    WHERE conta_id = v_conta_cartao_id;\r\n\r\n    -- 5. Gerencia o Lan√ßamento de Previs√£o na Conta Corrente\r\n    \r\n    -- Busca se j√° existe\r\n    SELECT id INTO v_lancamento_previsao_id\r\n    FROM public.lancamentos\r\n    WHERE conta_id = v_conta_debito_id \r\n      AND observacao = 'SISTEMA: PREVIS√ÉO FATURA CART√ÉO ID ' || v_conta_cartao_id\r\n      AND status = 'Pendente'\r\n    LIMIT 1;\r\n\r\n    IF v_lancamento_previsao_id IS NOT NULL THEN\r\n        -- ATUALIZA existente\r\n        IF v_total_fatura < 0 THEN\r\n            UPDATE public.lancamentos\r\n            SET valor = ABS(v_total_fatura),\r\n                data_vencimento = v_data_vencimento_previsao, -- Data calculada\r\n                data_transacao = v_data_vencimento_previsao   -- Mant√©m data transa√ß√£o igual vencimento para previs√£o\r\n            WHERE id = v_lancamento_previsao_id;\r\n        ELSE\r\n            -- Se saldo zerou (foi pago), remove a previs√£o\r\n            DELETE FROM public.lancamentos WHERE id = v_lancamento_previsao_id;\r\n        END IF;\r\n    ELSE\r\n        -- CRIA novo\r\n        IF v_total_fatura < 0 THEN\r\n            INSERT INTO public.lancamentos (\r\n                descricao, \r\n                valor, \r\n                tipo, \r\n                conta_id, \r\n                status, \r\n                data_transacao, \r\n                data_vencimento, \r\n                observacao,\r\n                organizacao_id\r\n            ) VALUES (\r\n                'Previs√£o Fatura - ' || v_nome_cartao,\r\n                ABS(v_total_fatura),\r\n                'Despesa',\r\n                v_conta_debito_id,\r\n                'Pendente',\r\n                v_data_vencimento_previsao, -- Data calculada\r\n                v_data_vencimento_previsao, -- Data calculada\r\n                'SISTEMA: PREVIS√ÉO FATURA CART√ÉO ID ' || v_conta_cartao_id,\r\n                (SELECT organizacao_id FROM public.contas_financeiras WHERE id = v_conta_cartao_id)\r\n            );\r\n        END IF;\r\n    END IF;\r\n\r\n    RETURN NULL;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "atualizar_status_pedido",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.atualizar_status_pedido(p_pedido_id bigint, p_novo_status text, p_usuario_id uuid)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_status_anterior text;\r\nBEGIN\r\n    -- Busca o status atual (que ser√° o anterior)\r\n    SELECT status INTO v_status_anterior\r\n    FROM public.pedidos_compra\r\n    WHERE id = p_pedido_id;\r\n\r\n    -- Se o status n√£o mudou, n√£o faz nada\r\n    IF v_status_anterior IS NOT DISTINCT FROM p_novo_status THEN\r\n        RETURN;\r\n    END IF;\r\n\r\n    -- Atualiza o status na tabela principal de pedidos\r\n    UPDATE public.pedidos_compra\r\n    SET status = p_novo_status\r\n    WHERE id = p_pedido_id;\r\n\r\n    -- Insere o registro na tabela de hist√≥rico\r\n    INSERT INTO public.pedidos_compra_status_historico\r\n        (pedido_compra_id, status_anterior, status_novo, alterado_por_usuario_id)\r\n    VALUES\r\n        (p_pedido_id, v_status_anterior, p_novo_status, p_usuario_id);\r\n\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "atualizar_valor_base_produtos",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.atualizar_valor_base_produtos(p_empreendimento_id bigint, p_novo_valor_base numeric)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    UPDATE public.produtos_empreendimento\r\n    SET\r\n        valor_base = p_novo_valor_base,\r\n        valor_venda_calculado = p_novo_valor_base * (1 + (COALESCE(fator_reajuste_percentual, 0) / 100))\r\n    WHERE\r\n        empreendimento_id = p_empreendimento_id;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "auto_gerenciar_triggers_notificacao",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.auto_gerenciar_triggers_notificacao()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_tabela_alvo TEXT;\r\n    v_nome_trigger TEXT;\r\n    v_existe BOOLEAN;\r\nBEGIN\r\n    v_tabela_alvo := NEW.tabela_alvo;\r\n    v_nome_trigger := 'trg_auto_notificacao_' || v_tabela_alvo;\r\n\r\n    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = v_tabela_alvo) THEN \r\n        RETURN NEW; \r\n    END IF;\r\n\r\n    SELECT EXISTS (SELECT 1 FROM information_schema.triggers WHERE event_object_table = v_tabela_alvo AND trigger_name = v_nome_trigger) INTO v_existe;\r\n\r\n    IF NOT v_existe THEN\r\n        EXECUTE format('CREATE TRIGGER %I AFTER INSERT OR UPDATE ON public.%I FOR EACH ROW EXECUTE FUNCTION public.processar_regras_notificacao();', v_nome_trigger, v_tabela_alvo);\r\n        RAISE NOTICE 'Gatilho autom√°tico criado na tabela: %', v_tabela_alvo;\r\n    END IF;\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "auto_merge_contacts_and_relink",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.auto_merge_contacts_and_relink(p_contact_ids bigint[])\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_primary_contact_id bigint;\r\n    v_secondary_contact_ids bigint[];\r\n    v_final_data jsonb;\r\n    v_final_telefones jsonb[];\r\n    v_final_emails jsonb[];\r\nBEGIN\r\n    -- Se o array de entrada tiver 1 ou 0 contatos, n√£o h√° nada a fazer.\r\n    IF array_length(p_contact_ids, 1) <= 1 THEN\r\n        RETURN 'N√£o h√° contatos suficientes para mesclar.';\r\n    END IF;\r\n\r\n    -- Define o contato mais antigo como o principal\r\n    SELECT id INTO v_primary_contact_id FROM public.contatos WHERE id = ANY(p_contact_ids) ORDER BY created_at ASC LIMIT 1;\r\n    \r\n    -- Os demais s√£o secund√°rios. \r\n    -- ***** AQUI EST√Å A CORRE√á√ÉO *****\r\n    -- Usamos COALESCE para garantir que, se n√£o houver secund√°rios, teremos um array vazio '{}' em vez de NULL.\r\n    SELECT COALESCE(array_agg(id), '{}') INTO v_secondary_contact_ids FROM public.contatos WHERE id = ANY(p_contact_ids) AND id <> v_primary_contact_id;\r\n\r\n    -- Pega os dados do contato principal como base\r\n    SELECT to_jsonb(c.*) INTO v_final_data FROM public.contatos c WHERE id = v_primary_contact_id;\r\n\r\n    -- Junta todos os telefones e e-mails √∫nicos de todos os contatos\r\n    SELECT array_agg(DISTINCT to_jsonb(t.*)) INTO v_final_telefones FROM public.telefones t WHERE t.contato_id = ANY(p_contact_ids);\r\n    SELECT array_agg(DISTINCT to_jsonb(e.*)) INTO v_final_emails FROM public.emails e WHERE e.contato_id = ANY(p_contact_ids);\r\n\r\n    -- Chama a nossa fun√ß√£o principal com os dados preparados\r\n    RETURN public.merge_contacts_and_relink_all_references(\r\n        v_primary_contact_id,\r\n        v_secondary_contact_ids,\r\n        v_final_data,\r\n        v_final_telefones,\r\n        v_final_emails\r\n    );\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "auto_merge_contacts_and_relink",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.auto_merge_contacts_and_relink(p_contact_ids uuid[], p_organizacao_id uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    winner_id uuid;\r\n    loser_id uuid;\r\n    id_iter uuid;\r\nBEGIN\r\n    -- 1. O Vencedor √© o mais antigo (ou o primeiro da lista)\r\n    SELECT id INTO winner_id\r\n    FROM contatos\r\n    WHERE id = ANY(p_contact_ids)\r\n    ORDER BY created_at ASC\r\n    LIMIT 1;\r\n\r\n    -- Loop para processar cada duplicata\r\n    FOREACH id_iter IN ARRAY p_contact_ids LOOP\r\n        IF id_iter <> winner_id THEN\r\n            loser_id := id_iter;\r\n\r\n            -- =================================================================\r\n            -- 1. TABELA DE LISTAS (whatsapp_list_members)\r\n            -- L√≥gica: Apagar do perdedor as listas que o vencedor J√Å TEM.\r\n            --         Depois, substituir o ID nas que sobrarem.\r\n            -- =================================================================\r\n            BEGIN\r\n                -- Apaga intersec√ß√£o (evita o erro unique_contato_na_lista)\r\n                DELETE FROM whatsapp_list_members\r\n                WHERE contato_id = loser_id\r\n                AND lista_id IN (\r\n                    SELECT lista_id FROM whatsapp_list_members WHERE contato_id = winner_id\r\n                );\r\n                \r\n                -- Substitui o ID nas restantes (UPDATE Simples)\r\n                UPDATE whatsapp_list_members \r\n                SET contato_id = winner_id \r\n                WHERE contato_id = loser_id;\r\n            EXCEPTION WHEN OTHERS THEN NULL; END;\r\n\r\n            -- =================================================================\r\n            -- 2. TABELA DE FUNIL (contatos_no_funil)\r\n            -- L√≥gica: Um contato s√≥ pode estar em UM lugar do funil.\r\n            -- =================================================================\r\n            IF EXISTS (SELECT 1 FROM contatos_no_funil WHERE contato_id = winner_id) THEN\r\n                -- Se o vencedor j√° est√° no funil, removemos o perdedor do funil\r\n                DELETE FROM contatos_no_funil WHERE contato_id = loser_id;\r\n            ELSE\r\n                -- Se o vencedor n√£o est√°, ele herda a posi√ß√£o do perdedor\r\n                UPDATE contatos_no_funil SET contato_id = winner_id WHERE contato_id = loser_id;\r\n            END IF;\r\n\r\n            -- =================================================================\r\n            -- 3. TABELA DE TELEFONES\r\n            -- L√≥gica: Apaga telefones repetidos, move os novos.\r\n            -- =================================================================\r\n            DELETE FROM telefones\r\n            WHERE contato_id = loser_id\r\n            AND telefone IN (\r\n                SELECT telefone FROM telefones WHERE contato_id = winner_id\r\n            );\r\n            UPDATE telefones SET contato_id = winner_id WHERE contato_id = loser_id;\r\n\r\n            -- =================================================================\r\n            -- 4. ATUALIZAR TODO O RESTANTE (Substitui√ß√£o de ID Direta)\r\n            -- =================================================================\r\n            \r\n            -- WhatsApp\r\n            UPDATE whatsapp_conversations SET contato_id = winner_id WHERE contato_id = loser_id;\r\n            UPDATE whatsapp_messages SET contato_id = winner_id WHERE contato_id = loser_id;\r\n            BEGIN UPDATE whatsapp_attachments SET contato_id = winner_id WHERE contato_id = loser_id; EXCEPTION WHEN OTHERS THEN NULL; END;\r\n\r\n            -- Notas e E-mails\r\n            BEGIN UPDATE crm_notas SET contato_id = winner_id WHERE contato_id = loser_id; EXCEPTION WHEN OTHERS THEN NULL; END;\r\n            BEGIN UPDATE emails SET contato_id = winner_id WHERE contato_id = loser_id; EXCEPTION WHEN OTHERS THEN NULL; END;\r\n            \r\n            -- Outros v√≠nculos poss√≠veis (adicione se necess√°rio)\r\n            -- UPDATE tarefas SET contato_id = winner_id WHERE contato_id = loser_id;\r\n\r\n            -- =================================================================\r\n            -- 5. EXCLUIR O CONTATO ANTIGO\r\n            -- =================================================================\r\n            DELETE FROM contatos WHERE id = loser_id;\r\n            \r\n        END IF;\r\n    END LOOP;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "auto_merge_contacts_and_relink",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.auto_merge_contacts_and_relink(p_contact_ids bigint[], p_organizacao_id bigint)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    winner_id bigint;\r\n    loser_id bigint;\r\n    id_iter bigint;\r\nBEGIN\r\n    -- 1. Identificar o Vencedor (O contato mais antigo criado)\r\n    SELECT id INTO winner_id\r\n    FROM public.contatos\r\n    WHERE id = ANY(p_contact_ids)\r\n    AND organizacao_id = p_organizacao_id\r\n    ORDER BY created_at ASC\r\n    LIMIT 1;\r\n\r\n    IF winner_id IS NULL THEN\r\n        RAISE EXCEPTION 'Nenhum contato v√°lido encontrado para fus√£o.';\r\n    END IF;\r\n\r\n    -- 2. Loop para processar os \"Perdedores\"\r\n    FOREACH id_iter IN ARRAY p_contact_ids\r\n    LOOP\r\n        IF id_iter <> winner_id THEN\r\n            loser_id := id_iter;\r\n\r\n            -- =========================================================\r\n            -- 1. LISTAS DO WHATSAPP (L√≥gica Cir√∫rgica) üß†\r\n            -- =========================================================\r\n            -- Passo A: Copiar o Vencedor para as listas do Perdedor\r\n            -- O segredo √© o \"WHERE NOT EXISTS\": s√≥ insere se o Vencedor AINDA N√ÉO ESTIVER na lista.\r\n            INSERT INTO public.whatsapp_list_members (lista_id, contato_id, created_at)\r\n            SELECT lista_id, winner_id, created_at\r\n            FROM public.whatsapp_list_members\r\n            WHERE contato_id = loser_id\r\n            AND lista_id NOT IN (\r\n                SELECT lista_id FROM public.whatsapp_list_members WHERE contato_id = winner_id\r\n            );\r\n\r\n            -- Passo B: Agora podemos apagar o perdedor de TODAS as listas sem medo\r\n            DELETE FROM public.whatsapp_list_members WHERE contato_id = loser_id;\r\n\r\n\r\n            -- =========================================================\r\n            -- 2. FUNIL DE VENDAS (Mesma l√≥gica segura)\r\n            -- =========================================================\r\n            -- Se o vencedor N√ÉO est√° no funil, trazemos o card do perdedor para ele.\r\n            IF NOT EXISTS (SELECT 1 FROM public.contatos_no_funil WHERE contato_id = winner_id) THEN\r\n                UPDATE public.contatos_no_funil SET contato_id = winner_id WHERE contato_id = loser_id;\r\n            END IF;\r\n            \r\n            -- Se o vencedor J√Å EST√Å (ou acabamos de mover), o registro do perdedor √© lixo. Tchau!\r\n            DELETE FROM public.contatos_no_funil WHERE contato_id = loser_id;\r\n\r\n\r\n            -- =========================================================\r\n            -- 3. FUNCION√ÅRIOS (V√≠nculo √önico)\r\n            -- =========================================================\r\n            IF NOT EXISTS (SELECT 1 FROM public.funcionarios WHERE contato_id = winner_id) THEN\r\n                 UPDATE public.funcionarios SET contato_id = winner_id WHERE contato_id = loser_id;\r\n            ELSE\r\n                 -- Se j√° tem v√≠nculo, removemos do perdedor para liberar a exclus√£o\r\n                 UPDATE public.funcionarios SET contato_id = NULL WHERE contato_id = loser_id;\r\n            END IF;\r\n\r\n\r\n            -- =========================================================\r\n            -- 4. CONVERSAS DO WHATSAPP (Unique Constraint no Telefone)\r\n            -- =========================================================\r\n            IF NOT EXISTS (SELECT 1 FROM public.whatsapp_conversations WHERE contato_id = winner_id) THEN\r\n                 UPDATE public.whatsapp_conversations SET contato_id = winner_id WHERE contato_id = loser_id;\r\n            ELSE\r\n                 -- Se o vencedor j√° tem conversa, soltamos o perdedor\r\n                 UPDATE public.whatsapp_conversations SET contato_id = NULL WHERE contato_id = loser_id;\r\n            END IF;\r\n            \r\n            -- Mensagens n√£o tem conflito, pode mover tudo\r\n            UPDATE public.whatsapp_messages SET contato_id = winner_id WHERE contato_id = loser_id;\r\n\r\n\r\n            -- =========================================================\r\n            -- 5. RELINKAGEM GERAL (Tabelas sem restri√ß√£o √∫nica cr√≠tica)\r\n            -- =========================================================\r\n            UPDATE public.telefones SET contato_id = winner_id WHERE contato_id = loser_id;\r\n            UPDATE public.emails SET contato_id = winner_id WHERE contato_id = loser_id;\r\n            UPDATE public.whatsapp_attachments SET contato_id = winner_id WHERE contato_id = loser_id;\r\n\r\n            -- Contratos e Comercial\r\n            UPDATE public.contratos SET contato_id = winner_id WHERE contato_id = loser_id;\r\n            UPDATE public.contratos SET corretor_id = winner_id WHERE corretor_id = loser_id;\r\n            UPDATE public.contratos SET conjuge_id = winner_id WHERE conjuge_id = loser_id;\r\n            UPDATE public.contratos SET representante_id = winner_id WHERE representante_id = loser_id;\r\n            \r\n            -- CRM e Atividades\r\n            UPDATE public.crm_notas SET contato_id = winner_id WHERE contato_id = loser_id;\r\n            UPDATE public.simulacoes SET contato_id = winner_id WHERE contato_id = loser_id;\r\n            UPDATE public.activities SET contato_id = winner_id WHERE contato_id = loser_id;\r\n            \r\n            -- Financeiro\r\n            UPDATE public.lancamentos SET favorecido_contato_id = winner_id WHERE favorecido_contato_id = loser_id;\r\n            UPDATE public.pedidos_compra_itens SET fornecedor_id = winner_id WHERE fornecedor_id = loser_id;\r\n\r\n            -- Empreendimentos\r\n            UPDATE public.empreendimentos SET incorporadora_id = winner_id WHERE incorporadora_id = loser_id;\r\n            UPDATE public.empreendimentos SET construtora_id = winner_id WHERE construtora_id = loser_id;\r\n\r\n            -- Refer√™ncias Cruzadas\r\n            UPDATE public.contatos SET conjuge_id = winner_id WHERE conjuge_id = loser_id;\r\n\r\n            -- =========================================================\r\n            -- 6. O FINAL: EXCLUIR O PERDEDOR\r\n            -- =========================================================\r\n            DELETE FROM public.contatos WHERE id = loser_id;\r\n            \r\n        END IF;\r\n    END LOOP;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "backfill_all_contact_meta_names",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.backfill_all_contact_meta_names()\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    updated_count integer;\r\nBEGIN\r\n    WITH updated_rows AS (\r\n        UPDATE public.contatos c\r\n        SET\r\n            meta_ad_name = ma.name,\r\n            meta_campaign_name = mc.name,\r\n            -- Garante que o ID da campanha seja preenchido se estiver faltando\r\n            meta_campaign_id = COALESCE(c.meta_campaign_id, ma.campaign_id)\r\n        FROM\r\n            public.meta_ads AS ma\r\n        LEFT JOIN\r\n            public.meta_campaigns AS mc ON ma.campaign_id = mc.id\r\n        WHERE\r\n            c.meta_ad_id = ma.id\r\n            -- Apenas atualiza se o nome do an√∫ncio ou da campanha estiverem vazios\r\n            AND (c.meta_ad_name IS NULL OR c.meta_campaign_name IS NULL)\r\n        RETURNING c.id\r\n    )\r\n    SELECT count(*) INTO updated_count FROM updated_rows;\r\n\r\n    RETURN 'Atualiza√ß√£o conclu√≠da. ' || updated_count || ' contatos foram atualizados.';\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "backfill_all_contact_meta_names_v2",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.backfill_all_contact_meta_names_v2()\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    updated_campaign_ids_count integer := 0;\r\n    updated_names_count integer := 0;\r\nBEGIN\r\n    -- ETAPA 1: Garante que o ID da campanha no contato seja preenchido,\r\n    -- buscando a informa√ß√£o a partir do an√∫ncio vinculado.\r\n    -- Isso corrige os contatos onde o 'meta_campaign_id' est√° nulo.\r\n    WITH updated_ids AS (\r\n        UPDATE public.contatos c\r\n        SET meta_campaign_id = ma.campaign_id\r\n        FROM public.meta_ads AS ma\r\n        WHERE c.meta_ad_id = ma.id\r\n          AND c.meta_campaign_id IS NULL -- Apenas atualiza se o ID da campanha do contato estiver faltando\r\n          AND ma.campaign_id IS NOT NULL\r\n        RETURNING c.id\r\n    )\r\n    SELECT count(*) INTO updated_campaign_ids_count FROM updated_ids;\r\n\r\n    -- ETAPA 2: Agora que os IDs de campanha est√£o corretos, atualiza os nomes\r\n    -- do an√∫ncio e da campanha que estiverem faltando.\r\n    WITH updated_names AS (\r\n        UPDATE public.contatos c\r\n        SET\r\n            meta_ad_name = (SELECT name FROM public.meta_ads WHERE id = c.meta_ad_id),\r\n            meta_campaign_name = (SELECT name FROM public.meta_campaigns WHERE id = c.meta_campaign_id)\r\n        WHERE\r\n            -- Condi√ß√£o para rodar:\r\n            -- Apenas em contatos que tenham um an√∫ncio ou campanha vinculados\r\n            (c.meta_ad_id IS NOT NULL OR c.meta_campaign_id IS NOT NULL)\r\n            -- E que ainda tenham o nome do an√∫ncio ou da campanha em branco\r\n            AND (c.meta_ad_name IS NULL OR c.meta_campaign_name IS NULL)\r\n        RETURNING c.id\r\n    )\r\n    SELECT count(*) INTO updated_names_count FROM updated_names;\r\n\r\n    RETURN 'Atualiza√ß√£o V2 conclu√≠da. IDs de campanha corrigidos: ' || updated_campaign_ids_count || '. Contatos com nomes atualizados: ' || updated_names_count;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "backfill_all_contact_meta_names_v3",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.backfill_all_contact_meta_names_v3()\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    contact_record RECORD;\r\n    ad_name_val TEXT;\r\n    campaign_id_val TEXT;\r\n    campaign_name_val TEXT;\r\n    updated_count INTEGER := 0;\r\nBEGIN\r\n    -- Percorre cada contato que tem um ID de an√∫ncio mas n√£o tem o nome preenchido.\r\n    FOR contact_record IN\r\n        SELECT id, meta_ad_id, meta_campaign_id\r\n        FROM public.contatos\r\n        WHERE meta_ad_id IS NOT NULL AND (meta_ad_name IS NULL OR meta_campaign_name IS NULL)\r\n    LOOP\r\n        -- Reseta as vari√°veis para cada loop\r\n        ad_name_val := NULL;\r\n        campaign_id_val := contact_record.meta_campaign_id;\r\n        campaign_name_val := NULL;\r\n\r\n        -- 1. Busca o nome do an√∫ncio e o ID da campanha a partir da tabela de an√∫ncios.\r\n        SELECT \"name\", campaign_id\r\n        INTO ad_name_val, campaign_id_val\r\n        FROM public.meta_ads\r\n        WHERE id = contact_record.meta_ad_id;\r\n\r\n        -- 2. Se encontrou um ID de campanha, busca o nome da campanha.\r\n        IF campaign_id_val IS NOT NULL THEN\r\n            SELECT \"name\"\r\n            INTO campaign_name_val\r\n            FROM public.meta_campaigns\r\n            WHERE id = campaign_id_val;\r\n        END IF;\r\n\r\n        -- 3. Se encontrou algum nome para atualizar, executa o UPDATE no contato espec√≠fico.\r\n        IF ad_name_val IS NOT NULL OR campaign_name_val IS NOT NULL THEN\r\n            UPDATE public.contatos\r\n            SET\r\n                meta_ad_name = COALESCE(ad_name_val, meta_ad_name), -- S√≥ atualiza se encontrou um nome novo\r\n                meta_campaign_name = COALESCE(campaign_name_val, meta_campaign_name),\r\n                meta_campaign_id = COALESCE(campaign_id_val, meta_campaign_id) -- Garante que o ID tamb√©m seja salvo\r\n            WHERE id = contact_record.id;\r\n\r\n            updated_count := updated_count + 1;\r\n        END IF;\r\n    END LOOP;\r\n\r\n    RETURN 'Atualiza√ß√£o V3 conclu√≠da. ' || updated_count || ' contatos foram processados e atualizados.';\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "binary_quantize",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.binary_quantize(halfvec)\n RETURNS bit\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_binary_quantize$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "binary_quantize",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.binary_quantize(vector)\n RETURNS bit\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$binary_quantize$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "buscar_contatos_geral",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.buscar_contatos_geral(p_search_term text)\n RETURNS TABLE(id bigint, nome text, razao_social text, nome_fantasia text, cpf text, cnpj text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT\r\n        c.id,\r\n        c.nome,\r\n        c.razao_social,\r\n        c.nome_fantasia,\r\n        c.cpf,\r\n        c.cnpj\r\n    FROM\r\n        public.contatos c\r\n    WHERE\r\n        p_search_term IS NULL OR p_search_term = '' OR\r\n        c.nome ILIKE '%' || p_search_term || '%' OR\r\n        c.razao_social ILIKE '%' || p_search_term || '%' OR\r\n        c.nome_fantasia ILIKE '%' || p_search_term || '%' OR\r\n        c.cpf ILIKE '%' || p_search_term || '%' OR\r\n        c.cnpj ILIKE '%' || p_search_term || '%'\r\n    LIMIT 10;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "buscar_contatos_geral",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.buscar_contatos_geral(p_search_term text, p_organizacao_id bigint)\n RETURNS TABLE(id bigint, nome text, razao_social text)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT c.id, c.nome, c.razao_social\r\n    FROM public.contatos AS c\r\n    WHERE c.organizacao_id = p_organizacao_id\r\n      AND (\r\n        c.nome ILIKE '%' || p_search_term || '%' OR\r\n        c.razao_social ILIKE '%' || p_search_term || '%'\r\n      )\r\n    LIMIT 20;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "buscar_fornecedores",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.buscar_fornecedores(search_term text)\n RETURNS TABLE(id bigint, nome_exibicao text, detalhe text)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n    SELECT\r\n        c.id,\r\n        COALESCE(c.razao_social, c.nome) AS nome_exibicao,\r\n        COALESCE(c.nome_fantasia, c.cnpj, c.cpf) AS detalhe\r\n    FROM\r\n        public.contatos c\r\n    WHERE\r\n        search_term IS NULL OR search_term = ''\r\n        OR unaccent(c.nome) ILIKE unaccent('%' || search_term || '%')\r\n        OR unaccent(c.razao_social) ILIKE unaccent('%' || search_term || '%')\r\n        OR unaccent(c.nome_fantasia) ILIKE unaccent('%' || search_term || '%')\r\n    LIMIT 20;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "buscar_lancamentos_filtrados",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.buscar_lancamentos_filtrados(p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date, p_search_term text DEFAULT NULL::text, p_empresa_ids bigint[] DEFAULT NULL::bigint[], p_conta_ids bigint[] DEFAULT NULL::bigint[], p_categoria_ids bigint[] DEFAULT NULL::bigint[], p_empreendimento_ids bigint[] DEFAULT NULL::bigint[], p_etapa_ids bigint[] DEFAULT NULL::bigint[], p_tipos text[] DEFAULT NULL::text[], p_status text[] DEFAULT NULL::text[], p_sort_key text DEFAULT 'data_relevante'::text, p_sort_direction text DEFAULT 'desc'::text, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0)\n RETURNS TABLE(id bigint, descricao text, valor numeric, data_transacao date, tipo text, status text, conta_id bigint, categoria_id bigint, empreendimento_id bigint, etapa_id bigint, pedido_compra_id bigint, funcionario_id bigint, created_at timestamp with time zone, data_vencimento date, data_pagamento date, parcela_info text, recorrencia_id bigint, favorecido_contato_id bigint, conciliado boolean, id_transacao_externa text, empresa_id bigint, criado_por_usuario_id uuid, conta_destino_id bigint, observacao text, mes_competencia date, data_relevante date, total_count bigint)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    WITH lancamentos_com_relevancia AS (\r\n        SELECT \r\n            l.*,\r\n            CASE\r\n                WHEN l.status = 'Pago' AND l.data_pagamento IS NOT NULL THEN l.data_pagamento\r\n                WHEN l.status = 'Pendente' AND l.data_vencimento IS NOT NULL THEN l.data_vencimento\r\n                ELSE l.data_transacao\r\n            END AS data_relevante\r\n        FROM public.lancamentos l\r\n    ),\r\n    filtered_lancamentos AS (\r\n        SELECT *\r\n        FROM lancamentos_com_relevancia\r\n        WHERE\r\n            (p_start_date IS NULL OR data_relevante >= p_start_date) AND\r\n            (p_end_date IS NULL OR data_relevante <= p_end_date) AND\r\n            (p_search_term IS NULL OR p_search_term = '' OR descricao ILIKE '%' || p_search_term || '%') AND\r\n            (p_empresa_ids IS NULL OR array_length(p_empresa_ids, 1) IS NULL OR empresa_id = ANY(p_empresa_ids)) AND\r\n            (p_conta_ids IS NULL OR array_length(p_conta_ids, 1) IS NULL OR (conta_id = ANY(p_conta_ids) OR conta_destino_id = ANY(p_conta_ids))) AND\r\n            (p_categoria_ids IS NULL OR array_length(p_categoria_ids, 1) IS NULL OR categoria_id = ANY(p_categoria_ids)) AND\r\n            (p_empreendimento_ids IS NULL OR array_length(p_empreendimento_ids, 1) IS NULL OR empreendimento_id = ANY(p_empreendimento_ids)) AND\r\n            (p_etapa_ids IS NULL OR array_length(p_etapa_ids, 1) IS NULL OR etapa_id = ANY(p_etapa_ids)) AND\r\n            (p_tipos IS NULL OR array_length(p_tipos, 1) IS NULL OR tipo = ANY(p_tipos))\r\n    ),\r\n    counted_lancamentos AS (\r\n        SELECT *, COUNT(*) OVER() as full_count FROM filtered_lancamentos\r\n    )\r\n    SELECT \r\n        c.id, c.descricao, c.valor, c.data_transacao, c.tipo, c.status, c.conta_id, c.categoria_id, c.empreendimento_id, c.etapa_id, c.pedido_compra_id,\r\n        c.funcionario_id, c.created_at, c.data_vencimento, c.data_pagamento, c.parcela_info, c.recorrencia_id, c.favorecido_contato_id,\r\n        c.conciliado, c.id_transacao_externa, c.empresa_id, c.criado_por_usuario_id, c.conta_destino_id, c.observacao, c.mes_competencia, c.data_relevante,\r\n        c.full_count as total_count\r\n    FROM counted_lancamentos c\r\n    ORDER BY\r\n        CASE WHEN p_sort_key = 'data_relevante' AND p_sort_direction = 'asc' THEN c.data_relevante END ASC NULLS LAST,\r\n        CASE WHEN p_sort_key = 'data_relevante' AND p_sort_direction <> 'asc' THEN c.data_relevante END DESC NULLS LAST,\r\n        CASE WHEN p_sort_key = 'descricao' AND p_sort_direction = 'asc' THEN c.descricao END ASC NULLS LAST,\r\n        CASE WHEN p_sort_key = 'descricao' AND p_sort_direction <> 'asc' THEN c.descricao END DESC NULLS LAST\r\n    LIMIT p_limit OFFSET p_offset;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "buscar_materiais",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.buscar_materiais(search_term text)\n RETURNS TABLE(id bigint, descricao text, unidade_medida text, preco_unitario numeric, categoria text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT\r\n        m.id,\r\n        m.descricao,\r\n        m.unidade_medida,\r\n        m.preco_unitario,\r\n        m.Grupo AS categoria\r\n    FROM\r\n        public.materiais m\r\n    WHERE\r\n        -- Busca case-insensitive, sem a camada de acentua√ß√£o\r\n        m.descricao ILIKE '%' || search_term || '%'\r\n    LIMIT 10;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "calcular_dados_ponto_funcionario",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.calcular_dados_ponto_funcionario(p_funcionario_id bigint, p_mes_referencia date)\n RETURNS TABLE(total_dias_trabalhados bigint, total_dias_uteis_mes integer, total_horas_trabalhadas_interval interval, total_horas_previstas_interval interval, saldo_banco_horas_interval interval, total_faltas integer)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    WITH mes_dados AS (\r\n        SELECT\r\n            SUM(CASE WHEN bhr.horas_trabalhadas > '0 seconds' THEN 1 ELSE 0 END) AS dias_trabalhados,\r\n            SUM(bhr.horas_previstas) AS total_previsto,\r\n            SUM(bhr.horas_trabalhadas) AS total_trabalhado,\r\n            SUM(bhr.saldo_dia_contabilizado) AS saldo_total,\r\n            SUM(CASE WHEN bhr.horas_previstas > '0 seconds' AND bhr.horas_trabalhadas = '0 seconds' AND NOT EXISTS (SELECT 1 FROM abonos a WHERE a.funcionario_id = bhr.funcionario_id AND a.data_abono = bhr.data_registro) THEN 1 ELSE 0 END) AS dias_falta\r\n        FROM\r\n            public.banco_horas_registros bhr\r\n        WHERE\r\n            bhr.funcionario_id = p_funcionario_id\r\n            AND date_trunc('month', bhr.data_registro) = date_trunc('month', p_mes_referencia)\r\n    ),\r\n    dias_uteis AS (\r\n        SELECT COUNT(DISTINCT jd.dia_semana)::INT as count_uteis\r\n        FROM public.funcionarios f\r\n        JOIN public.jornada_detalhes jd ON f.jornada_id = jd.jornada_id\r\n        WHERE f.id = p_funcionario_id\r\n    )\r\n    SELECT\r\n        COALESCE(md.dias_trabalhados, 0)::BIGINT,\r\n        -- Este c√°lculo de dias √∫teis √© uma aproxima√ß√£o, o ideal seria refatorar se precisar de exatid√£o\r\n        (SELECT COUNT(*)::INT FROM dias_uteis),\r\n        COALESCE(md.total_trabalhado, '0 seconds'),\r\n        COALESCE(md.total_previsto, '0 seconds'),\r\n        COALESCE(md.saldo_total, '0 seconds'),\r\n        COALESCE(md.dias_falta, 0)::INT\r\n    FROM\r\n        mes_dados md;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "calcular_dias_uteis",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.calcular_dias_uteis(p_mes_referencia date)\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_dias_uteis integer := 0;\r\n    v_dia date;\r\nBEGIN\r\n    FOR v_dia IN \r\n        SELECT generate_series(\r\n            date_trunc('month', p_mes_referencia), \r\n            date_trunc('month', p_mes_referencia) + interval '1 month' - interval '1 day',\r\n            '1 day'\r\n        )::date\r\n    LOOP\r\n        -- Conta apenas se for dia de semana (1=Seg, 5=Sex) E n√£o for feriado\r\n        IF extract(isodow from v_dia) < 6 AND NOT EXISTS (SELECT 1 FROM public.feriados WHERE data_feriado = v_dia) THEN\r\n            v_dias_uteis := v_dias_uteis + 1;\r\n        END IF;\r\n    END LOOP;\r\n    RETURN v_dias_uteis;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "calcular_inss",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.calcular_inss(salario_base numeric)\n RETURNS numeric\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    inss_faixa_1 numeric := 1412.00;\r\n    inss_faixa_2 numeric := 2666.68;\r\n    inss_faixa_3 numeric := 4000.03;\r\n    inss_faixa_4 numeric := 7786.02;\r\n    desconto numeric := 0;\r\nBEGIN\r\n    IF salario_base <= inss_faixa_1 THEN\r\n        desconto := salario_base * 0.075;\r\n    ELSIF salario_base <= inss_faixa_2 THEN\r\n        desconto := (inss_faixa_1 * 0.075) + \r\n                    ((salario_base - inss_faixa_1) * 0.09);\r\n    ELSIF salario_base <= inss_faixa_3 THEN\r\n        desconto := (inss_faixa_1 * 0.075) + \r\n                    ((inss_faixa_2 - inss_faixa_1) * 0.09) +\r\n                    ((salario_base - inss_faixa_2) * 0.12);\r\n    ELSIF salario_base <= inss_faixa_4 THEN\r\n        desconto := (inss_faixa_1 * 0.075) +\r\n                    ((inss_faixa_2 - inss_faixa_1) * 0.09) +\r\n                    ((inss_faixa_3 - inss_faixa_2) * 0.12) +\r\n                    ((salario_base - inss_faixa_3) * 0.14);\r\n    ELSE\r\n        desconto := (inss_faixa_1 * 0.075) +\r\n                    ((inss_faixa_2 - inss_faixa_1) * 0.09) +\r\n                    ((inss_faixa_3 - inss_faixa_2) * 0.12) +\r\n                    ((inss_faixa_4 - inss_faixa_3) * 0.14);\r\n    END IF;\r\n\r\n    RETURN TRUNC(desconto, 2);\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "calcular_kpi",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.calcular_kpi(p_kpi_id bigint)\n RETURNS numeric\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    kpi_formula text;\r\n    kpi_nome text;\r\n    indice_record record;\r\n    indice_valor numeric;\r\nBEGIN\r\n    -- Busca a f√≥rmula do KPI\r\n    SELECT formula, nome_kpi INTO kpi_formula, kpi_nome\r\n    FROM public.kpis_financeiros\r\n    WHERE id = p_kpi_id;\r\n\r\n    IF kpi_formula IS NULL THEN\r\n        RAISE EXCEPTION 'KPI com ID % n√£o encontrado.', p_kpi_id;\r\n    END IF;\r\n\r\n    -- Loop para substituir cada [NOME_INDICE] pelo seu valor calculado\r\n    FOR indice_record IN SELECT id, nome_indice FROM public.indices_financeiros\r\n    LOOP\r\n        -- Verifica se o √≠ndice atual est√° na f√≥rmula\r\n        IF position(('[' || indice_record.nome_indice || ']') IN kpi_formula) > 0 THEN\r\n            -- Calcula o valor do √≠ndice chamando a outra fun√ß√£o\r\n            SELECT calcular_valor_indice(indice_record.id) INTO indice_valor;\r\n            \r\n            -- Substitui o placeholder pelo valor num√©rico\r\n            kpi_formula := replace(kpi_formula, '[' || indice_record.nome_indice || ']', COALESCE(indice_valor, 0)::text);\r\n        END IF;\r\n    END LOOP;\r\n    \r\n    -- Valida√ß√£o final para garantir que n√£o h√° mais placeholders\r\n    IF kpi_formula ~ '\\[[A-Z_]+\\]' THEN\r\n        RAISE EXCEPTION 'F√≥rmula para o KPI \"%\" ainda cont√©m √≠ndices n√£o resolvidos: %', kpi_nome, kpi_formula;\r\n    END IF;\r\n\r\n    -- Avalia a express√£o matem√°tica de forma segura com plv8\r\n    BEGIN\r\n        RETURN plv8.eval(kpi_formula);\r\n    EXCEPTION WHEN others THEN\r\n        RAISE EXCEPTION 'Erro ao avaliar a f√≥rmula para o KPI \"%\": %. F√≥rmula resultante: %', kpi_nome, SQLERRM, kpi_formula;\r\n    END;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "calcular_kpi_financeiro",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.calcular_kpi_financeiro(p_organizacao_id bigint, p_filtros jsonb)\n RETURNS numeric\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_total numeric;\r\n    -- Vari√°veis para os filtros\r\n    v_filtro_contas jsonb;\r\n    v_filtro_categorias jsonb;\r\n    v_filtro_status jsonb;\r\n    v_filtro_tipo jsonb;\r\n    v_filtro_empresa jsonb;\r\n    v_filtro_empreendimento jsonb;\r\n    v_filtro_etapa jsonb;\r\n    v_data_inicio text;\r\n    v_data_fim text;\r\n    v_favorecido_id bigint;\r\n    v_ignorar_transferencias boolean;\r\nBEGIN\r\n    -- 1. Extra√ß√£o dos dados do JSON\r\n    v_filtro_contas := p_filtros->'contaIds';\r\n    v_filtro_categorias := p_filtros->'categoriaIds';\r\n    v_filtro_status := p_filtros->'status';\r\n    v_filtro_tipo := p_filtros->'tipo';\r\n    v_filtro_empresa := p_filtros->'empresaIds';\r\n    v_filtro_empreendimento := p_filtros->'empreendimentoIds';\r\n    v_filtro_etapa := p_filtros->'etapaIds';\r\n    \r\n    v_data_inicio := NULLIF(TRIM(p_filtros->>'startDate'), '');\r\n    v_data_fim := NULLIF(TRIM(p_filtros->>'endDate'), '');\r\n    \r\n    -- Tratamento para favorecido\r\n    IF (p_filtros->>'favorecidoId') IS NOT NULL AND (p_filtros->>'favorecidoId') <> 'null' THEN\r\n        v_favorecido_id := (p_filtros->>'favorecidoId')::bigint;\r\n    ELSE\r\n        v_favorecido_id := NULL;\r\n    END IF;\r\n\r\n    -- Tratamento para Ignorar Transfer√™ncias\r\n    v_ignorar_transferencias := COALESCE((p_filtros->>'ignoreTransfers')::boolean, false);\r\n\r\n    -- 2. A Query de C√°lculo\r\n    -- IMPORTANTE: Usamos CASE para subtrair despesas, garantindo que o saldo bata com o painel principal\r\n    SELECT COALESCE(SUM(valor), 0)\r\n    INTO v_total\r\n    FROM lancamentos\r\n    WHERE organizacao_id = p_organizacao_id\r\n    \r\n    -- Filtro de DATA\r\n    AND (\r\n        CASE \r\n            WHEN v_data_inicio IS NOT NULL THEN \r\n                COALESCE(data_pagamento, data_transacao, data_vencimento) >= v_data_inicio::date\r\n            ELSE TRUE \r\n        END\r\n    )\r\n    AND (\r\n        CASE \r\n            WHEN v_data_fim IS NOT NULL THEN \r\n                COALESCE(data_pagamento, data_transacao, data_vencimento) <= v_data_fim::date\r\n            ELSE TRUE \r\n        END\r\n    )\r\n\r\n    -- Filtro: Ignorar Transfer√™ncias\r\n    AND (\r\n        CASE \r\n            WHEN v_ignorar_transferencias IS TRUE THEN transferencia_id IS NULL\r\n            ELSE TRUE \r\n        END\r\n    )\r\n\r\n    -- Filtro: Favorecido\r\n    AND (\r\n        CASE \r\n            WHEN v_favorecido_id IS NOT NULL THEN favorecido_contato_id = v_favorecido_id\r\n            ELSE TRUE \r\n        END\r\n    )\r\n\r\n    -- Filtro Inteligente de STATUS (A CORRE√á√ÉO PRINCIPAL üåü)\r\n    AND (\r\n        CASE WHEN jsonb_array_length(v_filtro_status) > 0 THEN\r\n            (\r\n                -- Se o status exato estiver na lista\r\n                status = ANY(SELECT jsonb_array_elements_text(v_filtro_status))\r\n                OR\r\n                -- SE \"Pago\" foi selecionado, TAMB√âM trazemos \"Conciliado\"\r\n                (v_filtro_status @> '[\"Pago\"]'::jsonb AND status = 'Conciliado')\r\n            )\r\n        ELSE TRUE END\r\n    )\r\n\r\n    -- Outros Filtros de Arrays\r\n    AND (\r\n        CASE WHEN jsonb_array_length(v_filtro_contas) > 0 \r\n        THEN conta_id = ANY(SELECT jsonb_array_elements_text(v_filtro_contas)::bigint)\r\n        ELSE TRUE END\r\n    )\r\n    AND (\r\n        CASE WHEN jsonb_array_length(v_filtro_categorias) > 0 \r\n        THEN categoria_id = ANY(SELECT jsonb_array_elements_text(v_filtro_categorias)::bigint)\r\n        ELSE TRUE END\r\n    )\r\n    AND (\r\n        CASE WHEN jsonb_array_length(v_filtro_tipo) > 0 \r\n        THEN tipo = ANY(SELECT jsonb_array_elements_text(v_filtro_tipo))\r\n        ELSE TRUE END\r\n    )\r\n    AND (\r\n        CASE WHEN jsonb_array_length(v_filtro_empresa) > 0 \r\n        THEN empresa_id = ANY(SELECT jsonb_array_elements_text(v_filtro_empresa)::bigint)\r\n        ELSE TRUE END\r\n    )\r\n    AND (\r\n        CASE WHEN jsonb_array_length(v_filtro_empreendimento) > 0 \r\n        THEN empreendimento_id = ANY(SELECT jsonb_array_elements_text(v_filtro_empreendimento)::bigint)\r\n        ELSE TRUE END\r\n    )\r\n    AND (\r\n        CASE WHEN jsonb_array_length(v_filtro_etapa) > 0 \r\n        THEN etapa_id = ANY(SELECT jsonb_array_elements_text(v_filtro_etapa)::bigint)\r\n        ELSE TRUE END\r\n    );\r\n\r\n    RETURN v_total;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "calcular_kpi_generico",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.calcular_kpi_generico(p_organizacao_id bigint, p_tabela_fonte text, p_operacao text, p_coluna_alvo text, p_filtros jsonb)\n RETURNS numeric\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    query_sql TEXT;\r\n    resultado NUMERIC;\r\n    filtro_chave TEXT;\r\n    filtro_valor JSONB;\r\nBEGIN\r\n    -- 1. VALIDA√á√ÉO DE SEGURAN√áA: Adicionamos 'lancamentos' na lista!\r\n    IF p_tabela_fonte NOT IN ('contratos', 'funcionarios', 'contatos_no_funil', 'pedidos_compra', 'lancamentos') THEN\r\n        RAISE EXCEPTION 'Acesso negado. A tabela % n√£o √© permitida para KPIs.', p_tabela_fonte;\r\n    END IF;\r\n\r\n    -- 2. CONSTRU√á√ÉO DA BASE DA CONSULTA\r\n    IF p_operacao = 'COUNT' THEN\r\n        query_sql := format('SELECT COUNT(*) FROM public.%I', p_tabela_fonte);\r\n    ELSIF p_operacao = 'SUM' THEN\r\n        query_sql := format('SELECT SUM(%I) FROM public.%I', p_coluna_alvo, p_tabela_fonte);\r\n    ELSE\r\n        RAISE EXCEPTION 'Opera√ß√£o de KPI inv√°lida: %', p_operacao;\r\n    END IF;\r\n\r\n    -- 3. FILTRO DE SEGURAN√áA PRINCIPAL\r\n    query_sql := query_sql || format(' WHERE organizacao_id = %L', p_organizacao_id);\r\n\r\n    -- 4. APLICA√á√ÉO DIN√ÇMICA DOS FILTROS ADICIONAIS\r\n    IF p_filtros IS NOT NULL AND jsonb_typeof(p_filtros) = 'object' THEN\r\n        FOR filtro_chave, filtro_valor IN SELECT key, value FROM jsonb_each(p_filtros)\r\n        LOOP\r\n            IF filtro_valor IS NOT NULL AND filtro_valor::text <> 'null' AND filtro_valor::text <> '[]' AND filtro_valor::text <> '\"\"' THEN\r\n                 query_sql := query_sql || format(' AND %I = %L', filtro_chave, filtro_valor::text);\r\n            END IF;\r\n        END LOOP;\r\n    END IF;\r\n\r\n    -- 5. EXECU√á√ÉO E RETORNO\r\n    EXECUTE query_sql INTO resultado;\r\n\r\n    RETURN COALESCE(resultado, 0);\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "calcular_previsao_folha",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.calcular_previsao_folha(p_organizacao_id bigint, p_mes_ref text)\n RETURNS TABLE(custo_total numeric, dias_uteis integer)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_inicio_mes date;\r\n  v_fim_mes date;\r\n  \r\n  -- Vari√°veis de Loop e C√°lculo\r\n  r_func record;\r\n  v_inicio_efetivo date;\r\n  v_fim_efetivo date;\r\n  v_dias_corridos_trab int;\r\n  v_dias_uteis_trab numeric; -- Usando numeric para aceitar 0.5 (meio per√≠odo)\r\n  v_custo_individual numeric;\r\n  v_custo_total_acumulado numeric := 0;\r\n  \r\n  -- Auxiliares para Dias √öteis do M√™s (Refer√™ncia)\r\n  v_dia_loop date;\r\n  v_is_feriado boolean;\r\n  v_tipo_feriado text;\r\n  v_dias_uteis_mes_cheio int := 0;\r\nBEGIN\r\n  -- 1. Definir o intervalo do m√™s\r\n  v_inicio_mes := to_date(p_mes_ref, 'YYYY-MM-DD');\r\n  v_fim_mes := (v_inicio_mes + interval '1 month' - interval '1 day')::date;\r\n\r\n  -- 2. Calcular Dias √öteis do M√™s Cheio (para exibir no widget)\r\n  v_dia_loop := v_inicio_mes;\r\n  WHILE v_dia_loop <= v_fim_mes LOOP\r\n    IF EXTRACT(DOW FROM v_dia_loop) NOT IN (0, 6) THEN -- 0=Dom, 6=S√°b\r\n      SELECT tipo INTO v_tipo_feriado FROM feriados WHERE organizacao_id = p_organizacao_id AND data_feriado = v_dia_loop;\r\n      \r\n      IF v_tipo_feriado IS NULL THEN\r\n        v_dias_uteis_mes_cheio := v_dias_uteis_mes_cheio + 1;\r\n      ELSIF v_tipo_feriado = 'Meio Per√≠odo' THEN\r\n         -- Para refer√™ncia visual, meio per√≠odo conta como dia de trabalho? Vamos contar como 1 dia √∫til na agenda.\r\n         v_dias_uteis_mes_cheio := v_dias_uteis_mes_cheio + 1; \r\n      END IF;\r\n    END IF;\r\n    v_dia_loop := v_dia_loop + 1;\r\n  END LOOP;\r\n\r\n  -- 3. Loop por Funcion√°rio (C√°lculo Financeiro Individual)\r\n  FOR r_func IN\r\n    SELECT \r\n      f.id, \r\n      f.admission_date, \r\n      f.demission_date,\r\n      h.salario_base, \r\n      h.valor_diaria\r\n    FROM funcionarios f\r\n    LEFT JOIN LATERAL (\r\n      SELECT salario_base, valor_diaria \r\n      FROM historico_salarial \r\n      WHERE funcionario_id = f.id \r\n      ORDER BY data_inicio_vigencia DESC \r\n      LIMIT 1\r\n    ) h ON true\r\n    WHERE f.organizacao_id = p_organizacao_id\r\n      AND f.status = 'Ativo'\r\n      AND f.admission_date <= v_fim_mes::text\r\n      AND (f.demission_date IS NULL OR f.demission_date >= v_inicio_mes)\r\n  LOOP\r\n    \r\n    -- A. Define in√≠cio e fim efetivos deste funcion√°rio\r\n    v_inicio_efetivo := GREATEST(v_inicio_mes, r_func.admission_date::date);\r\n    \r\n    IF r_func.demission_date IS NOT NULL THEN\r\n       v_fim_efetivo := LEAST(v_fim_mes, r_func.demission_date::date);\r\n    ELSE\r\n       v_fim_efetivo := v_fim_mes;\r\n    END IF;\r\n\r\n    -- B. C√°lculo Mensalista (Regra 30 dias - Proporcional)\r\n    v_dias_corridos_trab := (v_fim_efetivo - v_inicio_efetivo) + 1;\r\n    IF v_dias_corridos_trab > 30 THEN v_dias_corridos_trab := 30; END IF; -- Trava teto 30\r\n\r\n    -- C. C√°lculo Diarista (Dias √öteis Exatos)\r\n    v_dias_uteis_trab := 0;\r\n    v_dia_loop := v_inicio_efetivo;\r\n    \r\n    WHILE v_dia_loop <= v_fim_efetivo LOOP\r\n      IF EXTRACT(DOW FROM v_dia_loop) NOT IN (0, 6) THEN\r\n        SELECT tipo INTO v_tipo_feriado FROM feriados WHERE organizacao_id = p_organizacao_id AND data_feriado = v_dia_loop;\r\n        \r\n        IF v_tipo_feriado IS NULL THEN\r\n          v_dias_uteis_trab := v_dias_uteis_trab + 1;\r\n        ELSIF v_tipo_feriado = 'Meio Per√≠odo' THEN\r\n           v_dias_uteis_trab := v_dias_uteis_trab + 0.5; -- Paga meia di√°ria\r\n        END IF;\r\n      END IF;\r\n      v_dia_loop := v_dia_loop + 1;\r\n    END LOOP;\r\n\r\n    -- D. Soma Valor\r\n    v_custo_individual := 0;\r\n\r\n    IF r_func.salario_base > 0 THEN\r\n      -- Mensalista\r\n      IF v_dias_corridos_trab >= 30 THEN\r\n         v_custo_individual := r_func.salario_base;\r\n      ELSE\r\n         v_custo_individual := (r_func.salario_base / 30.0) * v_dias_corridos_trab;\r\n      END IF;\r\n    ELSE\r\n      -- Diarista\r\n      v_custo_individual := (COALESCE(r_func.valor_diaria, 0) * v_dias_uteis_trab);\r\n    END IF;\r\n\r\n    v_custo_total_acumulado := v_custo_total_acumulado + v_custo_individual;\r\n    \r\n  END LOOP;\r\n\r\n  -- 4. Retorno Final\r\n  custo_total := ROUND(v_custo_total_acumulado, 2);\r\n  dias_uteis := v_dias_uteis_mes_cheio;\r\n  RETURN NEXT;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "calcular_ranking_atrasos",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.calcular_ranking_atrasos(p_organizacao_id bigint, p_mes_ref text)\n RETURNS TABLE(nome text, cargo text, qtd bigint)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  WITH batidas_vencedoras AS (\r\n    SELECT DISTINCT ON (p.funcionario_id, p.data_hora::date)\r\n      p.funcionario_id,\r\n      p.data_hora::date as data_dia,\r\n      p.data_hora::time as hora_chegada,\r\n      EXTRACT(DOW FROM p.data_hora)::integer as dia_semana\r\n    FROM pontos p\r\n    WHERE p.organizacao_id = p_organizacao_id\r\n      AND to_char(p.data_hora, 'YYYY-MM') = p_mes_ref\r\n      AND p.tipo_registro = 'Entrada'\r\n    -- A MUDAN√áA M√ÅGICA EST√Å AQUI EMBAIXO:\r\n    -- 1¬∫ Prioridade: Editado Manualmente (TRUE vem antes de FALSE)\r\n    -- 2¬∫ Prioridade: Data de Cria√ß√£o (Mais recente ganha)\r\n    ORDER BY p.funcionario_id, p.data_hora::date, p.editado_manualmente DESC, p.created_at DESC\r\n  )\r\n  SELECT \r\n    f.full_name as nome,\r\n    COALESCE(c.nome, 'Cargo n√£o definido') as cargo,\r\n    COUNT(*) as qtd\r\n  FROM batidas_vencedoras bv\r\n  JOIN funcionarios f ON f.id = bv.funcionario_id\r\n  LEFT JOIN cargos c ON f.cargo_id = c.id\r\n  JOIN jornadas j ON f.jornada_id = j.id\r\n  JOIN jornada_detalhes jd ON j.id = jd.jornada_id AND jd.dia_semana = bv.dia_semana\r\n  WHERE \r\n    jd.horario_entrada IS NOT NULL\r\n    -- Compara: Chegada > (Entrada + Toler√¢ncia)\r\n    AND bv.hora_chegada > (jd.horario_entrada + (COALESCE(j.tolerancia_minutos, 0) || ' minutes')::interval)\r\n  GROUP BY f.full_name, c.nome\r\n  ORDER BY qtd DESC\r\n  LIMIT 5;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "calcular_ranking_faltas",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.calcular_ranking_faltas(p_organizacao_id bigint, p_mes_ref text)\n RETURNS TABLE(nome text, cargo text, qtd bigint)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_inicio_mes date;\r\n    v_fim_mes date;\r\n    v_ontem date;\r\n    v_timezone text := 'America/Sao_Paulo';\r\nBEGIN\r\n    v_inicio_mes := (p_mes_ref || '-01')::date;\r\n    v_fim_mes := (v_inicio_mes + interval '1 month' - interval '1 day')::date;\r\n    v_ontem := (NOW() AT TIME ZONE v_timezone)::date - 1;\r\n\r\n    RETURN QUERY\r\n    WITH calendario_mes AS (\r\n        -- Gera dias at√© ONTEM\r\n        SELECT generate_series(v_inicio_mes, LEAST(v_fim_mes, v_ontem), '1 day'::interval)::date AS data_dia\r\n    )\r\n    SELECT \r\n        f.full_name::text,\r\n        COALESCE(c.nome, 'Cargo n/d')::text,\r\n        COUNT(*)::bigint\r\n    FROM calendario_mes cm\r\n    CROSS JOIN funcionarios f\r\n    LEFT JOIN cargos c ON f.cargo_id = c.id\r\n    \r\n    -- Filtra apenas dias de trabalho configurados na jornada\r\n    INNER JOIN jornada_detalhes jd ON f.jornada_id = jd.jornada_id \r\n         AND jd.dia_semana = EXTRACT(DOW FROM cm.data_dia)::integer\r\n         AND jd.horario_entrada IS NOT NULL -- Se for NULL, √© folga\r\n         \r\n    -- Verifica√ß√µes de Imunidade\r\n    LEFT JOIN feriados fer ON fer.data_feriado = cm.data_dia AND fer.organizacao_id = p_organizacao_id\r\n    LEFT JOIN abonos a ON a.funcionario_id = f.id AND a.data_abono = cm.data_dia\r\n    LEFT JOIN pontos p ON p.funcionario_id = f.id AND (p.data_hora AT TIME ZONE v_timezone)::date = cm.data_dia\r\n    \r\n    WHERE f.status = 'Ativo' \r\n      AND f.organizacao_id = p_organizacao_id\r\n      -- Filtro de contrato\r\n      AND (CASE WHEN f.admission_date IS NULL OR TRIM(f.admission_date::text) = '' THEN NULL ELSE f.admission_date::date END) <= cm.data_dia\r\n      AND ((CASE WHEN f.demission_date IS NULL OR TRIM(f.demission_date::text) = '' THEN NULL ELSE f.demission_date::date END) IS NULL \r\n           OR (CASE WHEN f.demission_date IS NULL OR TRIM(f.demission_date::text) = '' THEN NULL ELSE f.demission_date::date END) >= cm.data_dia)\r\n      -- Condi√ß√µes da Falta\r\n      AND fer.id IS NULL \r\n      AND a.id IS NULL   \r\n      AND p.id IS NULL   \r\n      \r\n    GROUP BY f.full_name, c.nome\r\n    ORDER BY COUNT(*) DESC\r\n    LIMIT 5;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "calcular_resumo_ponto_mensal",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.calcular_resumo_ponto_mensal(p_funcionario_id bigint, p_mes_referencia text)\n RETURNS TABLE(dias_trabalhados integer, horas_trabalhadas_formatado text, faltas integer, valor_a_pagar numeric)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_start_date date;\r\n    v_end_date date;\r\n    v_employee record;\r\n    v_total_minutos_trabalhados numeric;\r\n    v_dias_uteis integer;\r\nBEGIN\r\n    -- Define o primeiro e o √∫ltimo dia do m√™s de refer√™ncia\r\n    v_start_date := to_date(p_mes_referencia || '-01', 'YYYY-MM-DD');\r\n    v_end_date := (v_start_date + interval '1 month - 1 day');\r\n\r\n    -- Busca os dados do funcion√°rio, incluindo sua jornada e toler√¢ncia\r\n    SELECT f.id, f.daily_value, j.tolerancia_minutos, f.jornada_id\r\n    INTO v_employee\r\n    FROM public.funcionarios f\r\n    LEFT JOIN public.jornadas j ON f.jornada_id = j.id\r\n    WHERE f.id = p_funcionario_id;\r\n\r\n    IF v_employee IS NULL THEN\r\n        RETURN QUERY SELECT 0, '00:00', 0, 0.00;\r\n        RETURN;\r\n    END IF;\r\n\r\n    -- ***** IN√çCIO DA CORRE√á√ÉO *****\r\n    -- 1. Conta os dias √∫nicos em que houve pelo menos uma batida de ponto\r\n    SELECT COUNT(DISTINCT p.data_hora::date)\r\n    INTO dias_trabalhados\r\n    FROM public.pontos p\r\n    WHERE p.funcionario_id = p_funcionario_id AND p.data_hora::date BETWEEN v_start_date AND v_end_date;\r\n    -- ***** FIM DA CORRE√á√ÉO *****\r\n\r\n    -- CTEs para agrupar pontos e aplicar l√≥gica de toler√¢ncia para o C√ÅLCULO DE HORAS\r\n    WITH daily_punches AS (\r\n        SELECT\r\n            p.data_hora::date as dia,\r\n            MIN(CASE WHEN p.tipo_registro = 'Entrada' THEN p.data_hora::time END) as entrada,\r\n            MAX(CASE WHEN p.tipo_registro = 'Inicio_Intervalo' THEN p.data_hora::time END) as saida_intervalo,\r\n            MIN(CASE WHEN p.tipo_registro = 'Fim_Intervalo' THEN p.data_hora::time END) as volta_intervalo,\r\n            MAX(CASE WHEN p.tipo_registro = 'Saida' THEN p.data_hora::time END) as saida\r\n        FROM public.pontos p\r\n        WHERE p.funcionario_id = p_funcionario_id AND p.data_hora::date BETWEEN v_start_date AND v_end_date\r\n        GROUP BY p.data_hora::date\r\n    ),\r\n    adjusted_times AS (\r\n        SELECT\r\n            dp.*,\r\n            CASE WHEN abs(extract(epoch from dp.entrada - jd.horario_entrada)/60) <= v_employee.tolerancia_minutos THEN jd.horario_entrada ELSE dp.entrada END as entrada_ajustada,\r\n            CASE WHEN abs(extract(epoch from dp.saida_intervalo - jd.horario_saida_intervalo)/60) <= v_employee.tolerancia_minutos THEN jd.horario_saida_intervalo ELSE dp.saida_intervalo END as saida_intervalo_ajustada,\r\n            CASE WHEN abs(extract(epoch from dp.volta_intervalo - jd.horario_volta_intervalo)/60) <= v_employee.tolerancia_minutos THEN jd.horario_volta_intervalo ELSE dp.volta_intervalo END as volta_intervalo_ajustada,\r\n            CASE WHEN abs(extract(epoch from dp.saida - jd.horario_saida)/60) <= v_employee.tolerancia_minutos THEN jd.horario_saida ELSE dp.saida END as saida_ajustada\r\n        FROM daily_punches dp\r\n        LEFT JOIN public.jornada_detalhes jd ON jd.jornada_id = v_employee.jornada_id AND jd.dia_semana = EXTRACT(DOW FROM dp.dia)\r\n    )\r\n    SELECT\r\n        COALESCE(SUM(\r\n            GREATEST(0, (\r\n                EXTRACT(EPOCH FROM (saida_ajustada - entrada_ajustada)) - \r\n                COALESCE(EXTRACT(EPOCH FROM (volta_intervalo_ajustada - saida_intervalo_ajustada)), 0)\r\n            )) / 60\r\n        ), 0)\r\n    INTO v_total_minutos_trabalhados\r\n    FROM adjusted_times\r\n    WHERE entrada_ajustada IS NOT NULL AND saida_ajustada IS NOT NULL;\r\n    \r\n    SELECT count(*) INTO v_dias_uteis\r\n    FROM generate_series(v_start_date, v_end_date, '1 day'::interval) AS d\r\n    WHERE EXTRACT(DOW FROM d) NOT IN (0, 6);\r\n\r\n    faltas := GREATEST(0, v_dias_uteis - dias_trabalhados);\r\n    horas_trabalhadas_formatado := floor(v_total_minutos_trabalhados / 60)::text || ':' || lpad( (v_total_minutos_trabalhados % 60)::int::text, 2, '0');\r\n    valor_a_pagar := dias_trabalhados * (COALESCE(REPLACE(REPLACE(TRIM(REPLACE(v_employee.daily_value, 'R$', '')), '.', ''), ',', '.')::numeric, 0));\r\n\r\n    RETURN NEXT;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "calcular_saldo_anterior",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.calcular_saldo_anterior(p_conta_id bigint, p_data_inicio date, p_organizacao_id bigint)\n RETURNS numeric\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    saldo_inicial_conta numeric;\r\n    total_receitas numeric;\r\n    total_despesas numeric;\r\nBEGIN\r\n    -- 1. Pega o saldo inicial da conta, j√° filtrando pela organiza√ß√£o\r\n    SELECT COALESCE(saldo_inicial, 0)\r\n    INTO saldo_inicial_conta\r\n    FROM public.contas_financeiras\r\n    WHERE id = p_conta_id AND organizacao_id = p_organizacao_id;\r\n\r\n    -- 2. Soma todas as receitas PAGAS/CONCILIADAS antes da data de in√≠cio para a conta e organiza√ß√£o\r\n    SELECT COALESCE(SUM(valor), 0)\r\n    INTO total_receitas\r\n    FROM public.lancamentos\r\n    WHERE conta_id = p_conta_id\r\n      AND organizacao_id = p_organizacao_id -- Filtro de seguran√ßa\r\n      AND data_pagamento < p_data_inicio\r\n      AND tipo = 'Receita'\r\n      AND status IN ('Pago', 'Conciliado');\r\n\r\n    -- 3. Soma todas as despesas PAGAS/CONCILIADAS antes da data de in√≠cio para a conta e organiza√ß√£o\r\n    SELECT COALESCE(SUM(valor), 0)\r\n    INTO total_despesas\r\n    FROM public.lancamentos\r\n    WHERE conta_id = p_conta_id\r\n      AND organizacao_id = p_organizacao_id -- Filtro de seguran√ßa\r\n      AND data_pagamento < p_data_inicio\r\n      AND tipo = 'Despesa'\r\n      AND status IN ('Pago', 'Conciliado');\r\n\r\n    -- 4. Retorna o saldo anterior calculado: Saldo Inicial + Receitas - Despesas\r\n    RETURN saldo_inicial_conta + total_receitas - total_despesas;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "calcular_saldo_ate_data",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.calcular_saldo_ate_data(p_conta_id bigint, p_data_limite date)\n RETURNS numeric\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    saldo_calculado NUMERIC;\r\nBEGIN\r\n    SELECT COALESCE(SUM(CASE WHEN l.tipo = 'Receita' THEN l.valor ELSE -l.valor END), 0)\r\n    INTO saldo_calculado\r\n    FROM lancamentos l\r\n    WHERE l.conta_id = p_conta_id\r\n      AND l.data_transacao < p_data_limite;\r\n\r\n    RETURN saldo_calculado;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "calcular_saldo_atual_conta",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.calcular_saldo_atual_conta(p_conta_id bigint, p_organizacao_id bigint)\n RETURNS numeric\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    saldo_total NUMERIC;\r\n    saldo_inicial_conta NUMERIC;\r\nBEGIN\r\n    -- Pega o saldo inicial da conta\r\n    SELECT COALESCE(saldo_inicial, 0)\r\n    INTO saldo_inicial_conta\r\n    FROM public.contas_financeiras\r\n    WHERE id = p_conta_id AND organizacao_id = p_organizacao_id;\r\n\r\n    -- Calcula a soma de todas as transa√ß√µes pagas/conciliadas para a conta\r\n    SELECT\r\n        saldo_inicial_conta + \r\n        COALESCE(SUM(\r\n            CASE\r\n                WHEN tipo = 'Receita' THEN valor\r\n                WHEN tipo = 'Despesa' THEN -valor\r\n                ELSE 0\r\n            END\r\n        ), 0)\r\n    INTO saldo_total\r\n    FROM public.lancamentos\r\n    WHERE conta_id = p_conta_id\r\n      AND organizacao_id = p_organizacao_id\r\n      AND (status = 'Pago' OR status = 'Conciliado');\r\n\r\n    RETURN saldo_total;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "calcular_valor_comissao",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.calcular_valor_comissao()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Usa COALESCE para tratar valores NULOS como 0, prevenindo erros de c√°lculo.\r\n    IF COALESCE(NEW.valor_final_venda, 0) > 0 AND COALESCE(NEW.percentual_comissao_corretagem, 0) > 0 THEN\r\n        -- Calcula o valor da comiss√£o.\r\n        NEW.valor_comissao_corretagem := NEW.valor_final_venda * (NEW.percentual_comissao_corretagem / 100.0);\r\n    ELSE\r\n        -- Se as condi√ß√µes n√£o forem atendidas, define explicitamente a comiss√£o como 0.\r\n        NEW.valor_comissao_corretagem := 0;\r\n    END IF;\r\n\r\n    -- ESSA √â A LINHA MAIS CR√çTICA!\r\n    -- Ela garante que a opera√ß√£o (INSERT ou UPDATE) SEMPRE continue, retornando a\r\n    -- linha de dados que deve ser salva (NEW). Se esta fun√ß√£o retornar NULL,\r\n    -- a opera√ß√£o √© cancelada silenciosamente.\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "calcular_valor_indice",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.calcular_valor_indice(p_filtro jsonb)\n RETURNS numeric\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    -- Vari√°veis para extrair dados do JSON do filtro\r\n    search_term text := p_filtro->>'searchTerm';\r\n    empresa_ids_json jsonb := p_filtro->'empresaIds';\r\n    conta_ids_json jsonb := p_filtro->'contaIds';\r\n    categoria_ids_json jsonb := p_filtro->'categoriaIds';\r\n    empreendimento_ids_json jsonb := p_filtro->'empreendimentoIds';\r\n    etapa_ids_json jsonb := p_filtro->'etapaIds';\r\n    status_json jsonb := p_filtro->'status';\r\n    start_date text := p_filtro->>'startDate';\r\n    end_date text := p_filtro->>'endDate';\r\n    tipo_json jsonb := p_filtro->'tipo';\r\n\r\n    -- Vari√°veis para converter JSON arrays para SQL arrays\r\n    empresa_ids bigint[];\r\n    conta_ids bigint[];\r\n    categoria_ids bigint[];\r\n    empreendimento_ids bigint[];\r\n    etapa_ids bigint[];\r\n    status_array text[];\r\n    tipo_array text[];\r\n\r\n    dynamic_query text;\r\n    total_valor numeric;\r\nBEGIN\r\n    -- Converte os arrays JSON para arrays SQL, tratando valores nulos\r\n    SELECT COALESCE(ARRAY(SELECT jsonb_array_elements_text(empresa_ids_json)::bigint), '{}') INTO empresa_ids;\r\n    SELECT COALESCE(ARRAY(SELECT jsonb_array_elements_text(conta_ids_json)::bigint), '{}') INTO conta_ids;\r\n    SELECT COALESCE(ARRAY(SELECT jsonb_array_elements_text(categoria_ids_json)::bigint), '{}') INTO categoria_ids;\r\n    SELECT COALESCE(ARRAY(SELECT jsonb_array_elements_text(empreendimento_ids_json)::bigint), '{}') INTO empreendimento_ids;\r\n    SELECT COALESCE(ARRAY(SELECT jsonb_array_elements_text(etapa_ids_json)::bigint), '{}') INTO etapa_ids;\r\n    SELECT COALESCE(ARRAY(SELECT jsonb_array_elements_text(status_json)), '{}') INTO status_array;\r\n    SELECT COALESCE(ARRAY(SELECT jsonb_array_elements_text(tipo_json)), '{}') INTO tipo_array;\r\n\r\n    -- Inicia a constru√ß√£o da query\r\n    -- A soma agora considera que despesas s√£o negativas e receitas positivas\r\n    dynamic_query := 'SELECT COALESCE(SUM(CASE WHEN tipo = ''Receita'' THEN valor WHEN tipo = ''Despesa'' THEN -valor ELSE 0 END), 0) FROM public.lancamentos WHERE 1=1';\r\n\r\n    -- Adiciona as condi√ß√µes do filtro √† query\r\n    IF search_term IS NOT NULL AND search_term != '' THEN\r\n        dynamic_query := dynamic_query || ' AND descricao ILIKE ' || quote_literal('%' || search_term || '%');\r\n    END IF;\r\n\r\n    IF start_date IS NOT NULL AND start_date != '' THEN\r\n        dynamic_query := dynamic_query || ' AND data_transacao >= ' || quote_literal(start_date);\r\n    END IF;\r\n\r\n    IF end_date IS NOT NULL AND end_date != '' THEN\r\n        dynamic_query := dynamic_query || ' AND data_transacao <= ' || quote_literal(end_date);\r\n    END IF;\r\n    \r\n    -- A verifica√ß√£o 'array_length > 0' previne erros com arrays vazios\r\n    IF array_length(empresa_ids, 1) > 0 THEN\r\n        dynamic_query := dynamic_query || ' AND empresa_id = ANY(' || quote_literal(empresa_ids) || ')';\r\n    END IF;\r\n\r\n    IF array_length(conta_ids, 1) > 0 THEN\r\n        dynamic_query := dynamic_query || ' AND conta_id = ANY(' || quote_literal(conta_ids) || ')';\r\n    END IF;\r\n\r\n    IF array_length(categoria_ids, 1) > 0 THEN\r\n        dynamic_query := dynamic_query || ' AND categoria_id = ANY(' || quote_literal(categoria_ids) || ')';\r\n    END IF;\r\n\r\n    IF array_length(empreendimento_ids, 1) > 0 THEN\r\n        dynamic_query := dynamic_query || ' AND empreendimento_id = ANY(' || quote_literal(empreendimento_ids) || ')';\r\n    END IF;\r\n    \r\n    IF array_length(tipo_array, 1) > 0 THEN\r\n        dynamic_query := dynamic_query || ' AND tipo = ANY(' || quote_literal(tipo_array) || ')';\r\n    END IF;\r\n\r\n    EXECUTE dynamic_query INTO total_valor;\r\n\r\n    RETURN ABS(total_valor); -- Retorna sempre o valor absoluto, pois a f√≥rmula controlar√° o sinal\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "calcular_valor_indice",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.calcular_valor_indice(p_indice_id bigint)\n RETURNS numeric\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    filtro jsonb;\r\n    query_sql text;\r\n    total_valor numeric;\r\nBEGIN\r\n    -- 1. Busca a configura√ß√£o do filtro para o √≠ndice fornecido\r\n    SELECT configuracao_filtro INTO filtro\r\n    FROM public.indices_financeiros\r\n    WHERE id = p_indice_id;\r\n\r\n    -- Se n√£o encontrar o filtro, retorna 0\r\n    IF filtro IS NULL THEN\r\n        RAISE NOTICE '√çndice com ID % n√£o encontrado.', p_indice_id;\r\n        RETURN 0;\r\n    END IF;\r\n\r\n    -- 2. Constr√≥i a consulta SQL baseada nos filtros\r\n    -- CORRE√á√ÉO PRINCIPAL: Agora faz um SUM simples do valor, sem torn√°-lo negativo.\r\n    query_sql := 'SELECT COALESCE(SUM(valor), 0) FROM public.lancamentos WHERE 1=1';\r\n\r\n    -- Adiciona as condi√ß√µes (cl√°usulas WHERE) dinamicamente\r\n    IF filtro->>'searchTerm' IS NOT NULL AND filtro->>'searchTerm' != '' THEN\r\n        query_sql := query_sql || ' AND descricao ILIKE ''%' || filtro->>'searchTerm' || '%''';\r\n    END IF;\r\n\r\n    IF jsonb_array_length(filtro->'contaIds') > 0 THEN\r\n        query_sql := query_sql || ' AND conta_id = ANY(ARRAY[' || array_to_string(ARRAY(SELECT jsonb_array_elements_text(filtro->'contaIds')), ',') || '])';\r\n    END IF;\r\n\r\n    IF jsonb_array_length(filtro->'categoriaIds') > 0 THEN\r\n        query_sql := query_sql || ' AND categoria_id = ANY(ARRAY[' || array_to_string(ARRAY(SELECT jsonb_array_elements_text(filtro->'categoriaIds')), ',') || '])';\r\n    END IF;\r\n    \r\n    -- CORRE√á√ÉO: Adiciona o filtro por \"tipo\" (Receita/Despesa) se ele existir no JSON.\r\n    IF jsonb_array_length(filtro->'tipo') > 0 THEN\r\n        query_sql := query_sql || ' AND tipo = ANY(ARRAY[' || array_to_string(ARRAY(SELECT '''''' || value || '''''' FROM jsonb_array_elements_text(filtro->'tipo')), ',') || '])';\r\n    END IF;\r\n\r\n    IF filtro->>'startDate' IS NOT NULL AND filtro->>'startDate' != '' THEN\r\n        query_sql := query_sql || ' AND data_transacao >= ''' || (filtro->>'startDate') || '''';\r\n    END IF;\r\n    \r\n    IF filtro->>'endDate' IS NOT NULL AND filtro->>'endDate' != '' THEN\r\n        query_sql := query_sql || ' AND data_transacao <= ''' || (filtro->>'endDate') || '''';\r\n    END IF;\r\n\r\n    -- Adiciona mais filtros conforme necess√°rio (empresa, empreendimento, etc.)\r\n\r\n    -- 3. Executa a consulta e armazena o resultado\r\n    RAISE NOTICE 'Executando SQL para √çndice: %', query_sql;\r\n    EXECUTE query_sql INTO total_valor;\r\n\r\n    -- 4. Retorna o valor calculado\r\n    RETURN total_valor;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "calcular_valor_kpi",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.calcular_valor_kpi(p_formula text)\n RETURNS numeric\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    -- Esta fun√ß√£o agora recebe a F√ìRMULA como texto, n√£o mais o ID do KPI.\r\n    indice_name text;\r\n    indice_filtro jsonb;\r\n    indice_valor numeric;\r\n    final_expression text := p_formula;\r\nBEGIN\r\n    -- Se a f√≥rmula estiver vazia ou for nula, retorna 0.\r\n    IF final_expression IS NULL OR final_expression = '' THEN\r\n        RETURN 0;\r\n    END IF;\r\n\r\n    -- Usa uma express√£o regular para encontrar todos os nomes de √≠ndices (ex: [NOME_INDICE])\r\n    FOR indice_name IN SELECT (regexp_matches(final_expression, '\\[([a-zA-Z0-9_]+)\\]', 'g'))[1]\r\n    LOOP\r\n        -- Para cada nome encontrado, busca o filtro correspondente na tabela de √≠ndices\r\n        SELECT configuracao_filtro INTO indice_filtro \r\n        FROM public.indices_financeiros \r\n        WHERE nome_indice = indice_name;\r\n\r\n        -- Se encontrou o filtro, chama a fun√ß√£o auxiliar para calcular o valor daquele √≠ndice\r\n        IF indice_filtro IS NOT NULL THEN\r\n            SELECT calcular_valor_indice(indice_filtro) INTO indice_valor;\r\n            -- Substitui o nome do √≠ndice (ex: [CUSTO_TOTAL]) pelo seu valor num√©rico na f√≥rmula\r\n            final_expression := replace(final_expression, '[' || indice_name || ']', COALESCE(indice_valor, 0)::text);\r\n        ELSE\r\n            -- Se um √≠ndice na f√≥rmula n√£o for encontrado na tabela, substitui por 0 para evitar erros.\r\n            final_expression := replace(final_expression, '[' || indice_name || ']', '0');\r\n        END IF;\r\n    END LOOP;\r\n\r\n    -- Tenta executar a express√£o matem√°tica final (ex: (1000-500)/1000)\r\n    -- Se der um erro (como divis√£o por zero), o bloco EXCEPTION captura e retorna 0.\r\n    BEGIN\r\n        EXECUTE 'SELECT ' || final_expression INTO indice_valor;\r\n    EXCEPTION \r\n        WHEN division_by_zero THEN\r\n            RETURN 0;\r\n        WHEN others THEN\r\n            RETURN NULL; -- Retorna NULL para outros tipos de erro de sintaxe na f√≥rmula\r\n    END;\r\n\r\n    RETURN indice_valor;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "calcular_vgv_possivel",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.calcular_vgv_possivel(p_organizacao_id bigint)\n RETURNS numeric\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    valor_vendido NUMERIC;\r\n    valor_disponivel NUMERIC;\r\nBEGIN\r\n    -- 1. Soma o valor dos contratos J√Å ASSINADOS de empreendimentos listados para venda\r\n    SELECT COALESCE(SUM(c.valor_final_venda), 0)\r\n    INTO valor_vendido\r\n    FROM contratos c\r\n    JOIN empreendimentos e ON c.empreendimento_id = e.id\r\n    WHERE c.organizacao_id = p_organizacao_id\r\n      AND e.listado_para_venda = TRUE\r\n      AND c.status_contrato = 'Assinado';\r\n\r\n    -- 2. Soma o valor das unidades AINDA DISPON√çVEIS de empreendimentos listados para venda\r\n    -- =================================================================================\r\n    -- CORRE√á√ÉO APLICADA AQUI\r\n    -- O PORQU√ä: Trocamos \"p.valor_venda\" por \"p.valor_venda_calculado\", que √© o nome\r\n    -- correto da coluna na sua tabela \"produtos_empreendimento\".\r\n    -- =================================================================================\r\n    SELECT COALESCE(SUM(p.valor_venda_calculado), 0)\r\n    INTO valor_disponivel\r\n    FROM produtos_empreendimento p\r\n    JOIN empreendimentos e ON p.empreendimento_id = e.id\r\n    WHERE p.organizacao_id = p_organizacao_id\r\n      AND e.listado_para_venda = TRUE\r\n      AND p.status = 'Dispon√≠vel';\r\n\r\n    -- 3. Retorna a soma dos dois valores\r\n    RETURN valor_vendido + valor_disponivel;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "consultar_contratos_filtrados",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.consultar_contratos_filtrados(p_organizacao_id bigint, p_search_term text, p_cliente_ids bigint[], p_corretor_ids bigint[], p_produto_ids bigint[], p_empreendimento_ids bigint[], p_status text[], p_start_date date, p_end_date date)\n RETURNS TABLE(id bigint, contato_id bigint, produto_id bigint, empreendimento_id bigint, data_venda date, valor_final_venda numeric, status_contrato text, created_at timestamp with time zone, simulacao_id bigint, corretor_id bigint, indice_reajuste text, multa_inadimplencia_percentual numeric, juros_mora_inadimplencia_percentual numeric, clausula_penal_percentual numeric, numero_contrato text, organizacao_id bigint, contato json, produto json, empreendimento json, corretor json)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT\r\n        c.id,\r\n        c.contato_id,\r\n        c.produto_id,\r\n        c.empreendimento_id,\r\n        c.data_venda,\r\n        c.valor_final_venda,\r\n        c.status_contrato,\r\n        c.created_at,\r\n        c.simulacao_id,\r\n        c.corretor_id,\r\n        c.indice_reajuste,\r\n        c.multa_inadimplencia_percentual,\r\n        c.juros_mora_inadimplencia_percentual,\r\n        c.clausula_penal_percentual,\r\n        c.numero_contrato,\r\n        c.organizacao_id,\r\n        json_build_object('nome', cliente.nome, 'razao_social', cliente.razao_social) as contato,\r\n        json_build_object('unidade', produto.unidade, 'tipo', produto.tipo) as produto,\r\n        json_build_object('nome', empreendimento.nome) as empreendimento,\r\n        json_build_object('nome', corretor.nome, 'razao_social', corretor.razao_social) as corretor\r\n    FROM public.contratos c\r\n    LEFT JOIN public.contatos cliente ON c.contato_id = cliente.id\r\n    LEFT JOIN public.contatos corretor ON c.corretor_id = corretor.id\r\n    LEFT JOIN public.produtos_empreendimento produto ON c.produto_id = produto.id\r\n    LEFT JOIN public.empreendimentos empreendimento ON c.empreendimento_id = empreendimento.id\r\n    WHERE\r\n        c.organizacao_id = p_organizacao_id\r\n        AND (p_search_term IS NULL OR p_search_term = '' OR\r\n             c.id::text ILIKE '%' || p_search_term || '%' OR\r\n             cliente.nome ILIKE '%' || p_search_term || '%' OR\r\n             cliente.razao_social ILIKE '%' || p_search_term || '%' OR\r\n             produto.unidade ILIKE '%' || p_search_term || '%' OR\r\n             empreendimento.nome ILIKE '%' || p_search_term || '%' OR\r\n             corretor.nome ILIKE '%' || p_search_term || '%')\r\n        AND (p_cliente_ids IS NULL OR c.contato_id = ANY(p_cliente_ids))\r\n        AND (p_corretor_ids IS NULL OR c.corretor_id = ANY(p_corretor_ids))\r\n        AND (p_produto_ids IS NULL OR c.produto_id = ANY(p_produto_ids))\r\n        AND (p_empreendimento_ids IS NULL OR c.empreendimento_id = ANY(p_empreendimento_ids))\r\n        AND (p_status IS NULL OR c.status_contrato = ANY(p_status))\r\n        AND (p_start_date IS NULL OR c.data_venda >= p_start_date)\r\n        AND (p_end_date IS NULL OR c.data_venda <= p_end_date);\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "consultar_lancamentos_filtrados",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.consultar_lancamentos_filtrados(p_organizacao_id bigint, p_filtros jsonb)\n RETURNS SETOF lancamentos\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_query text;\r\nBEGIN\r\n    v_query := '\r\n        SELECT l.* FROM lancamentos l\r\n        LEFT JOIN categorias_financeiras c ON l.categoria_id = c.id\r\n        LEFT JOIN contatos fav ON l.favorecido_contato_id = fav.id\r\n        WHERE l.organizacao_id = ' || p_organizacao_id;\r\n\r\n    -- 1. Texto (Busca)\r\n    IF p_filtros->>'searchTerm' IS NOT NULL AND p_filtros->>'searchTerm' <> '' THEN\r\n        v_query := v_query || ' AND (\r\n            l.descricao ILIKE ''%' || (p_filtros->>'searchTerm') || '%'' OR\r\n            fav.nome ILIKE ''%' || (p_filtros->>'searchTerm') || '%'' OR\r\n            c.nome ILIKE ''%' || (p_filtros->>'searchTerm') || '%''\r\n        )';\r\n    END IF;\r\n\r\n    -- 2. Datas\r\n    IF p_filtros->>'startDate' IS NOT NULL AND p_filtros->>'startDate' <> '' THEN\r\n        v_query := v_query || ' AND l.data_vencimento >= ''' || (p_filtros->>'startDate') || '''';\r\n    END IF;\r\n    IF p_filtros->>'endDate' IS NOT NULL AND p_filtros->>'endDate' <> '' THEN\r\n        v_query := v_query || ' AND l.data_vencimento <= ''' || (p_filtros->>'endDate') || '''';\r\n    END IF;\r\n\r\n    -- 3. M√∫ltipla Escolha\r\n    IF jsonb_array_length(p_filtros->'status') > 0 THEN\r\n        v_query := v_query || ' AND l.status IN (SELECT jsonb_array_elements_text(''' || (p_filtros->'status') || '''))';\r\n    END IF;\r\n    IF jsonb_array_length(p_filtros->'tipo') > 0 THEN\r\n        v_query := v_query || ' AND l.tipo IN (SELECT jsonb_array_elements_text(''' || (p_filtros->'tipo') || '''))';\r\n    END IF;\r\n    IF jsonb_array_length(p_filtros->'contaIds') > 0 THEN\r\n        v_query := v_query || ' AND l.conta_id IN (SELECT jsonb_array_elements_text(''' || (p_filtros->'contaIds') || ''')::bigint)';\r\n    END IF;\r\n    IF jsonb_array_length(p_filtros->'categoriaIds') > 0 THEN\r\n        v_query := v_query || ' AND l.categoria_id IN (SELECT jsonb_array_elements_text(''' || (p_filtros->'categoriaIds') || ''')::bigint)';\r\n    END IF;\r\n    IF jsonb_array_length(p_filtros->'empresaIds') > 0 THEN\r\n        v_query := v_query || ' AND l.empresa_id IN (SELECT jsonb_array_elements_text(''' || (p_filtros->'empresaIds') || ''')::bigint)';\r\n    END IF;\r\n    IF jsonb_array_length(p_filtros->'empreendimentoIds') > 0 THEN\r\n        v_query := v_query || ' AND l.empreendimento_id IN (SELECT jsonb_array_elements_text(''' || (p_filtros->'empreendimentoIds') || ''')::bigint)';\r\n    END IF;\r\n    IF jsonb_array_length(p_filtros->'etapaIds') > 0 THEN\r\n        v_query := v_query || ' AND l.etapa_id IN (SELECT jsonb_array_elements_text(''' || (p_filtros->'etapaIds') || ''')::bigint)';\r\n    END IF;\r\n\r\n    -- 4. Filtro de Favorecido\r\n    IF p_filtros->>'favorecidoId' IS NOT NULL THEN\r\n        v_query := v_query || ' AND l.favorecido_contato_id = ' || (p_filtros->>'favorecidoId');\r\n    END IF;\r\n\r\n    -- === 5. ATUALIZADO: IGNORAR TRANSFER√äNCIAS E ESTORNOS ===\r\n    -- Oculta se a categoria come√ßar com \"Transfer√™ncia\" OU \"Estorno\"\r\n    IF (p_filtros->>'ignoreTransfers')::boolean IS TRUE THEN\r\n        v_query := v_query || ' AND (c.nome IS NULL OR NOT (\r\n            UNACCENT(c.nome) ILIKE UNACCENT(''Transfer√™ncia%'') OR \r\n            UNACCENT(c.nome) ILIKE UNACCENT(''Estorno%'')\r\n        ))';\r\n    END IF;\r\n\r\n    RETURN QUERY EXECUTE v_query;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "corrigir_e_criar_materiais_faltantes",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.corrigir_e_criar_materiais_faltantes()\n RETURNS TABLE(item_pedido_id bigint, descricao_item text, pedido_id bigint, material_foi_criado boolean, id_final_do_material bigint)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    item_rec RECORD;\r\n    material_id_encontrado BIGINT;\r\n    v_organizacao_id BIGINT;\r\nBEGIN\r\n    -- Percorre cada item de pedido que precisa de corre√ß√£o\r\n    FOR item_rec IN\r\n        SELECT pci.id, pci.descricao_item, pci.unidade_medida, p.organizacao_id, pci.pedido_compra_id\r\n        FROM pedidos_compra_itens AS pci\r\n        JOIN pedidos_compra AS p ON pci.pedido_compra_id = p.id\r\n        WHERE pci.material_id IS NULL AND pci.descricao_item IS NOT NULL AND pci.descricao_item <> ''\r\n    LOOP\r\n        v_organizacao_id := item_rec.organizacao_id;\r\n        material_id_encontrado := NULL;\r\n\r\n        -- Tenta encontrar um material existente com base na descri√ß√£o e organiza√ß√£o\r\n        SELECT m.id INTO material_id_encontrado\r\n        FROM materiais AS m\r\n        WHERE \r\n            (m.nome = item_rec.descricao_item OR m.descricao = item_rec.descricao_item)\r\n            AND m.organizacao_id = v_organizacao_id\r\n        LIMIT 1;\r\n\r\n        -- Se n√£o encontrou, cria um novo\r\n        IF material_id_encontrado IS NULL THEN\r\n            INSERT INTO materiais (nome, descricao, unidade_medida, classificacao, organizacao_id)\r\n            VALUES (\r\n                item_rec.descricao_item,      -- nome\r\n                item_rec.descricao_item,      -- descricao\r\n                COALESCE(item_rec.unidade_medida, 'unid.'), -- unidade_medida (usa a do item ou 'unid.')\r\n                'Insumo',                     -- classificacao (valor padr√£o)\r\n                v_organizacao_id              -- organizacao_id\r\n            )\r\n            RETURNING id INTO material_id_encontrado;\r\n\r\n            -- Prepara a linha de relat√≥rio para este item\r\n            item_pedido_id := item_rec.id;\r\n            descricao_item := item_rec.descricao_item;\r\n            pedido_id := item_rec.pedido_compra_id;\r\n            material_foi_criado := TRUE;\r\n            id_final_do_material := material_id_encontrado;\r\n            RETURN NEXT;\r\n\r\n        ELSE\r\n            -- Prepara a linha de relat√≥rio para o item que encontrou correspond√™ncia\r\n            item_pedido_id := item_rec.id;\r\n            descricao_item := item_rec.descricao_item;\r\n            pedido_id := item_rec.pedido_compra_id;\r\n            material_foi_criado := FALSE;\r\n            id_final_do_material := material_id_encontrado;\r\n            RETURN NEXT;\r\n        END IF;\r\n        \r\n        -- Atualiza o item do pedido com o ID do material (encontrado ou criado)\r\n        UPDATE pedidos_compra_itens\r\n        SET material_id = material_id_encontrado\r\n        WHERE id = item_rec.id;\r\n\r\n    END LOOP;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "corrigir_e_criar_materiais_versao_robusta",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.corrigir_e_criar_materiais_versao_robusta()\n RETURNS TABLE(acao_realizada text, item_pedido_id bigint, descricao_item text, pedido_id bigint, id_final_do_material bigint, nome_material_vinculado text)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    item_rec RECORD;\r\n    material_id_encontrado BIGINT;\r\n    v_organizacao_id BIGINT;\r\n    updated_ids BIGINT[];\r\nBEGIN\r\n    -- Etapa 1: Tenta atualizar em massa todos os itens que encontram correspond√™ncia\r\n    -- limpando os nomes (sem acentos, min√∫sculas, sem espa√ßos extras).\r\n    WITH updates AS (\r\n        UPDATE pedidos_compra_itens pci\r\n        SET material_id = m.id\r\n        FROM materiais m\r\n        JOIN pedidos_compra pc ON pci.pedido_compra_id = pc.id\r\n        WHERE \r\n            pci.material_id IS NULL \r\n            AND pc.organizacao_id = m.organizacao_id\r\n            AND unaccent(lower(trim(pci.descricao_item))) = unaccent(lower(trim(m.nome)))\r\n        RETURNING pci.id, pci.descricao_item, pci.pedido_compra_id, m.id as novo_material_id, m.nome as material_nome\r\n    )\r\n    SELECT array_agg(id) INTO updated_ids FROM updates;\r\n\r\n    -- Cria a tabela de resultados tempor√°ria para o relat√≥rio\r\n    CREATE TEMP TABLE IF NOT EXISTS temp_results ON COMMIT DROP AS\r\n    SELECT \r\n        'VINCULADO'::TEXT as acao_realizada, \r\n        u.id as item_pedido_id, \r\n        u.descricao_item,\r\n        u.pedido_compra_id as pedido_id,\r\n        u.novo_material_id as id_final_do_material,\r\n        u.material_nome as nome_material_vinculado\r\n    FROM updates u;\r\n\r\n    -- Etapa 2: Percorre apenas os itens que N√ÉO foram atualizados na etapa 1 para criar novos materiais\r\n    FOR item_rec IN\r\n        SELECT pci.id, pci.descricao_item, pci.unidade_medida, p.organizacao_id, pci.pedido_compra_id\r\n        FROM pedidos_compra_itens AS pci\r\n        JOIN pedidos_compra AS p ON pci.pedido_compra_id = p.id\r\n        WHERE pci.material_id IS NULL \r\n          AND pci.descricao_item IS NOT NULL \r\n          AND trim(pci.descricao_item) <> ''\r\n          AND (updated_ids IS NULL OR NOT (pci.id = ANY(updated_ids)))\r\n    LOOP\r\n        v_organizacao_id := item_rec.organizacao_id;\r\n        material_id_encontrado := NULL;\r\n\r\n        -- Cria um novo material\r\n        INSERT INTO materiais (nome, descricao, unidade_medida, classificacao, organizacao_id)\r\n        VALUES (\r\n            trim(item_rec.descricao_item),\r\n            trim(item_rec.descricao_item),\r\n            COALESCE(item_rec.unidade_medida, 'unid.'),\r\n            'Insumo',\r\n            v_organizacao_id\r\n        )\r\n        RETURNING id INTO material_id_encontrado;\r\n\r\n        -- Atualiza o item do pedido com o ID do material rec√©m-criado\r\n        UPDATE pedidos_compra_itens\r\n        SET material_id = material_id_encontrado\r\n        WHERE id = item_rec.id;\r\n\r\n        -- Adiciona a informa√ß√£o ao relat√≥rio\r\n        INSERT INTO temp_results (acao_realizada, item_pedido_id, descricao_item, pedido_id, id_final_do_material, nome_material_vinculado)\r\n        VALUES ('CRIADO', item_rec.id, item_rec.descricao_item, item_rec.pedido_compra_id, material_id_encontrado, trim(item_rec.descricao_item));\r\n\r\n    END LOOP;\r\n\r\n    -- Retorna o relat√≥rio completo\r\n    RETURN QUERY SELECT * FROM temp_results ORDER BY acao_realizada, pedido_id, item_pedido_id;\r\n\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "corrigir_itens_com_criacao_direta_v2",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.corrigir_itens_com_criacao_direta_v2()\n RETURNS TABLE(item_pedido_id_corrigido bigint, descricao_item text, id_do_pedido bigint, id_do_novo_material_criado bigint)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    item_rec RECORD;\r\n    novo_material_id BIGINT;\r\nBEGIN\r\n    -- Cria uma tabela tempor√°ria para o relat√≥rio (com a sintaxe corrigida)\r\n    CREATE TEMP TABLE temp_reporte_final_criacao (\r\n        item_pedido_id_corrigido BIGINT,\r\n        descricao_item TEXT,\r\n        id_do_pedido BIGINT,\r\n        id_do_novo_material_criado BIGINT\r\n    ) ON COMMIT DROP;\r\n\r\n    -- Loop que passa por cada item de pedido com material_id nulo\r\n    FOR item_rec IN\r\n        SELECT pci.id, pci.descricao_item, pci.unidade_medida, p.organizacao_id, pci.pedido_compra_id\r\n        FROM pedidos_compra_itens AS pci\r\n        JOIN pedidos_compra AS p ON pci.pedido_compra_id = p.id\r\n        WHERE pci.material_id IS NULL AND pci.descricao_item IS NOT NULL AND trim(pci.descricao_item) <> ''\r\n    LOOP\r\n        -- Cria o novo material e captura o ID gerado\r\n        INSERT INTO materiais (nome, descricao, unidade_medida, classificacao, organizacao_id)\r\n        VALUES (\r\n            trim(item_rec.descricao_item),\r\n            trim(item_rec.descricao_item),\r\n            COALESCE(item_rec.unidade_medida, 'unid.'),\r\n            'Insumo',\r\n            item_rec.organizacao_id\r\n        )\r\n        RETURNING id INTO novo_material_id;\r\n\r\n        -- Atualiza o item do pedido com o novo ID\r\n        UPDATE pedidos_compra_itens\r\n        SET material_id = novo_material_id\r\n        WHERE id = item_rec.id;\r\n\r\n        -- Adiciona a a√ß√£o ao relat√≥rio\r\n        INSERT INTO temp_reporte_final_criacao (item_pedido_id_corrigido, descricao_item, id_do_pedido, id_do_novo_material_criado)\r\n        VALUES (item_rec.id, item_rec.descricao_item, item_rec.pedido_compra_id, novo_material_id);\r\n\r\n    END LOOP;\r\n\r\n    -- Retorna o relat√≥rio completo\r\n    RETURN QUERY SELECT * FROM temp_reporte_final_criacao;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "corrigir_materiais_com_logica_inteligente",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.corrigir_materiais_com_logica_inteligente()\n RETURNS TABLE(acao_realizada text, item_pedido_id_corrigido bigint, descricao_item text, id_do_pedido bigint, id_do_material_final bigint, nome_do_material_final text)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    item_rec RECORD;\r\n    material_encontrado RECORD;\r\nBEGIN\r\n    -- Habilita a extens√£o para ignorar acentos, caso ainda n√£o esteja ativa.\r\n    CREATE EXTENSION IF NOT EXISTS unaccent;\r\n\r\n    -- Cria a tabela tempor√°ria para o relat√≥rio\r\n    CREATE TEMP TABLE temp_reporte_inteligente (\r\n        acao_realizada TEXT,\r\n        item_pedido_id_corrigido BIGINT,\r\n        descricao_item TEXT,\r\n        id_do_pedido BIGINT,\r\n        id_do_material_final BIGINT,\r\n        nome_do_material_final TEXT\r\n    ) ON COMMIT DROP;\r\n\r\n    -- Loop por cada item que precisa ser corrigido\r\n    FOR item_rec IN\r\n        SELECT pci.id, pci.descricao_item, pci.unidade_medida, p.organizacao_id, pci.pedido_compra_id\r\n        FROM pedidos_compra_itens AS pci\r\n        JOIN pedidos_compra AS p ON pci.pedido_compra_id = p.id\r\n        WHERE pci.material_id IS NULL AND pci.descricao_item IS NOT NULL AND trim(pci.descricao_item) <> ''\r\n    LOOP\r\n        -- PASSO 1: Tenta encontrar um material existente (busca inteligente)\r\n        SELECT m.id, m.nome INTO material_encontrado\r\n        FROM materiais AS m\r\n        WHERE\r\n            m.organizacao_id = item_rec.organizacao_id\r\n            AND unaccent(lower(trim(m.nome))) = unaccent(lower(trim(item_rec.descricao_item)))\r\n        LIMIT 1;\r\n\r\n        -- PASSO 2: Decide se vincula ou cria\r\n        IF material_encontrado.id IS NOT NULL THEN\r\n            -- SE ENCONTROU: Apenas atualiza o item do pedido\r\n            UPDATE pedidos_compra_itens SET material_id = material_encontrado.id WHERE id = item_rec.id;\r\n            -- Adiciona ao relat√≥rio\r\n            INSERT INTO temp_reporte_inteligente VALUES ('VINCULADO', item_rec.id, item_rec.descricao_item, item_rec.pedido_compra_id, material_encontrado.id, material_encontrado.nome);\r\n        ELSE\r\n            -- SE N√ÉO ENCONTROU: Cria um novo material\r\n            INSERT INTO materiais (nome, descricao, unidade_medida, classificacao, organizacao_id)\r\n            VALUES (\r\n                trim(item_rec.descricao_item),\r\n                trim(item_rec.descricao_item),\r\n                COALESCE(item_rec.unidade_medida, 'unid.'),\r\n                'Insumo',\r\n                item_rec.organizacao_id\r\n            )\r\n            RETURNING id, nome INTO material_encontrado;\r\n            -- Atualiza o item do pedido com o novo ID\r\n            UPDATE pedidos_compra_itens SET material_id = material_encontrado.id WHERE id = item_rec.id;\r\n            -- Adiciona ao relat√≥rio\r\n            INSERT INTO temp_reporte_inteligente VALUES ('CRIADO', item_rec.id, item_rec.descricao_item, item_rec.pedido_compra_id, material_encontrado.id, material_encontrado.nome);\r\n        END IF;\r\n\r\n    END LOOP;\r\n\r\n    -- Retorna o relat√≥rio completo\r\n    RETURN QUERY SELECT * FROM temp_reporte_inteligente ORDER BY acao_realizada, id_do_pedido;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "corrigir_numeros_pela_agenda",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.corrigir_numeros_pela_agenda()\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    r_conv RECORD;\r\n    v_telefone_correto text;\r\n    v_atualizados int := 0;\r\nBEGIN\r\n    -- Percorre todas as conversas que j√° t√™m um dono (contato_id)\r\n    FOR r_conv IN \r\n        SELECT id, phone_number, contato_id, organizacao_id\r\n        FROM public.whatsapp_conversations\r\n        WHERE contato_id IS NOT NULL\r\n    LOOP\r\n        -- Tenta achar o telefone oficial na tabela 'telefones'\r\n        -- Crit√©rio: Mesmo contato_id E √∫ltimos 8 d√≠gitos iguais\r\n        SELECT telefone INTO v_telefone_correto\r\n        FROM public.telefones\r\n        WHERE contato_id = r_conv.contato_id\r\n          AND RIGHT(REGEXP_REPLACE(telefone, '\\D', '', 'g'), 8) = RIGHT(REGEXP_REPLACE(r_conv.phone_number, '\\D', '', 'g'), 8)\r\n        LIMIT 1; -- Pega o primeiro que der match (caso tenha fixo e celular com final igual, raro mas poss√≠vel)\r\n\r\n        -- Se achou um n√∫mero oficial e ele √© diferente do que est√° na conversa...\r\n        IF v_telefone_correto IS NOT NULL AND v_telefone_correto <> r_conv.phone_number THEN\r\n            \r\n            -- ATUALIZA O N√öMERO NA CONVERSA\r\n            -- Nota: Usamos um bloco BEGIN/EXCEPTION para o caso de j√° existir uma conversa com o n√∫mero correto\r\n            BEGIN\r\n                UPDATE public.whatsapp_conversations\r\n                SET phone_number = v_telefone_correto\r\n                WHERE id = r_conv.id;\r\n                \r\n                v_atualizados := v_atualizados + 1;\r\n            EXCEPTION WHEN unique_violation THEN\r\n                -- Se der erro de duplicidade, significa que j√° existe a conversa certa.\r\n                -- Nesse caso, ignoramos o update aqui, pois a fun√ß√£o de limpeza (faxina) vai resolver depois.\r\n                RAISE NOTICE 'Conversa % j√° existe com o n√∫mero correto. Pulando atualiza√ß√£o.', r_conv.id;\r\n            END;\r\n            \r\n        END IF;\r\n    END LOOP;\r\n\r\n    RETURN 'Corre√ß√£o finalizada! ' || v_atualizados || ' conversas tiveram seus n√∫meros corrigidos pela agenda.';\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "cosine_distance",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.cosine_distance(halfvec, halfvec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_cosine_distance$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "cosine_distance",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.cosine_distance(vector, vector)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$cosine_distance$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "cosine_distance",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.cosine_distance(sparsevec, sparsevec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_cosine_distance$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "count_leads_per_campaign",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.count_leads_per_campaign(campaign_ids text[], p_organizacao_id bigint)\n RETURNS TABLE(meta_campaign_id text, lead_count integer)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT\r\n        c.meta_campaign_id,\r\n        COUNT(c.id)::INT AS lead_count\r\n    FROM\r\n        contatos AS c\r\n    WHERE\r\n        c.meta_campaign_id = ANY(campaign_ids) AND\r\n        c.organizacao_id = p_organizacao_id\r\n    GROUP BY\r\n        c.meta_campaign_id;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "dar_baixa_estoque_por_uso",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.dar_baixa_estoque_por_uso(p_estoque_id bigint, p_quantidade numeric, p_observacao text, p_usuario_id uuid, p_funcionario_id bigint, p_organizacao_id bigint)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_nova_quantidade_atual numeric;\r\n    v_estoque_organizacao_id bigint;\r\nBEGIN\r\n    -- Busca a quantidade atual e o ID da organiza√ß√£o do item de estoque\r\n    SELECT quantidade_atual, organizacao_id INTO v_nova_quantidade_atual, v_estoque_organizacao_id\r\n    FROM public.estoque\r\n    WHERE id = p_estoque_id;\r\n\r\n    -- Verifica se o item de estoque existe\r\n    IF v_estoque_organizacao_id IS NULL THEN\r\n        RAISE EXCEPTION 'Item de estoque n√£o encontrado com o ID fornecido.';\r\n    END IF;\r\n\r\n    -- Verifica se o item pertence √† organiza√ß√£o correta\r\n    IF v_estoque_organizacao_id != p_organizacao_id THEN\r\n        RAISE EXCEPTION 'Permiss√£o negada: este item de estoque pertence a outra organiza√ß√£o.';\r\n    END IF;\r\n\r\n    -- Calcula a nova quantidade\r\n    v_nova_quantidade_atual := v_nova_quantidade_atual - p_quantidade;\r\n\r\n    -- Impede que o estoque fique negativo\r\n    IF v_nova_quantidade_atual < 0 THEN\r\n        RAISE EXCEPTION 'Quantidade de baixa excede o estoque dispon√≠vel.';\r\n    END IF;\r\n\r\n    -- Passo 1: Atualiza a quantidade no estoque\r\n    UPDATE public.estoque\r\n    SET \r\n        quantidade_atual = v_nova_quantidade_atual,\r\n        ultima_atualizacao = now()\r\n    WHERE id = p_estoque_id;\r\n\r\n    -- Passo 2: Insere o registro da movimenta√ß√£o\r\n    INSERT INTO public.movimentacoes_estoque(\r\n        estoque_id,\r\n        tipo,\r\n        quantidade,\r\n        usuario_id,\r\n        observacao,\r\n        funcionario_id,\r\n        organizacao_id\r\n    ) VALUES (\r\n        p_estoque_id,\r\n        'Sa√≠da por Uso', -- Tipo correto\r\n        p_quantidade,\r\n        p_usuario_id,\r\n        p_observacao,\r\n        p_funcionario_id,\r\n        p_organizacao_id\r\n    );\r\n\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "delete_category_and_children",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.delete_category_and_children(p_category_id bigint)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    WITH RECURSIVE sub_categories AS (\r\n        SELECT id FROM public.categorias_financeiras WHERE id = p_category_id\r\n        UNION ALL\r\n        SELECT c.id FROM public.categorias_financeiras c\r\n        INNER JOIN sub_categories sc ON c.parent_id = sc.id\r\n    )\r\n    DELETE FROM public.categorias_financeiras\r\n    WHERE id IN (SELECT id FROM sub_categories);\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "delete_contato_completo",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.delete_contato_completo(p_contato_id bigint)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- 1. Desassocia o contato como corretor das simula√ß√µes\r\n    -- Isso evita o erro de chave estrangeira que voc√™ encontrou\r\n    UPDATE public.simulacoes\r\n    SET corretor_id = NULL\r\n    WHERE corretor_id = p_contato_id;\r\n\r\n    -- 2. Desassocia o contato como cliente principal das simula√ß√µes\r\n    UPDATE public.simulacoes\r\n    SET contato_id = NULL\r\n    WHERE contato_id = p_contato_id;\r\n\r\n    -- 3. Remove o contato de qualquer funil de vendas\r\n    DELETE FROM public.contatos_no_funil\r\n    WHERE contato_id = p_contato_id;\r\n    \r\n    -- 4. Deleta os registros associados em outras tabelas (telefones, emails, etc.)\r\n    DELETE FROM public.telefones\r\n    WHERE contato_id = p_contato_id;\r\n\r\n    DELETE FROM public.emails\r\n    WHERE contato_id = p_contato_id;\r\n\r\n    -- Adicione aqui outras tabelas que tenham rela√ß√£o direta se necess√°rio\r\n    -- Ex: DELETE FROM public.crm_notas WHERE contato_id = p_contato_id;\r\n\r\n    -- 5. Finalmente, deleta o contato da tabela principal\r\n    DELETE FROM public.contatos\r\n    WHERE id = p_contato_id;\r\n\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "delete_lancamentos_futuros_do_grupo",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.delete_lancamentos_futuros_do_grupo(p_grupo_id uuid, p_data_referencia date, p_organizacao_id bigint)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    DELETE FROM public.lancamentos\r\n    WHERE\r\n        parcela_grupo = p_grupo_id AND\r\n        data_vencimento >= p_data_referencia AND\r\n        organizacao_id = p_organizacao_id;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "delete_pedidos_cancelados",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.delete_pedidos_cancelados(pedido_ids bigint[])\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    -- 1. Deleta os filhos diretos\r\n    DELETE FROM public.pedidos_compra_itens\r\n    WHERE pedido_compra_id = ANY(pedido_ids);\r\n    \r\n    DELETE FROM public.pedidos_compra_anexos\r\n    WHERE pedido_compra_id = ANY(pedido_ids);\r\n    \r\n    DELETE FROM public.pedidos_compra_status_historico\r\n    WHERE pedido_compra_id = ANY(pedido_ids);\r\n    \r\n    DELETE FROM public.pedidos_compra_notas\r\n    WHERE pedido_id = ANY(pedido_ids);\r\n\r\n    -- 2. Remove as liga√ß√µes (FKs) em outras tabelas\r\n    \r\n    -- Link dos Lan√ßamentos Financeiros\r\n    UPDATE public.lancamentos\r\n    SET pedido_compra_id = NULL\r\n    WHERE pedido_compra_id = ANY(pedido_ids);\r\n\r\n    /* ===================================================================\r\n     * CORRE√á√ÉO: ADICIONAMOS A ATUALIZA√á√ÉO NA TABELA DE ESTOQUE\r\n     * O Porqu√™: Quebra o \"elo\" com as movimenta√ß√µes de estoque\r\n     * antes de tentar deletar o pedido.\r\n     * ===================================================================\r\n     */\r\n    UPDATE public.movimentacoes_estoque\r\n    SET pedido_compra_id = NULL\r\n    WHERE pedido_compra_id = ANY(pedido_ids);\r\n\r\n    -- 3. Finalmente, deleta o pedido (pai)\r\n    DELETE FROM public.pedidos_compra\r\n    WHERE id = ANY(pedido_ids);\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "duplicar_contrato_e_detalhes",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.duplicar_contrato_e_detalhes(p_contrato_id bigint)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    rec_contrato record;\r\n    new_contrato_id bigint;\r\n    rec_parcela record;\r\n    rec_permuta record;\r\nBEGIN\r\n    -- 1. Encontra o contrato original para copiar os dados\r\n    SELECT * INTO rec_contrato FROM public.contratos WHERE id = p_contrato_id;\r\n\r\n    IF NOT FOUND THEN\r\n        RETURN json_build_object('success', false, 'message', 'Contrato original n√£o encontrado.');\r\n    END IF;\r\n\r\n    -- 2. Insere um novo contrato com os dados do original, mas com status \"Rascunho\" e sem produto_id\r\n    INSERT INTO public.contratos (\r\n        contato_id,\r\n        produto_id, -- Ficar√° nulo para ser preenchido depois\r\n        empreendimento_id,\r\n        data_venda,\r\n        valor_final_venda,\r\n        status_contrato, -- Definido como Rascunho\r\n        simulacao_id, -- Ficar√° nulo\r\n        corretor_id,\r\n        indice_reajuste,\r\n        multa_inadimplencia_percentual,\r\n        juros_mora_inadimplencia_percentual,\r\n        clausula_penal_percentual\r\n    )\r\n    VALUES (\r\n        rec_contrato.contato_id,\r\n        NULL, -- Importante: a c√≥pia n√£o vem atrelada a uma unidade\r\n        rec_contrato.empreendimento_id,\r\n        CURRENT_DATE, -- Usa a data atual para a c√≥pia\r\n        rec_contrato.valor_final_venda,\r\n        'Rascunho', -- Status inicial da c√≥pia\r\n        NULL, -- A simula√ß√£o n√£o √© copiada\r\n        rec_contrato.corretor_id,\r\n        rec_contrato.indice_reajuste,\r\n        rec_contrato.multa_inadimplencia_percentual,\r\n        rec_contrato.juros_mora_inadimplencia_percentual,\r\n        rec_contrato.clausula_penal_percentual\r\n    )\r\n    RETURNING id INTO new_contrato_id;\r\n\r\n    -- 3. Copia todas as parcelas do contrato original para o novo contrato\r\n    FOR rec_parcela IN SELECT * FROM public.contrato_parcelas WHERE contrato_id = p_contrato_id\r\n    LOOP\r\n        INSERT INTO public.contrato_parcelas (\r\n            contrato_id,\r\n            descricao,\r\n            tipo,\r\n            data_vencimento,\r\n            valor_parcela,\r\n            status_pagamento -- Parcelas da c√≥pia come√ßam como Pendente\r\n        )\r\n        VALUES (\r\n            new_contrato_id,\r\n            rec_parcela.descricao,\r\n            rec_parcela.tipo,\r\n            rec_parcela.data_vencimento,\r\n            rec_parcela.valor_parcela,\r\n            'Pendente'\r\n        );\r\n    END LOOP;\r\n\r\n    -- 4. Copia todas as permutas do contrato original para o novo contrato\r\n    FOR rec_permuta IN SELECT * FROM public.contrato_permutas WHERE contrato_id = p_contrato_id\r\n    LOOP\r\n        INSERT INTO public.contrato_permutas (\r\n            contrato_id,\r\n            descricao,\r\n            valor\r\n        )\r\n        VALUES (\r\n            new_contrato_id,\r\n            rec_permuta.descricao,\r\n            rec_permuta.valor\r\n        );\r\n    END LOOP;\r\n\r\n    -- 5. Retorna uma mensagem de sucesso\r\n    RETURN json_build_object('success', true, 'message', 'Contrato duplicado com sucesso como rascunho!');\r\n\r\nEXCEPTION\r\n    WHEN OTHERS THEN\r\n        -- Em caso de qualquer erro, retorna uma mensagem de falha\r\n        RETURN json_build_object('success', false, 'message', 'Erro ao duplicar contrato: ' || SQLERRM);\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "duplicar_parcela_contrato",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.duplicar_parcela_contrato(p_parcela_id integer)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    original_parcela RECORD;\r\n    nova_parcela_id INT;\r\nBEGIN\r\n    -- 1. Encontra a parcela original\r\n    SELECT * INTO original_parcela\r\n    FROM contrato_parcelas\r\n    WHERE id = p_parcela_id;\r\n\r\n    -- 2. Se n√£o encontrar, gera um erro\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Parcela com ID % n√£o encontrada.', p_parcela_id;\r\n    END IF;\r\n\r\n    -- 3. Insere a nova parcela apenas com os campos essenciais\r\n    INSERT INTO contrato_parcelas (\r\n        contrato_id,\r\n        descricao,\r\n        tipo,\r\n        data_vencimento,\r\n        valor_parcela,\r\n        status_pagamento\r\n    )\r\n    VALUES (\r\n        original_parcela.contrato_id,\r\n        original_parcela.descricao || ' (C√≥pia)',\r\n        'Adicional',\r\n        original_parcela.data_vencimento + INTERVAL '30 days',\r\n        original_parcela.valor_parcela,\r\n        'Pendente'\r\n    )\r\n    RETURNING id INTO nova_parcela_id;\r\n\r\n    -- 4. Confirma se a inser√ß√£o funcionou\r\n    IF nova_parcela_id IS NULL THEN\r\n        RAISE EXCEPTION 'A inser√ß√£o no banco de dados falhou silenciosamente.';\r\n    END IF;\r\n\r\n    -- 5. Retorna sucesso\r\n    RETURN json_build_object('success', true, 'message', 'Parcela duplicada com sucesso!');\r\n\r\nEXCEPTION\r\n    -- 6. Captura qualquer outro erro\r\n    WHEN OTHERS THEN\r\n        RETURN json_build_object('success', false, 'message', SQLERRM);\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "duplicar_pedido_compra",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.duplicar_pedido_compra(p_original_pedido_id bigint, p_novo_solicitante_id uuid)\n RETURNS SETOF pedidos_compra\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    novo_pedido_id BIGINT;\r\nBEGIN\r\n    -- 1. Cria um novo pedido de compra, copiando os dados do original\r\n    INSERT INTO public.pedidos_compra (\r\n        empreendimento_id,\r\n        solicitante_id,\r\n        data_solicitacao,\r\n        data_entrega_prevista,\r\n        status,\r\n        justificativa,\r\n        titulo,\r\n        turno_entrega\r\n    )\r\n    SELECT\r\n        p.empreendimento_id,\r\n        p_novo_solicitante_id, -- Define o novo solicitante\r\n        NOW(), -- Define a data atual como data da solicita√ß√£o\r\n        p.data_entrega_prevista,\r\n        'Pedido Realizado', -- Reseta o status para o inicial\r\n        p.justificativa,\r\n        p.titulo || ' - C√ìPIA', -- Adiciona \"C√ìPIA\" ao t√≠tulo\r\n        p.turno_entrega\r\n    FROM public.pedidos_compra p\r\n    WHERE p.id = p_original_pedido_id\r\n    RETURNING id INTO novo_pedido_id;\r\n\r\n    -- 2. Copia todos os itens do pedido original para o novo pedido\r\n    INSERT INTO public.pedidos_compra_itens (\r\n        pedido_compra_id,\r\n        orcamento_item_id,\r\n        material_id,\r\n        descricao_item,\r\n        quantidade_solicitada,\r\n        unidade_medida,\r\n        fornecedor_id,\r\n        preco_unitario_real,\r\n        custo_total_real,\r\n        etapa_id\r\n    )\r\n    SELECT\r\n        novo_pedido_id, -- Usa o ID do novo pedido criado\r\n        i.orcamento_item_id,\r\n        i.material_id,\r\n        i.descricao_item,\r\n        i.quantidade_solicitada,\r\n        i.unidade_medida,\r\n        i.fornecedor_id,\r\n        i.preco_unitario_real,\r\n        i.custo_total_real,\r\n        i.etapa_id\r\n    FROM public.pedidos_compra_itens i\r\n    WHERE i.pedido_compra_id = p_original_pedido_id;\r\n\r\n    -- 3. Retorna o pedido completo que foi criado\r\n    RETURN QUERY \r\n        SELECT * FROM public.pedidos_compra WHERE id = novo_pedido_id;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "encontrar_duplicatas_dinamico",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.encontrar_duplicatas_dinamico(p_criterios text[])\n RETURNS TABLE(id bigint, descricao text, valor numeric, data_transacao date, conta_id bigint, tipo text, favorecido_contato_id bigint, chave_duplicata text, contas_financeiras json, favorecido_contatos json)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    allowed_columns TEXT[] := ARRAY['data_transacao', 'descricao', 'valor', 'conta_id', 'tipo', 'favorecido_contato_id'];\r\n    valid_criteria TEXT[];\r\n    partition_clause TEXT;\r\n    md5_clause TEXT;\r\n    query TEXT;\r\nBEGIN\r\n    SELECT array_agg(c) INTO valid_criteria FROM unnest(p_criterios) c WHERE c = ANY(allowed_columns);\r\n\r\n    IF array_length(valid_criteria, 1) IS NULL THEN\r\n        RETURN;\r\n    END IF;\r\n\r\n    partition_clause := array_to_string(valid_criteria, ', ');\r\n    md5_clause := 'md5(concat(' || (\r\n        SELECT string_agg(format('COALESCE(%I::text, ''NULL'')', col), ', ')\r\n        FROM unnest(valid_criteria) col\r\n    ) || '))';\r\n\r\n    query := format('\r\n        WITH duplicatas AS (\r\n            SELECT\r\n                l.id,\r\n                l.descricao,\r\n                l.valor,\r\n                l.data_transacao,\r\n                l.conta_id,\r\n                l.tipo,\r\n                l.favorecido_contato_id,\r\n                %s AS chave_duplicata,\r\n                COUNT(*) OVER (PARTITION BY %s) as contagem\r\n            FROM\r\n                public.lancamentos l\r\n            WHERE\r\n                -- AQUI EST√Å A MUDAN√áA PRINCIPAL: Ignora lan√ßamentos j√° verificados\r\n                l.auditoria_verificado = FALSE\r\n        )\r\n        SELECT\r\n            d.id,\r\n            d.descricao,\r\n            d.valor,\r\n            d.data_transacao,\r\n            d.conta_id,\r\n            d.tipo,\r\n            d.favorecido_contato_id,\r\n            d.chave_duplicata,\r\n            json_build_object(''id'', cf.id, ''nome'', cf.nome) as contas_financeiras,\r\n            json_build_object(''id'', c.id, ''nome'', c.nome, ''razao_social'', c.razao_social) as favorecido_contatos\r\n        FROM\r\n            duplicatas d\r\n        JOIN\r\n            public.contas_financeiras cf ON d.conta_id = cf.id\r\n        LEFT JOIN\r\n            public.contatos c ON d.favorecido_contato_id = c.id\r\n        WHERE\r\n            d.contagem > 1\r\n        ORDER BY\r\n            d.chave_duplicata, d.id\r\n    ', md5_clause, partition_clause);\r\n\r\n    RETURN QUERY EXECUTE query;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "excluir_categoria_e_migrar",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.excluir_categoria_e_migrar(p_categoria_id bigint, p_nova_categoria_id bigint, p_organizacao_id bigint)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  -- A. Migra ou 'Orfaniza' os lan√ßamentos\r\n  UPDATE lancamentos\r\n  SET categoria_id = p_nova_categoria_id\r\n  WHERE categoria_id = p_categoria_id\r\n  AND organizacao_id = p_organizacao_id;\r\n\r\n  -- B. Deleta a categoria antiga\r\n  DELETE FROM categorias_financeiras\r\n  WHERE id = p_categoria_id\r\n  AND organizacao_id = p_organizacao_id;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "excluir_contrato_e_liberar_unidade",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.excluir_contrato_e_liberar_unidade(p_contrato_id bigint)\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_produto_id BIGINT;\r\nBEGIN\r\n    -- 1. Encontra o ID do produto associado ao contrato que ser√° exclu√≠do.\r\n    SELECT produto_id INTO v_produto_id\r\n    FROM public.contratos\r\n    WHERE id = p_contrato_id;\r\n\r\n    -- 2. Se encontrou um produto, atualiza seu status para 'Dispon√≠vel'.\r\n    IF v_produto_id IS NOT NULL THEN\r\n        UPDATE public.produtos_empreendimento\r\n        SET status = 'Dispon√≠vel'\r\n        WHERE id = v_produto_id;\r\n    END IF;\r\n\r\n    -- 3. Exclui o contrato.\r\n    DELETE FROM public.contratos\r\n    WHERE id = p_contrato_id;\r\n\r\n    -- 4. Retorna uma mensagem de sucesso.\r\n    RETURN 'Contrato exclu√≠do e unidade liberada com sucesso.';\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "excluir_contrato_e_liberar_unidade",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.excluir_contrato_e_liberar_unidade(p_contrato_id bigint, p_organizacao_id bigint)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_produto_id bigint;\r\n    v_parcelas_pagas_count integer;\r\nBEGIN\r\n    -- Verifica se o contrato pertence √† organiza√ß√£o correta\r\n    IF NOT EXISTS (\r\n        SELECT 1 FROM public.contratos\r\n        WHERE id = p_contrato_id AND organizacao_id = p_organizacao_id\r\n    ) THEN\r\n        RAISE EXCEPTION 'Contrato n√£o encontrado ou n√£o pertence √† sua organiza√ß√£o.';\r\n    END IF;\r\n\r\n    -- O PORQU√ä DA MUDAN√áA: Adicionamos uma verifica√ß√£o de seguran√ßa crucial.\r\n    -- A fun√ß√£o agora verifica se existem parcelas com status 'Pago' ou 'Conciliado'.\r\n    SELECT count(*)\r\n    INTO v_parcelas_pagas_count\r\n    FROM public.contrato_parcelas\r\n    WHERE contrato_id = p_contrato_id\r\n      AND (status_pagamento = 'Pago' OR status_pagamento = 'Conciliado');\r\n\r\n    -- Se houver UMA ou mais parcelas pagas, a fun√ß√£o gera um erro e para.\r\n    IF v_parcelas_pagas_count > 0 THEN\r\n        RAISE EXCEPTION 'N√£o √© poss√≠vel excluir um contrato que possui parcelas pagas.';\r\n    END IF;\r\n\r\n    -- Se passou pela verifica√ß√£o, continua com a l√≥gica original...\r\n    -- Pega o ID do produto associado ao contrato\r\n    SELECT produto_id INTO v_produto_id\r\n    FROM public.contratos\r\n    WHERE id = p_contrato_id;\r\n\r\n    -- Exclui o contrato (o CASCADE cuidar√° das parcelas e anexos)\r\n    DELETE FROM public.contratos WHERE id = p_contrato_id;\r\n\r\n    -- Se encontrou um produto, libera a unidade\r\n    IF v_produto_id IS NOT NULL THEN\r\n        UPDATE public.produtos_empreendimento\r\n        SET status = 'Dispon√≠vel'\r\n        WHERE id = v_produto_id;\r\n    END IF;\r\n\r\n    RETURN 'Contrato exclu√≠do e unidade liberada com sucesso!';\r\nEXCEPTION\r\n    WHEN OTHERS THEN\r\n        -- Retorna a mensagem de erro espec√≠fica para o frontend\r\n        RETURN 'Erro ao excluir: ' || SQLERRM;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "excluir_parcela_e_lancamento",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.excluir_parcela_e_lancamento(p_parcela_id bigint)\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_lancamento_id BIGINT;\r\n    v_parcela_descricao TEXT;\r\nBEGIN\r\n    -- Etapa 1: Encontrar o ID do lan√ßamento financeiro vinculado √† parcela, se houver.\r\n    SELECT lancamento_id, descricao INTO v_lancamento_id, v_parcela_descricao\r\n    FROM contrato_parcelas\r\n    WHERE id = p_parcela_id;\r\n\r\n    -- Se n√£o encontrar a parcela, retorna um erro.\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Parcela com ID % n√£o encontrada.', p_parcela_id;\r\n    END IF;\r\n\r\n    -- Etapa 2: Excluir a parcela do cronograma do contrato.\r\n    DELETE FROM contrato_parcelas WHERE id = p_parcela_id;\r\n\r\n    -- Etapa 3: Se existir um lan√ßamento vinculado, exclu√≠-lo tamb√©m.\r\n    IF v_lancamento_id IS NOT NULL THEN\r\n        DELETE FROM lancamentos WHERE id = v_lancamento_id;\r\n        RETURN 'Parcela \"' || v_parcela_descricao || '\" e seu lan√ßamento financeiro foram exclu√≠dos com sucesso.';\r\n    ELSE\r\n        RETURN 'Parcela \"' || v_parcela_descricao || '\" foi exclu√≠da com sucesso (n√£o possu√≠a lan√ßamento financeiro).';\r\n    END IF;\r\n\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "faxina_nuclear_por_dono",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.faxina_nuclear_por_dono()\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    r_grupo RECORD;\r\n    v_vencedor_id bigint;\r\n    v_ids_perdedores bigint[];\r\n    v_total_grupos int := 0;\r\n    v_total_deletados int := 0;\r\nBEGIN\r\n    -- 1. Encontra contatos que possuem mais de uma conversa aberta\r\n    FOR r_grupo IN\r\n        SELECT \r\n            contato_id,\r\n            -- O Vencedor √© a conversa atualizada mais recentemente (a √∫ltima que teve a√ß√£o)\r\n            ARRAY_AGG(id ORDER BY updated_at DESC) as ids\r\n        FROM public.whatsapp_conversations\r\n        WHERE contato_id IS NOT NULL\r\n        GROUP BY contato_id\r\n        HAVING COUNT(*) > 1\r\n    LOOP\r\n        -- O primeiro da lista (mais recente) vence e fica vivo\r\n        v_vencedor_id := r_grupo.ids[1];\r\n        \r\n        -- O resto (antigos) ser√£o sacrificados\r\n        v_ids_perdedores := r_grupo.ids[2:array_length(r_grupo.ids, 1)];\r\n\r\n        -- 2. Move as mensagens √≥rf√£s para a conversa vencedora\r\n        UPDATE public.whatsapp_messages\r\n        SET conversation_record_id = v_vencedor_id\r\n        WHERE conversation_record_id = ANY(v_ids_perdedores);\r\n\r\n        -- 3. Exclui as conversas duplicadas\r\n        DELETE FROM public.whatsapp_conversations\r\n        WHERE id = ANY(v_ids_perdedores);\r\n\r\n        v_total_grupos := v_total_grupos + 1;\r\n        v_total_deletados := v_total_deletados + array_length(v_ids_perdedores, 1);\r\n    END LOOP;\r\n\r\n    RETURN 'Faxina Nuclear Conclu√≠da: ' || v_total_grupos || ' contatos unificados. ' || v_total_deletados || ' conversas duplicadas foram exclu√≠das.';\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "filtrar_ids_contatos",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.filtrar_ids_contatos(p_organizacao_id bigint, p_search_term text, p_type_filter text)\n RETURNS TABLE(id bigint)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT DISTINCT c.id\r\n    FROM public.contatos c\r\n    LEFT JOIN public.telefones t ON c.id = t.contato_id\r\n    WHERE c.organizacao_id = p_organizacao_id\r\n    AND (\r\n        p_type_filter IS NULL \r\n        OR p_type_filter = 'Todos' \r\n        OR c.tipo_contato::text = p_type_filter\r\n    )\r\n    AND (\r\n        p_search_term IS NULL \r\n        OR p_search_term = ''\r\n        -- Busca no Nome e Raz√£o Social\r\n        OR c.nome ILIKE '%' || p_search_term || '%'\r\n        OR c.razao_social ILIKE '%' || p_search_term || '%'\r\n        OR c.nome_fantasia ILIKE '%' || p_search_term || '%'\r\n        -- Busca no Documento (CPF/CNPJ)\r\n        OR c.cpf ILIKE '%' || p_search_term || '%'\r\n        OR c.cnpj ILIKE '%' || p_search_term || '%'\r\n        -- Busca no Telefone (A grande novidade!)\r\n        OR t.telefone ILIKE '%' || p_search_term || '%'\r\n    );\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "financeiro_montar_where",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.financeiro_montar_where(p_organizacao_id bigint, p_filtros jsonb)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\r\ndeclare\r\n  v_where text;\r\n  v_use_competencia boolean;\r\nbegin\r\n  v_use_competencia := coalesce((p_filtros->>'useCompetencia')::boolean, false);\r\n  v_where := ' where l.organizacao_id = ' || p_organizacao_id;\r\n\r\n  -- 1. Busca Textual\r\n  if (p_filtros->>'searchTerm') is not null and (p_filtros->>'searchTerm') <> '' then\r\n    v_where := v_where || ' and l.descricao ilike ''%' || (p_filtros->>'searchTerm') || '%''';\r\n  end if;\r\n\r\n  -- 2. Datas (Lei da Fernanda)\r\n  if (p_filtros->>'startDate') is not null and (p_filtros->>'startDate') <> '' then\r\n    if v_use_competencia then\r\n        v_where := v_where || ' and l.data_transacao >= ''' || (p_filtros->>'startDate') || '''';\r\n    else\r\n        v_where := v_where || ' and (CASE WHEN l.data_pagamento IS NOT NULL THEN l.data_pagamento WHEN l.data_vencimento IS NOT NULL THEN l.data_vencimento ELSE l.data_transacao END) >= ''' || (p_filtros->>'startDate') || '''';\r\n    end if;\r\n  end if;\r\n\r\n  if (p_filtros->>'endDate') is not null and (p_filtros->>'endDate') <> '' then\r\n    if v_use_competencia then\r\n        v_where := v_where || ' and l.data_transacao <= ''' || (p_filtros->>'endDate') || '''';\r\n    else\r\n        v_where := v_where || ' and (CASE WHEN l.data_pagamento IS NOT NULL THEN l.data_pagamento WHEN l.data_vencimento IS NOT NULL THEN l.data_vencimento ELSE l.data_transacao END) <= ''' || (p_filtros->>'endDate') || '''';\r\n    end if;\r\n  end if;\r\n\r\n  -- 3. Status\r\n  if (p_filtros->'status') is not null and jsonb_array_length(p_filtros->'status') > 0 then\r\n      declare\r\n        v_or_conditions text[] := array[]::text[];\r\n      begin\r\n        if p_filtros->'status' @> '[\"Pago\"]' then\r\n          v_or_conditions := array_append(v_or_conditions, 'l.status in (''Pago'', ''Conciliado'')');\r\n        end if;\r\n        if p_filtros->'status' @> '[\"Pendente\"]' then\r\n          v_or_conditions := array_append(v_or_conditions, '(l.status = ''Pendente'' and coalesce(l.data_vencimento, l.data_transacao) >= current_date)');\r\n        end if;\r\n        if p_filtros->'status' @> '[\"Atrasada\"]' then\r\n          v_or_conditions := array_append(v_or_conditions, '(l.status = ''Pendente'' and coalesce(l.data_vencimento, l.data_transacao) < current_date)');\r\n        end if;\r\n\r\n        if array_length(v_or_conditions, 1) > 0 then\r\n           v_where := v_where || ' and (' || array_to_string(v_or_conditions, ' OR ') || ')';\r\n        end if;\r\n      end;\r\n  end if;\r\n\r\n  -- 4. Categorias (Chamada Segura da Fun√ß√£o Recursiva)\r\n  if (p_filtros->'categoriaIds') is not null and jsonb_array_length(p_filtros->'categoriaIds') > 0 then\r\n      if p_filtros->'categoriaIds' @> '[\"IS_NULL\"]' then\r\n        v_where := v_where || ' and (l.categoria_id in (select id from get_recursive_categories(''' || (p_filtros->'categoriaIds') || ''')) or l.categoria_id is null)';\r\n      else\r\n        v_where := v_where || ' and l.categoria_id in (select id from get_recursive_categories(''' || (p_filtros->'categoriaIds') || '''))';\r\n      end if;\r\n  end if;\r\n\r\n  -- 5. Contas (L√≥gica Segura sem refer√™ncia externa)\r\n  if (p_filtros->'contaIds') is not null and jsonb_array_length(p_filtros->'contaIds') > 0 then\r\n      if p_filtros->'contaIds' @> '[\"IS_NULL\"]' then\r\n        v_where := v_where || ' and (l.conta_id in (select (elem::text)::bigint from jsonb_array_elements(''' || (p_filtros->'contaIds') || ''') elem where (elem::text) <> ''\"IS_NULL\"'') or l.conta_id is null)';\r\n      else\r\n        v_where := v_where || ' and l.conta_id in (select (elem::text)::bigint from jsonb_array_elements(''' || (p_filtros->'contaIds') || ''') elem)';\r\n      end if;\r\n  end if;\r\n\r\n  -- 6. Empreendimentos\r\n  if (p_filtros->'empreendimentoIds') is not null and jsonb_array_length(p_filtros->'empreendimentoIds') > 0 then\r\n      if p_filtros->'empreendimentoIds' @> '[\"IS_NULL\"]' then\r\n        v_where := v_where || ' and (l.empreendimento_id in (select (elem::text)::bigint from jsonb_array_elements(''' || (p_filtros->'empreendimentoIds') || ''') elem where (elem::text) <> ''\"IS_NULL\"'') or l.empreendimento_id is null)';\r\n      else\r\n        v_where := v_where || ' and l.empreendimento_id in (select (elem::text)::bigint from jsonb_array_elements(''' || (p_filtros->'empreendimentoIds') || ''') elem)';\r\n      end if;\r\n  end if;\r\n\r\n  -- 7. Empresas\r\n  if (p_filtros->'empresaIds') is not null and jsonb_array_length(p_filtros->'empresaIds') > 0 then\r\n      if p_filtros->'empresaIds' @> '[\"IS_NULL\"]' then\r\n        v_where := v_where || ' and (l.empresa_id in (select (elem::text)::bigint from jsonb_array_elements(''' || (p_filtros->'empresaIds') || ''') elem where (elem::text) <> ''\"IS_NULL\"'') or l.empresa_id is null)';\r\n      else\r\n        v_where := v_where || ' and l.empresa_id in (select (elem::text)::bigint from jsonb_array_elements(''' || (p_filtros->'empresaIds') || ''') elem)';\r\n      end if;\r\n  end if;\r\n  \r\n  -- 8. Etapas\r\n  if (p_filtros->'etapaIds') is not null and jsonb_array_length(p_filtros->'etapaIds') > 0 then\r\n      if p_filtros->'etapaIds' @> '[\"IS_NULL\"]' then\r\n        v_where := v_where || ' and (l.etapa_id in (select (elem::text)::bigint from jsonb_array_elements(''' || (p_filtros->'etapaIds') || ''') elem where (elem::text) <> ''\"IS_NULL\"'') or l.etapa_id is null)';\r\n      else\r\n        v_where := v_where || ' and l.etapa_id in (select (elem::text)::bigint from jsonb_array_elements(''' || (p_filtros->'etapaIds') || ''') elem)';\r\n      end if;\r\n  end if;\r\n\r\n  -- 9. Tipo (Receita/Despesa) - Tratamento Seguro\r\n  if (p_filtros->'tipo') is not null and jsonb_array_length(p_filtros->'tipo') > 0 then\r\n    -- Aqui n√£o precisamos de cast para bigint, √© texto\r\n    v_where := v_where || ' and l.tipo in (select elem::text from jsonb_array_elements_text(''' || (p_filtros->'tipo') || ''') elem)';\r\n  end if;\r\n\r\n  -- 10. Favorecido\r\n  if (p_filtros->>'favorecidoId') is not null then\r\n    if (p_filtros->>'favorecidoId') = 'IS_NULL' then\r\n       v_where := v_where || ' and l.favorecido_contato_id is null';\r\n    else\r\n       v_where := v_where || ' and l.favorecido_contato_id = ' || (p_filtros->>'favorecidoId');\r\n    end if;\r\n  end if;\r\n\r\n  -- 11. Ignorar Especiais (A L√ìGICA DE EXCLUS√ÉO IMPORTANTE)\r\n  if (p_filtros->>'ignoreTransfers')::boolean is true then\r\n    v_where := v_where || ' and l.transferencia_id is null';\r\n  end if;\r\n\r\n  if (p_filtros->>'ignoreChargebacks')::boolean is true then\r\n    v_where := v_where || ' and (l.categoria_id not in (189, 308) or l.categoria_id is null)';\r\n  end if;\r\n\r\n  return v_where;\r\nend;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "find_contact_by_phone",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.find_contact_by_phone(phone_input text)\n RETURNS bigint\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  clean_phone text;\r\n  found_id bigint;\r\nBEGIN\r\n  -- Limpa o n√∫mero de entrada\r\n  clean_phone := regexp_replace(phone_input, '\\D', '', 'g');\r\n  \r\n  SELECT c.id INTO found_id\r\n  FROM telefones t\r\n  JOIN contatos c ON c.id = t.contato_id\r\n  WHERE \r\n    -- Mesma l√≥gica de busca flex√≠vel de antes\r\n    regexp_replace(t.telefone, '\\D', '', 'g') = clean_phone\r\n    OR (length(clean_phone) > 11 AND regexp_replace(t.telefone, '\\D', '', 'g') = right(clean_phone, -2))\r\n    OR (length(clean_phone) <= 11 AND regexp_replace(t.telefone, '\\D', '', 'g') = '55' || clean_phone)\r\n  ORDER BY \r\n    -- AQUI EST√Å A M√ÅGICA:\r\n    -- Prioridade 1: Nome existe e N√ÉO come√ßa com 'Lead' (Ex: \"Raul\")\r\n    CASE WHEN c.nome IS NOT NULL AND c.nome NOT ILIKE 'Lead%' THEN 0 ELSE 1 END,\r\n    -- Prioridade 2: Se ambos forem Leads (ou ambos reais), pega o mais recente\r\n    c.created_at DESC \r\n  LIMIT 1;\r\n\r\n  RETURN found_id;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "find_contact_smart",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.find_contact_smart(phone_input text)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  clean_phone text;\r\n  phone_suffix text;\r\n  phone_ddd text;\r\n  is_brazil boolean;\r\n  found_id uuid;\r\nBEGIN\r\n  -- 1. Limpeza: deixa s√≥ n√∫meros\r\n  clean_phone := regexp_replace(phone_input, '[^0-9]', '', 'g');\r\n\r\n  -- 2. √â Brasil? (Come√ßa com 55 E tem tamanho de celular BR 12/13 digitos)\r\n  is_brazil := (left(clean_phone, 2) = '55' AND length(clean_phone) >= 12);\r\n\r\n  -- üåé CAMINHO INTERNACIONAL (EUA, etc)\r\n  IF NOT is_brazil THEN\r\n    -- Busca EXATA. Se o webhook salvou 1774..., busca 1774...\r\n    SELECT contato_id INTO found_id\r\n    FROM telefones\r\n    WHERE regexp_replace(telefone, '[^0-9]', '', 'g') = clean_phone\r\n    ORDER BY created_at DESC\r\n    LIMIT 1;\r\n    \r\n    RETURN found_id;\r\n  END IF;\r\n\r\n  -- üáßüá∑ CAMINHO BRASILEIRO (L√≥gica flex√≠vel do 9¬∫ D√≠gito)\r\n  phone_suffix := right(clean_phone, 8);\r\n  phone_ddd := substring(clean_phone from 3 for 2);\r\n\r\n  SELECT contato_id INTO found_id\r\n  FROM telefones\r\n  WHERE \r\n    (telefone LIKE '%' || phone_ddd || '%') \r\n    AND\r\n    right(regexp_replace(telefone, '[^0-9]', '', 'g'), 8) = phone_suffix\r\n  ORDER BY created_at DESC\r\n  LIMIT 1;\r\n\r\n  RETURN found_id;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "fundir_cargos",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.fundir_cargos(p_ids_origem bigint[], p_id_destino bigint, p_organizacao_id bigint)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- 1. Move os funcion√°rios dos cargos antigos para o novo\r\n    UPDATE public.funcionarios\r\n    SET cargo_id = p_id_destino\r\n    WHERE cargo_id = ANY(p_ids_origem)\r\n    AND organizacao_id = p_organizacao_id;\r\n\r\n    -- 2. Deleta os cargos antigos que agora est√£o vazios\r\n    DELETE FROM public.cargos\r\n    WHERE id = ANY(p_ids_origem)\r\n    AND id <> p_id_destino -- Seguran√ßa para n√£o deletar o destino\r\n    AND organizacao_id = p_organizacao_id;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "garantir_simulacao_para_contrato",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.garantir_simulacao_para_contrato(p_contrato_id bigint)\n RETURNS TABLE(id bigint, empreendimento_id bigint, produto_id bigint, contato_id bigint, valor_venda numeric, desconto_percentual numeric, desconto_valor numeric, entrada_percentual numeric, entrada_valor numeric, num_parcelas_entrada integer, data_primeira_parcela_entrada date, parcelas_obra_percentual numeric, parcelas_obra_valor numeric, num_parcelas_obra integer, data_primeira_parcela_obra date, saldo_remanescente_percentual numeric, saldo_remanescente_valor numeric)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_simulacao_id BIGINT;\r\n    v_contrato RECORD;\r\n    v_configuracao RECORD;\r\nBEGIN\r\n    -- Busca os dados do contrato\r\n    SELECT * INTO v_contrato FROM public.contratos WHERE contratos.id = p_contrato_id;\r\n\r\n    -- Verifica se o contrato j√° tem uma simula√ß√£o associada\r\n    IF v_contrato.simulacao_id IS NOT NULL THEN\r\n        v_simulacao_id := v_contrato.simulacao_id;\r\n    ELSE\r\n        -- Se n√£o tiver, busca a configura√ß√£o padr√£o do empreendimento\r\n        SELECT * INTO v_configuracao FROM public.configuracoes_venda WHERE configuracoes_venda.empreendimento_id = v_contrato.empreendimento_id;\r\n\r\n        -- Cria uma nova simula√ß√£o para o contrato\r\n        INSERT INTO public.simulacoes (\r\n            contrato_id,\r\n            contato_id,\r\n            empreendimento_id,\r\n            produto_id,\r\n            valor_venda,\r\n            desconto_percentual,\r\n            entrada_percentual,\r\n            num_parcelas_entrada,\r\n            data_primeira_parcela_entrada,\r\n            parcelas_obra_percentual,\r\n            num_parcelas_obra,\r\n            data_primeira_parcela_obra,\r\n            saldo_remanescente_percentual,\r\n            status\r\n        )\r\n        VALUES (\r\n            p_contrato_id,\r\n            v_contrato.contato_id,\r\n            v_contrato.empreendimento_id,\r\n            v_contrato.produto_id,\r\n            v_contrato.valor_final_venda,\r\n            COALESCE(v_configuracao.desconto_percentual, 0),\r\n            COALESCE(v_configuracao.entrada_percentual, 0),\r\n            COALESCE(v_configuracao.num_parcelas_entrada, 1),\r\n            v_configuracao.data_primeira_parcela_entrada,\r\n            COALESCE(v_configuracao.parcelas_obra_percentual, 0),\r\n            COALESCE(v_configuracao.num_parcelas_obra, 1),\r\n            v_configuracao.data_primeira_parcela_obra,\r\n            COALESCE(v_configuracao.saldo_remanescente_percentual, 0),\r\n            'Vinculada'\r\n        ) RETURNING simulacoes.id INTO v_simulacao_id;\r\n\r\n        -- Atualiza o contrato com o ID da nova simula√ß√£o\r\n        UPDATE public.contratos SET simulacao_id = v_simulacao_id WHERE contratos.id = p_contrato_id;\r\n    END IF;\r\n\r\n    -- Retorna os dados da simula√ß√£o encontrada ou criada\r\n    RETURN QUERY\r\n    SELECT\r\n        s.id,\r\n        s.empreendimento_id,\r\n        s.produto_id,\r\n        s.contato_id,\r\n        s.valor_venda,\r\n        s.desconto_percentual,\r\n        s.desconto_valor,\r\n        s.entrada_percentual,\r\n        s.entrada_valor,\r\n        s.num_parcelas_entrada,\r\n        s.data_primeira_parcela_entrada,\r\n        s.parcelas_obra_percentual,\r\n        s.parcelas_obra_valor,\r\n        s.num_parcelas_obra,\r\n        s.data_primeira_parcela_obra,\r\n        s.saldo_remanescente_percentual,\r\n        s.saldo_remanescente_valor\r\n    FROM public.simulacoes s\r\n    WHERE s.id = v_simulacao_id;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "garantir_simulacao_para_contrato",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.garantir_simulacao_para_contrato(p_contrato_id bigint, p_organizacao_id bigint)\n RETURNS json\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    simulacao_rec record;\r\nBEGIN\r\n    SELECT * INTO simulacao_rec FROM public.simulacoes WHERE contrato_id = p_contrato_id LIMIT 1;\r\n    IF FOUND THEN\r\n        RETURN row_to_json(simulacao_rec);\r\n    END IF;\r\n\r\n    INSERT INTO public.simulacoes (\r\n        contrato_id, contato_id, empreendimento_id, corretor_id,\r\n        valor_venda, status, organizacao_id, produto_id\r\n    )\r\n    SELECT\r\n        id, contato_id, empreendimento_id, corretor_id,\r\n        valor_final_venda, 'Aprovado', organizacao_id,\r\n        (SELECT produto_id FROM public.contrato_produtos WHERE contrato_id = p_contrato_id LIMIT 1)\r\n    FROM public.contratos\r\n    WHERE id = p_contrato_id AND organizacao_id = p_organizacao_id\r\n    RETURNING * INTO simulacao_rec;\r\n\r\n    UPDATE public.contratos SET simulacao_id = simulacao_rec.id WHERE id = p_contrato_id;\r\n    RETURN row_to_json(simulacao_rec);\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "gerar_ou_atualizar_contracheque",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.gerar_ou_atualizar_contracheque(p_funcionario_id bigint, p_mes_referencia text, p_organizacao_id bigint)\n RETURNS SETOF contracheques\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    -- Vari√°veis para os c√°lculos\r\n    v_salario_base numeric;\r\n    v_valor_diaria_base numeric;\r\n    v_dias_trabalhados integer;\r\n    v_valor_total_diarias numeric;\r\n    v_bonus numeric;\r\n    v_salario_bruto numeric;\r\n    v_faixa_inss numeric;\r\n    v_desconto_inss numeric;\r\n    v_base_calculo_fgts numeric;\r\n    v_valor_fgts numeric;\r\n    v_base_calculo_irrf numeric;\r\n    v_outros_descontos numeric;\r\n    v_adicionais numeric;\r\n    v_custo_inss_patronal numeric;\r\n    v_custo_rat numeric;\r\n    v_custo_terceiros numeric;\r\nBEGIN\r\n    -- 1. Buscar Sal√°rio\r\n    SELECT salario_base, valor_diaria INTO v_salario_base, v_valor_diaria_base\r\n    FROM public.historico_salarial\r\n    WHERE funcionario_id = p_funcionario_id\r\n      AND organizacao_id = p_organizacao_id\r\n      AND data_inicio_vigencia <= (p_mes_referencia || '-01')::date\r\n    ORDER BY data_inicio_vigencia DESC\r\n    LIMIT 1;\r\n\r\n    IF v_salario_base IS NULL THEN\r\n        SELECT base_salary, daily_value INTO v_salario_base, v_valor_diaria_base\r\n        FROM public.funcionarios\r\n        WHERE id = p_funcionario_id AND organizacao_id = p_organizacao_id;\r\n    END IF;\r\n\r\n    v_salario_base := COALESCE(v_salario_base, 0);\r\n    v_valor_diaria_base := COALESCE(v_valor_diaria_base, 0);\r\n\r\n    -- 2. Calcular Dias e Di√°rias a partir da tabela 'pontos'\r\n    SELECT \r\n        COUNT(DISTINCT data_hora::date),\r\n        COUNT(DISTINCT data_hora::date) * v_valor_diaria_base\r\n    INTO v_dias_trabalhados, v_valor_total_diarias\r\n    FROM public.pontos\r\n    WHERE funcionario_id = p_funcionario_id\r\n      AND organizacao_id = p_organizacao_id\r\n      AND DATE_TRUNC('month', data_hora) = (p_mes_referencia || '-01')::date;\r\n      \r\n    v_dias_trabalhados := COALESCE(v_dias_trabalhados, 0);\r\n    v_valor_total_diarias := COALESCE(v_valor_total_diarias, 0);\r\n\r\n    -- 3. Fazer todos os outros c√°lculos\r\n    v_bonus := GREATEST(0, v_valor_total_diarias - v_salario_base);\r\n    v_salario_bruto := GREATEST(v_salario_base, v_valor_total_diarias);\r\n    v_desconto_inss := calcular_inss(v_salario_base);\r\n    v_faixa_inss := obter_faixa_inss(v_salario_base);\r\n    v_base_calculo_fgts := v_salario_base;\r\n    v_valor_fgts := v_base_calculo_fgts * 0.08;\r\n    v_base_calculo_irrf := v_salario_base - v_desconto_inss;\r\n    v_outros_descontos := 0;\r\n    v_adicionais := 0;\r\n    v_custo_inss_patronal := v_salario_base * 0.20;\r\n    v_custo_rat := v_salario_base * 0.03;\r\n    v_custo_terceiros := v_salario_base * 0.058;\r\n\r\n    -- =================================================================================\r\n    -- IN√çCIO DA CORRE√á√ÉO (UPSERT)\r\n    -- O PORQU√ä: Substitu√≠mos o bloco IF/ELSE por um √∫nico comando INSERT ... ON CONFLICT.\r\n    -- Ele tenta inserir. Se a constraint 'contracheques_funcionario_mes_unico' (que verifica\r\n    -- a combina√ß√£o de funcion√°rio, m√™s e organiza√ß√£o) for violada, em vez de dar erro,\r\n    -- ele executa o bloco DO UPDATE, atualizando os campos do registro que j√° existe.\r\n    -- Isso √© at√¥mico, mais r√°pido e resolve o erro de chave duplicada.\r\n    -- =================================================================================\r\n    INSERT INTO public.contracheques (\r\n        funcionario_id, mes_referencia, organizacao_id, salario_base, valor_diaria_base, \r\n        dias_trabalhados, valor_total_diarias, bonus, salario_bruto, faixa_inss, \r\n        desconto_inss, base_calculo_fgts, valor_fgts, base_calculo_irrf, \r\n        outros_descontos, adicionais, custo_inss_patronal, custo_rat, \r\n        custo_terceiros, status\r\n    ) VALUES (\r\n        p_funcionario_id, (p_mes_referencia || '-01')::date, p_organizacao_id, v_salario_base, v_valor_diaria_base,\r\n        v_dias_trabalhados, v_valor_total_diarias, v_bonus, v_salario_bruto, v_faixa_inss,\r\n        v_desconto_inss, v_base_calculo_fgts, v_valor_fgts, v_base_calculo_irrf,\r\n        v_outros_descontos, v_adicionais, v_custo_inss_patronal, v_custo_rat,\r\n        v_custo_terceiros, 'Pendente'\r\n    )\r\n    ON CONFLICT (funcionario_id, mes_referencia, organizacao_id) DO UPDATE SET\r\n        salario_base = EXCLUDED.salario_base,\r\n        valor_diaria_base = EXCLUDED.valor_diaria_base,\r\n        dias_trabalhados = EXCLUDED.dias_trabalhados,\r\n        valor_total_diarias = EXCLUDED.valor_total_diarias,\r\n        bonus = EXCLUDED.bonus,\r\n        salario_bruto = EXCLUDED.salario_bruto,\r\n        faixa_inss = EXCLUDED.faixa_inss,\r\n        desconto_inss = EXCLUDED.desconto_inss,\r\n        base_calculo_fgts = EXCLUDED.base_calculo_fgts,\r\n        valor_fgts = EXCLUDED.valor_fgts,\r\n        base_calculo_irrf = EXCLUDED.base_calculo_irrf,\r\n        outros_descontos = EXCLUDED.outros_descontos,\r\n        adicionais = EXCLUDED.adicionais,\r\n        custo_inss_patronal = EXCLUDED.custo_inss_patronal,\r\n        custo_rat = EXCLUDED.custo_rat,\r\n        custo_terceiros = EXCLUDED.custo_terceiros;\r\n    -- =================================================================================\r\n    -- FIM DA CORRE√á√ÉO\r\n    -- =================================================================================\r\n\r\n    -- Retorna o contracheque que foi inserido ou atualizado\r\n    RETURN QUERY\r\n    SELECT *\r\n    FROM public.contracheques\r\n    WHERE funcionario_id = p_funcionario_id\r\n      AND mes_referencia = (p_mes_referencia || '-01')::date\r\n      AND organizacao_id = p_organizacao_id;\r\n      \r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "gerar_ou_atualizar_contracheque",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.gerar_ou_atualizar_contracheque(p_funcionario_id bigint, p_mes_referencia text)\n RETURNS SETOF contracheques\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_mes_date date := to_date(p_mes_referencia || '-01', 'YYYY-MM-DD');\r\n    v_funcionario record;\r\n    v_ponto_resumo record;\r\n    v_salario_bruto numeric;\r\n    v_bonus numeric;\r\n    v_faixa_inss numeric;\r\n    v_desconto_inss numeric;\r\n    v_base_fgts numeric;\r\n    v_valor_fgts numeric;\r\n    v_base_irrf numeric;\r\n    v_contracheque_id bigint;\r\n    v_daily_value_numeric numeric;\r\n    v_base_salary_numeric numeric;\r\n    v_total_salary_numeric numeric;\r\n    -- NOVAS VARI√ÅVEIS PARA CUSTOS DA EMPRESA\r\n    v_custo_inss_patronal numeric;\r\n    v_custo_rat numeric;\r\n    v_custo_terceiros numeric;\r\nBEGIN\r\n    -- 1. Buscar dados do funcion√°rio\r\n    SELECT id, daily_value, base_salary, total_salary, jornada_id\r\n    INTO v_funcionario\r\n    FROM public.funcionarios\r\n    WHERE id = p_funcionario_id;\r\n\r\n    IF v_funcionario IS NULL THEN\r\n        RAISE EXCEPTION 'Funcion√°rio com ID % n√£o encontrado', p_funcionario_id;\r\n    END IF;\r\n\r\n    -- Converte os campos de texto para num√©rico de forma segura\r\n    v_daily_value_numeric := COALESCE(NULLIF(REPLACE(REPLACE(TRIM(REPLACE(v_funcionario.daily_value, 'R$', '')), '.', ''), ',', '.'), '')::numeric, 0);\r\n    v_base_salary_numeric := COALESCE(NULLIF(REPLACE(REPLACE(TRIM(REPLACE(v_funcionario.base_salary, 'R$', '')), '.', ''), ',', '.'), '')::numeric, 0);\r\n    v_total_salary_numeric := COALESCE(NULLIF(REPLACE(REPLACE(TRIM(REPLACE(v_funcionario.total_salary, 'R$', '')), '.', ''), ',', '.'), '')::numeric, 0);\r\n\r\n    -- 2. Chamar a fun√ß√£o de ponto para obter dias trabalhados\r\n    SELECT dias_trabalhados INTO v_ponto_resumo\r\n    FROM calcular_resumo_ponto_mensal(p_funcionario_id, p_mes_referencia);\r\n\r\n    -- 3. Calcular valores base do funcion√°rio\r\n    v_salario_bruto := v_base_salary_numeric + GREATEST(0, (v_ponto_resumo.dias_trabalhados * v_daily_value_numeric) - v_base_salary_numeric);\r\n    v_bonus := GREATEST(0, v_salario_bruto - v_base_salary_numeric);\r\n\r\n    -- 4. Calcular INSS do funcion√°rio sobre o SAL√ÅRIO BASE\r\n    SELECT\r\n        CASE\r\n            WHEN v_base_salary_numeric <= 1518.00 THEN 7.5 WHEN v_base_salary_numeric <= 2793.88 THEN 9.0\r\n            WHEN v_base_salary_numeric <= 4190.83 THEN 12.0 WHEN v_base_salary_numeric <= 8157.41 THEN 14.0\r\n            ELSE 14.0\r\n        END,\r\n        CASE\r\n            WHEN v_base_salary_numeric <= 1518.00 THEN v_base_salary_numeric * 0.075\r\n            WHEN v_base_salary_numeric <= 2793.88 THEN v_base_salary_numeric * 0.09\r\n            WHEN v_base_salary_numeric <= 4190.83 THEN v_base_salary_numeric * 0.12\r\n            WHEN v_base_salary_numeric <= 8157.41 THEN v_base_salary_numeric * 0.14\r\n            ELSE 8157.41 * 0.14\r\n        END\r\n    INTO v_faixa_inss, v_desconto_inss;\r\n\r\n    -- 5. Calcular FGTS e Base IRRF sobre o SAL√ÅRIO BASE\r\n    v_base_fgts := v_base_salary_numeric;\r\n    v_valor_fgts := v_base_fgts * 0.08;\r\n    v_base_irrf := v_base_salary_numeric - v_desconto_inss;\r\n\r\n    -- ***** IN√çCIO DA NOVA L√ìGICA *****\r\n    -- 6. Calcular CUSTOS DA EMPRESA sobre o SAL√ÅRIO BASE\r\n    v_custo_inss_patronal := v_base_salary_numeric * 0.20;\r\n    v_custo_rat := v_base_salary_numeric * 0.03;\r\n    v_custo_terceiros := v_base_salary_numeric * 0.058;\r\n    -- ***** FIM DA NOVA L√ìGICA *****\r\n\r\n    -- 7. Inserir ou atualizar o registro do contracheque com TODOS os dados\r\n    INSERT INTO public.contracheques (\r\n        funcionario_id, mes_referencia, salario_base, valor_diaria_base, dias_trabalhados,\r\n        valor_total_diarias, bonus, salario_bruto, faixa_inss, desconto_inss,\r\n        base_calculo_fgts, valor_fgts, base_calculo_irrf,\r\n        custo_inss_patronal, custo_rat, custo_terceiros\r\n    )\r\n    VALUES (\r\n        p_funcionario_id, v_mes_date, v_base_salary_numeric, v_daily_value_numeric, v_ponto_resumo.dias_trabalhados,\r\n        (v_ponto_resumo.dias_trabalhados * v_daily_value_numeric), v_bonus, v_salario_bruto, v_faixa_inss, v_desconto_inss,\r\n        v_base_fgts, v_valor_fgts, v_base_irrf,\r\n        v_custo_inss_patronal, v_custo_rat, v_custo_terceiros\r\n    )\r\n    ON CONFLICT (funcionario_id, mes_referencia)\r\n    DO UPDATE SET\r\n        salario_base = EXCLUDED.salario_base,\r\n        valor_diaria_base = EXCLUDED.valor_diaria_base,\r\n        dias_trabalhados = EXCLUDED.dias_trabalhados,\r\n        valor_total_diarias = EXCLUDED.valor_total_diarias,\r\n        bonus = EXCLUDED.bonus,\r\n        salario_bruto = EXCLUDED.salario_bruto,\r\n        faixa_inss = EXCLUDED.faixa_inss,\r\n        desconto_inss = EXCLUDED.desconto_inss,\r\n        base_calculo_fgts = EXCLUDED.base_calculo_fgts,\r\n        valor_fgts = EXCLUDED.valor_fgts,\r\n        base_calculo_irrf = EXCLUDED.base_calculo_irrf,\r\n        custo_inss_patronal = EXCLUDED.custo_inss_patronal,\r\n        custo_rat = EXCLUDED.custo_rat,\r\n        custo_terceiros = EXCLUDED.custo_terceiros\r\n    RETURNING id INTO v_contracheque_id;\r\n\r\n    -- 8. Retornar o registro completo\r\n    RETURN QUERY SELECT * FROM public.contracheques WHERE id = v_contracheque_id;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "gerar_parcelas_contrato",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.gerar_parcelas_contrato()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    config_venda RECORD;\r\n    permuta_total NUMERIC;\r\n    valor_base NUMERIC;\r\n    valor_entrada NUMERIC;\r\n    valor_obra NUMERIC;\r\n    valor_adicionais NUMERIC;\r\n    valor_remanescente NUMERIC;\r\n    valor_parcela_entrada NUMERIC;\r\n    valor_parcela_obra NUMERIC;\r\n    primeira_data_entrada DATE;\r\n    primeira_data_obra DATE;\r\n    i INTEGER;\r\nBEGIN\r\n    -- Busca a configura√ß√£o de venda para o empreendimento do contrato\r\n    SELECT * INTO config_venda\r\n    FROM public.configuracoes_venda\r\n    WHERE empreendimento_id = NEW.empreendimento_id;\r\n\r\n    -- Se n√£o houver configura√ß√£o, n√£o faz nada\r\n    IF NOT FOUND THEN\r\n        RETURN NEW;\r\n    END IF;\r\n\r\n    -- Calcula o total de permutas (se houver)\r\n    SELECT COALESCE(SUM(valor), 0) INTO permuta_total\r\n    FROM public.contrato_permutas\r\n    WHERE contrato_id = NEW.id;\r\n\r\n    -- Pega o valor final da venda \"congelado\" no contrato\r\n    valor_base := NEW.valor_final_venda;\r\n\r\n    -- Calcula os valores de cada bloco\r\n    valor_entrada := valor_base * (config_venda.entrada_percentual / 100.0);\r\n    valor_obra := valor_base * (config_venda.parcelas_obra_percentual / 100.0);\r\n    \r\n    -- Gera as parcelas da ENTRADA\r\n    primeira_data_entrada := COALESCE(config_venda.data_primeira_parcela_entrada, NEW.data_venda + INTERVAL '30 days');\r\n    IF config_venda.num_parcelas_entrada > 0 THEN\r\n        valor_parcela_entrada := valor_entrada / config_venda.num_parcelas_entrada;\r\n        FOR i IN 1..config_venda.num_parcelas_entrada LOOP\r\n            INSERT INTO public.contrato_parcelas (contrato_id, descricao, tipo, data_vencimento, valor_parcela)\r\n            VALUES (NEW.id, 'Entrada ' || i || '/' || config_venda.num_parcelas_entrada, 'Entrada', primeira_data_entrada + (INTERVAL '1 month' * (i-1)), valor_parcela_entrada);\r\n        END LOOP;\r\n    END IF;\r\n\r\n    -- Gera as parcelas da OBRA\r\n    primeira_data_obra := COALESCE(config_venda.data_primeira_parcela_obra, primeira_data_entrada + (INTERVAL '1 month' * config_venda.num_parcelas_entrada));\r\n    IF config_venda.num_parcelas_obra > 0 THEN\r\n        valor_parcela_obra := valor_obra / config_venda.num_parcelas_obra;\r\n        FOR i IN 1..config_venda.num_parcelas_obra LOOP\r\n            INSERT INTO public.contrato_parcelas (contrato_id, descricao, tipo, data_vencimento, valor_parcela)\r\n            VALUES (NEW.id, 'Parcela Obra ' || i || '/' || config_venda.num_parcelas_obra, 'Obra', primeira_data_obra + (INTERVAL '1 month' * (i-1)), valor_parcela_obra);\r\n        END LOOP;\r\n    END IF;\r\n\r\n    -- Calcula o total de parcelas adicionais do plano\r\n    SELECT COALESCE(SUM(valor), 0) INTO valor_adicionais\r\n    FROM public.parcelas_adicionais\r\n    WHERE configuracao_venda_id = config_venda.id;\r\n\r\n    -- Insere as parcelas ADICIONAIS\r\n    INSERT INTO public.contrato_parcelas (contrato_id, descricao, tipo, data_vencimento, valor_parcela)\r\n    SELECT NEW.id, 'Parcela Adicional', 'Adicional', pa.data_pagamento, pa.valor\r\n    FROM public.parcelas_adicionais pa\r\n    WHERE pa.configuracao_venda_id = config_venda.id;\r\n\r\n    -- Calcula e insere o SALDO REMANESCENTE\r\n    valor_remanescente := valor_base - valor_entrada - valor_obra - valor_adicionais - permuta_total;\r\n    IF valor_remanescente > 0 THEN\r\n        INSERT INTO public.contrato_parcelas (contrato_id, descricao, tipo, data_vencimento, valor_parcela)\r\n        VALUES (NEW.id, 'Saldo Remanescente (Financiamento)', 'Financiamento', primeira_data_obra + (INTERVAL '1 month' * config_venda.num_parcelas_obra), valor_remanescente);\r\n    END IF;\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_auditoria_folha",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_auditoria_folha(p_organizacao_id bigint, p_data_inicio text, p_data_fim text)\n RETURNS TABLE(out_funcionario_id bigint, out_nome text, out_cargo text, out_modelo_contratacao text, out_salario_base numeric, out_valor_diaria numeric, out_dias_uteis_previstos numeric, out_dias_trabalhados_reais numeric, out_dias_faltas numeric, out_dias_abonados numeric, out_dias_extras numeric, out_horas_previstas text, out_horas_trabalhadas text, out_horas_extras text, out_custo_previsto numeric, out_observacao text)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_inicio date := to_date(p_data_inicio, 'YYYY-MM-DD');\r\n  v_fim date := to_date(p_data_fim, 'YYYY-MM-DD');\r\n  \r\n  r_func record;\r\n  v_inicio_efetivo date;\r\n  v_fim_efetivo date;\r\n  v_dia_loop date;\r\n  v_dow int;\r\n  \r\n  -- Vari√°veis de Jornada e Ponto\r\n  v_jornada_ent time;\r\n  v_jornada_sai time;\r\n  v_jornada_sai_int time;\r\n  v_jornada_vol_int time;\r\n  v_minutos_dia_previsto numeric;\r\n  \r\n  v_pt_ent timestamp;\r\n  v_pt_sai timestamp;\r\n  v_pt_ini_int timestamp;\r\n  v_pt_fim_int timestamp;\r\n  v_minutos_dia_trabalhado numeric;\r\n  \r\n  v_eh_feriado boolean;\r\n  v_tipo_feriado text;\r\n  v_tem_jornada boolean;\r\n  v_bateu_ponto boolean;\r\n  v_tem_abono boolean;\r\n  \r\n  -- Acumuladores\r\n  v_acc_dias_previstos numeric;\r\n  v_acc_dias_trabalhados numeric;\r\n  v_acc_dias_faltas numeric;\r\n  v_acc_dias_abonos numeric;\r\n  v_acc_dias_extras numeric;         -- Novo Acumulador\r\n  v_acc_minutos_previstos numeric;\r\n  v_acc_minutos_trabalhados numeric;\r\n  v_acc_minutos_extras numeric;      -- Novo Acumulador\r\n  v_acc_custo numeric;\r\n  \r\n  v_obs text;\r\n  v_modelo text;\r\n  v_valor_dia_base numeric;\r\n  v_custo_extra numeric;\r\n\r\nBEGIN\r\n  FOR r_func IN\r\n    SELECT \r\n      f.id, \r\n      f.full_name,\r\n      COALESCE(c.nome, 'Cargo n√£o definido') as cargo_nome,\r\n      f.admission_date, \r\n      f.demission_date,\r\n      f.jornada_id,\r\n      h.salario_base, \r\n      h.valor_diaria\r\n    FROM funcionarios f\r\n    LEFT JOIN cargos c ON f.cargo_id = c.id\r\n    LEFT JOIN LATERAL (\r\n      SELECT hs.salario_base, hs.valor_diaria \r\n      FROM historico_salarial hs \r\n      WHERE hs.funcionario_id = f.id \r\n      ORDER BY hs.data_inicio_vigencia DESC LIMIT 1\r\n    ) h ON true\r\n    WHERE f.organizacao_id = p_organizacao_id\r\n      AND f.status = 'Ativo'\r\n      AND (f.demission_date IS NULL OR f.demission_date >= v_inicio)\r\n      AND (f.admission_date <= v_fim::text)\r\n    ORDER BY f.full_name\r\n  LOOP\r\n    \r\n    -- Reset dos acumuladores\r\n    v_acc_dias_previstos := 0;\r\n    v_acc_dias_trabalhados := 0;\r\n    v_acc_dias_faltas := 0;\r\n    v_acc_dias_abonos := 0;\r\n    v_acc_dias_extras := 0;\r\n    v_acc_minutos_previstos := 0;\r\n    v_acc_minutos_trabalhados := 0;\r\n    v_acc_minutos_extras := 0;\r\n    v_obs := '';\r\n\r\n    v_inicio_efetivo := GREATEST(v_inicio, r_func.admission_date::date);\r\n    IF r_func.demission_date IS NOT NULL THEN\r\n       v_fim_efetivo := LEAST(v_fim, r_func.demission_date::date);\r\n    ELSE\r\n       v_fim_efetivo := v_fim;\r\n    END IF;\r\n\r\n    if v_inicio_efetivo > v_inicio THEN v_obs := v_obs || 'Admiss√£o recente. '; END IF;\r\n    if v_fim_efetivo < v_fim THEN v_obs := v_obs || 'Desligamento. '; END IF;\r\n\r\n    -- === LOOP DOS DIAS ===\r\n    v_dia_loop := v_inicio_efetivo;\r\n    \r\n    WHILE v_dia_loop <= v_fim_efetivo LOOP\r\n      v_dow := EXTRACT(DOW FROM v_dia_loop); \r\n      v_minutos_dia_previsto := 0;\r\n      v_minutos_dia_trabalhado := 0;\r\n      \r\n      -- 1. Verifica Feriado\r\n      SELECT tipo INTO v_tipo_feriado FROM feriados WHERE organizacao_id = p_organizacao_id AND data_feriado = v_dia_loop;\r\n      \r\n      -- 2. Verifica Jornada Prevista\r\n      SELECT horario_entrada, horario_saida, horario_saida_intervalo, horario_volta_intervalo \r\n      INTO v_jornada_ent, v_jornada_sai, v_jornada_sai_int, v_jornada_vol_int\r\n      FROM jornada_detalhes \r\n      WHERE jornada_id = r_func.jornada_id AND dia_semana = v_dow;\r\n      \r\n      v_tem_jornada := (v_jornada_ent IS NOT NULL);\r\n\r\n      -- 3. Busca Ponto do Dia\r\n      SELECT \r\n         MAX(CASE WHEN tipo_registro = 'Entrada' THEN data_hora END),\r\n         MAX(CASE WHEN tipo_registro = 'Saida' THEN data_hora END),\r\n         MAX(CASE WHEN tipo_registro = 'Inicio_Intervalo' THEN data_hora END),\r\n         MAX(CASE WHEN tipo_registro = 'Fim_Intervalo' THEN data_hora END)\r\n      INTO v_pt_ent, v_pt_sai, v_pt_ini_int, v_pt_fim_int\r\n      FROM pontos p\r\n      WHERE p.funcionario_id = r_func.id AND p.data_hora::date = v_dia_loop;\r\n\r\n      v_bateu_ponto := (v_pt_ent IS NOT NULL);\r\n\r\n      -- 4. Calcula Minutos Trabalhados (Se houver ponto)\r\n      IF v_bateu_ponto THEN\r\n         -- Manh√£\r\n         IF v_pt_ent IS NOT NULL THEN\r\n            IF v_pt_ini_int IS NOT NULL THEN\r\n               v_minutos_dia_trabalhado := v_minutos_dia_trabalhado + (EXTRACT(EPOCH FROM (v_pt_ini_int - v_pt_ent)) / 60);\r\n            ELSIF v_pt_sai IS NOT NULL AND v_pt_fim_int IS NULL THEN\r\n               v_minutos_dia_trabalhado := v_minutos_dia_trabalhado + (EXTRACT(EPOCH FROM (v_pt_sai - v_pt_ent)) / 60);\r\n            END IF;\r\n         END IF;\r\n         -- Tarde\r\n         IF v_pt_fim_int IS NOT NULL AND v_pt_sai IS NOT NULL THEN\r\n             v_minutos_dia_trabalhado := v_minutos_dia_trabalhado + (EXTRACT(EPOCH FROM (v_pt_sai - v_pt_fim_int)) / 60);\r\n         END IF;\r\n         IF v_minutos_dia_trabalhado < 0 THEN v_minutos_dia_trabalhado := 0; END IF;\r\n      END IF;\r\n\r\n      -- === CEN√ÅRIO A: DIA NORMAL DE TRABALHO ===\r\n      IF v_tem_jornada AND (v_tipo_feriado IS DISTINCT FROM 'Integral') THEN\r\n         \r\n         -- Calcula Minutos Previstos\r\n         v_minutos_dia_previsto := (EXTRACT(EPOCH FROM (v_jornada_sai - v_jornada_ent)) / 60);\r\n         IF v_jornada_vol_int IS NOT NULL AND v_jornada_sai_int IS NOT NULL THEN\r\n            v_minutos_dia_previsto := v_minutos_dia_previsto - (EXTRACT(EPOCH FROM (v_jornada_vol_int - v_jornada_sai_int)) / 60);\r\n         END IF;\r\n\r\n         -- Ajuste Meio Per√≠odo\r\n         IF v_tipo_feriado = 'Meio Per√≠odo' THEN \r\n            v_acc_dias_previstos := v_acc_dias_previstos + 0.5;\r\n            v_minutos_dia_previsto := v_minutos_dia_previsto / 2;\r\n         ELSE\r\n            v_acc_dias_previstos := v_acc_dias_previstos + 1;\r\n         END IF;\r\n         v_acc_minutos_previstos := v_acc_minutos_previstos + v_minutos_dia_previsto;\r\n\r\n         -- Verifica Status (Presen√ßa/Falta/Abono)\r\n         SELECT EXISTS(SELECT 1 FROM abonos a WHERE a.funcionario_id = r_func.id AND a.data_abono = v_dia_loop) INTO v_tem_abono;\r\n\r\n         IF v_bateu_ponto THEN\r\n            -- TRABALHOU NORMAL\r\n            IF v_tipo_feriado = 'Meio Per√≠odo' THEN v_acc_dias_trabalhados := v_acc_dias_trabalhados + 0.5;\r\n            ELSE v_acc_dias_trabalhados := v_acc_dias_trabalhados + 1; END IF;\r\n            v_acc_minutos_trabalhados := v_acc_minutos_trabalhados + v_minutos_dia_trabalhado;\r\n         ELSIF v_tem_abono THEN\r\n            -- ABONADO\r\n            IF v_tipo_feriado = 'Meio Per√≠odo' THEN v_acc_dias_abonos := v_acc_dias_abonos + 0.5;\r\n            ELSE v_acc_dias_abonos := v_acc_dias_abonos + 1; END IF;\r\n         ELSE\r\n            -- FALTOU\r\n            IF v_tipo_feriado = 'Meio Per√≠odo' THEN v_acc_dias_faltas := v_acc_dias_faltas + 0.5;\r\n            ELSE v_acc_dias_faltas := v_acc_dias_faltas + 1; END IF;\r\n         END IF;\r\n\r\n      -- === CEN√ÅRIO B: DIA EXTRA (Fora da Jornada ou Feriado) ===\r\n      ELSIF v_bateu_ponto THEN\r\n         -- Trabalhou num dia que n√£o devia (S√°bado, Domingo ou Feriado)\r\n         v_acc_dias_extras := v_acc_dias_extras + 1; -- Conta como 1 dia extra\r\n         v_acc_minutos_extras := v_acc_minutos_extras + v_minutos_dia_trabalhado;\r\n         v_acc_minutos_trabalhados := v_acc_minutos_trabalhados + v_minutos_dia_trabalhado;\r\n      END IF;\r\n\r\n      v_dia_loop := v_dia_loop + 1;\r\n    END LOOP;\r\n\r\n    -- 5. C√ÅLCULO FINANCEIRO FINAL\r\n    v_acc_custo := 0;\r\n    v_valor_dia_base := 0;\r\n\r\n    -- Define o valor do dia base\r\n    IF COALESCE(r_func.valor_diaria, 0) > 0 THEN\r\n       v_modelo := 'Diarista';\r\n       v_valor_dia_base := r_func.valor_diaria;\r\n       \r\n       -- DIARISTA:\r\n       -- Ganha pelos dias trabalhados (Jornada) + Abonos\r\n       v_acc_custo := (v_acc_dias_trabalhados + v_acc_dias_abonos) * v_valor_dia_base;\r\n\r\n    ELSIF COALESCE(r_func.salario_base, 0) > 0 THEN\r\n       v_modelo := 'Mensalista';\r\n       \r\n       DECLARE\r\n         v_dias_contrato int := (v_fim_efetivo - v_inicio_efetivo) + 1;\r\n       BEGIN\r\n         IF v_dias_contrato > 30 THEN v_dias_contrato := 30; END IF;\r\n         v_valor_dia_base := (r_func.salario_base / 30.0);\r\n         \r\n         -- MENSALISTA:\r\n         -- Sal√°rio Proporcional - Desconto de Faltas\r\n         v_acc_custo := (v_dias_contrato * v_valor_dia_base) - (v_acc_dias_faltas * v_valor_dia_base);\r\n       END;\r\n    ELSE\r\n       v_modelo := 'Sem Valor';\r\n    END IF;\r\n\r\n    -- === ADICIONAL DE EXTRAS (1.5x) ===\r\n    -- Independente se √© Mensalista ou Diarista, o dia extra vale 1.5x o dia normal\r\n    v_custo_extra := (v_acc_dias_extras * v_valor_dia_base * 1.5);\r\n    v_acc_custo := v_acc_custo + v_custo_extra;\r\n\r\n    -- Preenche retorno\r\n    out_funcionario_id := r_func.id;\r\n    out_nome := r_func.full_name;\r\n    out_cargo := r_func.cargo_nome;\r\n    out_modelo_contratacao := v_modelo;\r\n    out_salario_base := COALESCE(r_func.salario_base, 0);\r\n    out_valor_diaria := COALESCE(r_func.valor_diaria, 0);\r\n    \r\n    out_dias_uteis_previstos := v_acc_dias_previstos;\r\n    out_dias_trabalhados_reais := v_acc_dias_trabalhados;\r\n    out_dias_faltas := v_acc_dias_faltas;\r\n    out_dias_abonados := v_acc_dias_abonos;\r\n    out_dias_extras := v_acc_dias_extras;  -- Retorna os dias extras\r\n    \r\n    out_horas_previstas := TO_CHAR((v_acc_minutos_previstos || ' minutes')::interval, 'HH24:MI');\r\n    out_horas_trabalhadas := TO_CHAR((v_acc_minutos_trabalhados || ' minutes')::interval, 'HH24:MI');\r\n    out_horas_extras := TO_CHAR((v_acc_minutos_extras || ' minutes')::interval, 'HH24:MI');\r\n    \r\n    out_custo_previsto := ROUND(GREATEST(v_acc_custo, 0), 2);\r\n    out_observacao := TRIM(v_obs);\r\n    \r\n    RETURN NEXT;\r\n  END LOOP;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_broadcast_stats",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_broadcast_stats(p_broadcast_id bigint)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    total_msgs integer;\r\n    sent_msgs integer;\r\n    delivered_msgs integer;\r\n    read_msgs integer;\r\n    failed_msgs integer;\r\nBEGIN\r\n    -- Conta mensagens vinculadas a este disparo\r\n    SELECT \r\n        COUNT(*),\r\n        COUNT(*) FILTER (WHERE status = 'sent'),\r\n        COUNT(*) FILTER (WHERE status = 'delivered' OR status = 'read'), -- Entregue inclui Lida\r\n        COUNT(*) FILTER (WHERE status = 'read'),\r\n        COUNT(*) FILTER (WHERE status = 'failed')\r\n    INTO \r\n        total_msgs,\r\n        sent_msgs,\r\n        delivered_msgs,\r\n        read_msgs,\r\n        failed_msgs\r\n    FROM whatsapp_messages\r\n    WHERE broadcast_id = p_broadcast_id;\r\n\r\n    -- Retorna um JSON bonitinho\r\n    RETURN json_build_object(\r\n        'total', total_msgs,\r\n        'sent', sent_msgs,\r\n        'delivered', delivered_msgs,\r\n        'read', read_msgs,\r\n        'failed', failed_msgs\r\n    );\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_clientes_com_contrato",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_clientes_com_contrato(p_organizacao_id bigint)\n RETURNS TABLE(id bigint, nome text, razao_social text)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT DISTINCT\r\n        c.id,\r\n        c.nome,\r\n        c.razao_social\r\n    FROM\r\n        public.contatos c\r\n    JOIN\r\n        public.contratos co ON c.id = co.contato_id\r\n    WHERE\r\n        c.organizacao_id = p_organizacao_id\r\n        AND co.organizacao_id = p_organizacao_id;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_contact_id_by_phone",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_contact_id_by_phone(p_phone_number text)\n RETURNS TABLE(found_contact_id bigint, found_empresa_id bigint)\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nDECLARE\r\n    v_cleaned_phone TEXT;\r\n    v_possible_phones TEXT[];\r\nBEGIN\r\n    -- 1. Limpa o n√∫mero, removendo tudo o que n√£o for d√≠gito\r\n    v_cleaned_phone := regexp_replace(p_phone_number, '\\D', '', 'g');\r\n\r\n    -- 2. Gera as poss√≠veis varia√ß√µes do n√∫mero de telem√≥vel brasileiro\r\n    -- Formato com 13 d√≠gitos (Ex: 5533999998888) -> cria a varia√ß√£o sem o 9\r\n    IF LENGTH(v_cleaned_phone) = 13 AND v_cleaned_phone LIKE '55__9%' THEN\r\n        v_possible_phones := ARRAY[\r\n            v_cleaned_phone,\r\n            '55' || SUBSTRING(v_cleaned_phone, 3, 2) || SUBSTRING(v_cleaned_phone, 6)\r\n        ];\r\n    -- Formato com 12 d√≠gitos (Ex: 553332715757, mas que seja telem√≥vel) -> cria a varia√ß√£o com o 9\r\n    ELSIF LENGTH(v_cleaned_phone) = 12 AND v_cleaned_phone LIKE '55__%' THEN\r\n        v_possible_phones := ARRAY[\r\n            v_cleaned_phone,\r\n            '55' || SUBSTRING(v_cleaned_phone, 3, 2) || '9' || SUBSTRING(v_cleaned_phone, 5)\r\n        ];\r\n    ELSE\r\n        -- Para todos os outros casos (n√∫meros fixos, internacionais), usa apenas o n√∫mero limpo\r\n        v_possible_phones := ARRAY[v_cleaned_phone];\r\n    END IF;\r\n\r\n    -- 3. Busca na tabela de telefones usando as varia√ß√µes poss√≠veis\r\n    RETURN QUERY\r\n    SELECT\r\n        t.contato_id,\r\n        c.empresa_id\r\n    FROM public.telefones AS t\r\n    JOIN public.contatos AS c ON t.contato_id = c.id\r\n    WHERE regexp_replace(t.telefone, '\\D', '', 'g') = ANY(v_possible_phones)\r\n    ORDER BY LENGTH(regexp_replace(t.telefone, '\\D', '', 'g')) DESC\r\n    LIMIT 1;\r\n\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_conversations_with_details",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_conversations_with_details()\n RETURNS TABLE(contato_id bigint, nome_contato text, foto_url text, ultima_mensagem_conteudo text, ultima_mensagem_em timestamp with time zone, nao_lidas bigint)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nBEGIN\r\n    -- Esta verifica√ß√£o garante que apenas usu√°rios logados possam executar a fun√ß√£o.\r\n    IF auth.role() <> 'authenticated' THEN\r\n        RAISE EXCEPTION 'Acesso n√£o autorizado.';\r\n    END IF;\r\n\r\n    RETURN QUERY\r\n    -- Este bloco de c√≥digo encontra a mensagem mais recente de cada conversa.\r\n    WITH latest_messages AS (\r\n        SELECT\r\n            m.contato_id,\r\n            m.content,\r\n            m.sent_at,\r\n            ROW_NUMBER() OVER(PARTITION BY m.contato_id ORDER BY m.sent_at DESC) as rn\r\n        FROM\r\n            whatsapp_messages m\r\n        WHERE m.contato_id IS NOT NULL\r\n    )\r\n    -- E aqui, juntamos a mensagem mais recente com as informa√ß√µes do contato.\r\n    SELECT\r\n        c.id as contato_id,\r\n        c.nome as nome_contato,\r\n        c.foto_url,\r\n        lm.content as ultima_mensagem_conteudo,\r\n        lm.sent_at as ultima_mensagem_em,\r\n        -- A contagem de mensagens n√£o lidas pode ser implementada aqui no futuro.\r\n        0::bigint as nao_lidas\r\n    FROM\r\n        latest_messages lm\r\n    JOIN\r\n        contatos c ON lm.contato_id = c.id\r\n    WHERE\r\n        lm.rn = 1\r\n    ORDER BY\r\n        lm.sent_at DESC;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_conversations_with_unread_count",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_conversations_with_unread_count()\n RETURNS TABLE(contato_id bigint, nome text, last_message text, last_message_sent_at timestamp with time zone, unread_count bigint)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    WITH latest_messages AS (\r\n        SELECT\r\n            wm.contato_id,\r\n            ROW_NUMBER() OVER(PARTITION BY wm.contato_id ORDER BY wm.sent_at DESC) as rn,\r\n            wm.content,\r\n            wm.sent_at\r\n        FROM\r\n            whatsapp_messages wm\r\n    ),\r\n    unread_counts AS (\r\n        SELECT\r\n            wm.contato_id,\r\n            COUNT(*) as unread\r\n        FROM\r\n            whatsapp_messages wm\r\n        WHERE\r\n            wm.is_read = false\r\n        GROUP BY\r\n            wm.contato_id\r\n    )\r\n    SELECT\r\n        c.id as contato_id,\r\n        c.nome,\r\n        lm.content as last_message,\r\n        lm.sent_at as last_message_sent_at,\r\n        COALESCE(uc.unread, 0) as unread_count\r\n    FROM\r\n        contatos c\r\n    JOIN\r\n        latest_messages lm ON c.id = lm.contato_id AND lm.rn = 1\r\n    LEFT JOIN\r\n        unread_counts uc ON c.id = uc.contato_id\r\n    ORDER BY\r\n        lm.sent_at DESC;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_conversations_with_unread_count",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_conversations_with_unread_count(p_organizacao_id bigint)\n RETURNS TABLE(contato_id bigint, nome text, last_message text, last_message_sent_at timestamp with time zone, unread_count bigint)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    WITH latest_messages AS (\r\n        SELECT\r\n            wm.contato_id,\r\n            ROW_NUMBER() OVER(PARTITION BY wm.contato_id ORDER BY wm.sent_at DESC) as rn,\r\n            wm.content,\r\n            wm.sent_at\r\n        FROM\r\n            public.whatsapp_messages wm\r\n        WHERE\r\n            wm.organizacao_id = p_organizacao_id AND wm.contato_id IS NOT NULL\r\n    ),\r\n    unread_counts AS (\r\n        SELECT\r\n            wm.contato_id,\r\n            COUNT(*) as unread\r\n        FROM\r\n            public.whatsapp_messages wm\r\n        WHERE\r\n            wm.is_read = false AND wm.organizacao_id = p_organizacao_id AND wm.direction = 'inbound' AND wm.contato_id IS NOT NULL\r\n        GROUP BY\r\n            wm.contato_id\r\n    )\r\n    SELECT\r\n        c.id as contato_id,\r\n        c.nome,\r\n        lm.content as last_message,\r\n        lm.sent_at as last_message_sent_at,\r\n        COALESCE(uc.unread, 0) as unread_count\r\n    FROM\r\n        public.contatos c\r\n    JOIN\r\n        latest_messages lm ON c.id = lm.contato_id AND lm.rn = 1\r\n    LEFT JOIN\r\n        unread_counts uc ON c.id = uc.contato_id\r\n    WHERE\r\n        c.organizacao_id = p_organizacao_id\r\n    ORDER BY\r\n        lm.sent_at DESC;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_corporate_entities",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_corporate_entities()\n RETURNS TABLE(id bigint, display_name text, cnpj text)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT\r\n        c.id,\r\n        -- Prioriza nome_fantasia, depois razao_social, depois nome (se cnpj existir)\r\n        COALESCE(c.nome_fantasia, c.razao_social, c.nome) as display_name,\r\n        c.cnpj\r\n    FROM\r\n        public.contatos c\r\n    WHERE\r\n        c.cnpj IS NOT NULL; -- Apenas contatos que se comportam como PJ\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_corretores_com_contrato",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_corretores_com_contrato(p_organizacao_id bigint)\n RETURNS TABLE(id bigint, nome text, razao_social text)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT DISTINCT\r\n        c.id,\r\n        c.nome,\r\n        c.razao_social\r\n    FROM\r\n        public.contatos c\r\n    JOIN\r\n        public.contratos co ON c.id = co.corretor_id\r\n    WHERE\r\n        c.organizacao_id = p_organizacao_id\r\n        AND co.organizacao_id = p_organizacao_id\r\n        AND co.corretor_id IS NOT NULL;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_crm_filter_options_v2",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_crm_filter_options_v2(p_organizacao_id bigint)\n RETURNS json\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    result json;\r\nBEGIN\r\n    WITH contatos_ids_no_funil AS (\r\n        -- Primeiro, pegamos apenas os IDs dos contatos que est√£o no funil. Esta √© a nossa base.\r\n        SELECT DISTINCT contato_id FROM public.contatos_no_funil WHERE organizacao_id = p_organizacao_id\r\n    )\r\n    SELECT json_build_object(\r\n        'corretores', (\r\n            SELECT COALESCE(json_agg(json_build_object('id', c.id, 'nome', COALESCE(c.nome, c.razao_social)) ORDER BY COALESCE(c.nome, c.razao_social)), '[]'::json)\r\n            FROM public.contatos c\r\n            WHERE c.id IN (SELECT DISTINCT corretor_id FROM public.contatos_no_funil WHERE organizacao_id = p_organizacao_id AND corretor_id IS NOT NULL)\r\n        ),\r\n        'origens', (\r\n            SELECT COALESCE(json_agg(json_build_object('id', o.origem, 'nome', o.origem)), '[]'::json)\r\n            FROM (\r\n                SELECT DISTINCT c.origem FROM public.contatos c JOIN contatos_ids_no_funil f ON c.id = f.contato_id WHERE c.origem IS NOT NULL ORDER BY c.origem\r\n            ) o\r\n        ),\r\n        'unidades', ( -- Unidades n√£o dependem do contato, ent√£o a busca √© direta e r√°pida.\r\n            SELECT COALESCE(json_agg(json_build_object('id', id, 'nome', unidade) ORDER BY unidade), '[]'::json)\r\n            FROM public.produtos_empreendimento WHERE organizacao_id = p_organizacao_id\r\n        ),\r\n        'campaigns', (\r\n            SELECT COALESCE(json_agg(json_build_object('id', mc.id, 'nome', mc.name) ORDER BY mc.name), '[]'::json)\r\n            FROM public.meta_campaigns mc\r\n            WHERE mc.id IN (SELECT DISTINCT c.meta_campaign_id FROM public.contatos c JOIN contatos_ids_no_funil f ON c.id = f.contato_id WHERE c.meta_campaign_id IS NOT NULL)\r\n        ),\r\n        'ads', (\r\n            SELECT COALESCE(json_agg(json_build_object('id', ma.id, 'nome', ma.name) ORDER BY ma.name), '[]'::json)\r\n            FROM public.meta_ads ma\r\n            WHERE ma.id IN (SELECT DISTINCT c.meta_ad_id FROM public.contatos c JOIN contatos_ids_no_funil f ON c.id = f.contato_id WHERE c.meta_ad_id IS NOT NULL)\r\n        )\r\n    ) INTO result;\r\n\r\n    RETURN result;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_current_user_organizacao_id",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_current_user_organizacao_id()\n RETURNS bigint\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    org_id BIGINT;\r\nBEGIN\r\n    SELECT COALESCE(\r\n        (SELECT organizacao_id FROM public.usuarios WHERE id = auth.uid()),\r\n        (SELECT (auth.jwt()->>'user_metadata')::jsonb->>'organizacao_id')::BIGINT\r\n    ) INTO org_id;\r\n    RETURN org_id;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_dados_grafico_kpi",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_dados_grafico_kpi(p_organizacao_id bigint, p_filtros jsonb)\n RETURNS TABLE(data_ref text, receita numeric, despesa numeric)\n LANGUAGE plpgsql\nAS $function$\r\ndeclare\r\n  v_where text;\r\n  v_use_competencia boolean;\r\nbegin\r\n  -- Pega o filtro montado pelo C√©rebro Central (j√° blindado)\r\n  v_where := financeiro_montar_where(p_organizacao_id, p_filtros);\r\n  v_use_competencia := coalesce((p_filtros->>'useCompetencia')::boolean, false);\r\n\r\n  return query execute '\r\n    select \r\n      to_char(\r\n        CASE \r\n          WHEN ' || v_use_competencia || ' THEN coalesce(l.mes_competencia, l.data_transacao)\r\n          ELSE coalesce(l.data_pagamento, l.data_vencimento) \r\n        END, \r\n        ''YYYY-MM-DD''\r\n      ) as data_ref,\r\n      coalesce(sum(case when l.tipo = ''Receita'' then l.valor else 0 end), 0) as receita,\r\n      coalesce(sum(case when l.tipo = ''Despesa'' then l.valor else 0 end), 0) as despesa\r\n    from lancamentos l\r\n    ' || v_where || '\r\n    group by 1\r\n    order by 1\r\n  ';\r\nend;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_dashboard_auditoria_kanban",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_dashboard_auditoria_kanban(p_organizacao_id bigint, p_filtros jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_where text;\r\n  v_result jsonb;\r\nBEGIN\r\n  -- 1. O C√©rebro: Usa a fun√ß√£o central para montar o filtro (Lei de Fernanda)\r\n  v_where := financeiro_montar_where(p_organizacao_id, p_filtros);\r\n\r\n  -- 2. Executa a query din√¢mica\r\n  EXECUTE '\r\n    WITH dados_brutos AS (\r\n      SELECT \r\n        l.*,\r\n        \r\n        -- AQUI: Calculamos a data efetiva APENAS PARA EXIBI√á√ÉO\r\n        -- (A filtragem j√° foi feita pelo v_where abaixo)\r\n        CASE \r\n            WHEN l.data_pagamento IS NOT NULL THEN l.data_pagamento \r\n            WHEN l.data_vencimento IS NOT NULL THEN l.data_vencimento \r\n            ELSE l.data_transacao \r\n        END as data_efetiva,\r\n\r\n        (select jsonb_build_object(''id'', c.id, ''nome'', c.nome) from contas_financeiras c where c.id = l.conta_id) as conta,\r\n        (select jsonb_build_object(''id'', cat.id, ''nome'', cat.nome) from categorias_financeiras cat where cat.id = l.categoria_id) as categoria,\r\n        (select jsonb_build_object(''id'', fav.id, ''nome'', fav.nome, ''razao_social'', fav.razao_social) from contatos fav where fav.id = l.favorecido_contato_id) as favorecido,\r\n        \r\n        -- Verifica se tem anexos\r\n        EXISTS(SELECT 1 FROM lancamentos_anexos an WHERE an.lancamento_id = l.id) as tem_anexo,\r\n        \r\n        -- Traz os anexos\r\n        (select json_agg(jsonb_build_object(''id'', an.id, ''caminho_arquivo'', an.caminho_arquivo, ''nome_arquivo'', an.nome_arquivo)) from lancamentos_anexos an where an.lancamento_id = l.id) as anexos_detalhes\r\n      FROM lancamentos l\r\n      ' || v_where || '\r\n    )\r\n    SELECT jsonb_build_object(\r\n      ''sem_anexo'', COALESCE(jsonb_agg(d.*) FILTER (WHERE d.tipo = ''Despesa'' AND d.tem_anexo = false AND d.status_auditoria_ia NOT IN (''Aprovado'')), ''[]''::jsonb),\r\n      ''fila_ia'', COALESCE(jsonb_agg(d.*) FILTER (WHERE d.tem_anexo = true AND d.status_auditoria_ia IN (''Nao Auditado'', ''Pendente'')), ''[]''::jsonb),\r\n      ''divergente'', COALESCE(jsonb_agg(d.*) FILTER (WHERE d.status_auditoria_ia IN (''Divergente'', ''Erro'')), ''[]''::jsonb),\r\n      ''aprovado'', COALESCE(jsonb_agg(d.*) FILTER (WHERE d.status_auditoria_ia = ''Aprovado''), ''[]''::jsonb)\r\n    )\r\n    FROM dados_brutos d;\r\n  ' INTO v_result;\r\n\r\n  RETURN v_result;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_dias_ferias_gozados_ano",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_dias_ferias_gozados_ano(p_funcionario_id bigint, p_ano integer)\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    total_dias integer;\r\nBEGIN\r\n    SELECT COUNT(a.id)\r\n    INTO total_dias\r\n    FROM public.abonos a\r\n    JOIN public.abono_tipos at ON a.tipo_abono_id = at.id\r\n    WHERE a.funcionario_id = p_funcionario_id\r\n      AND at.descricao = 'F√©rias'\r\n      AND EXTRACT(YEAR FROM a.data_abono) = p_ano;\r\n\r\n    RETURN COALESCE(total_dias, 0);\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_duplicate_contatos",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_duplicate_contatos()\n RETURNS TABLE(duplicate_type text, duplicate_key text, contato_details json)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    WITH potential_duplicates AS (\r\n        -- Duplicatas por CPF\r\n        SELECT 'CPF' as type, cpf as key, id FROM contatos WHERE cpf IS NOT NULL AND cpf <> ''\r\n        UNION ALL\r\n        -- Duplicatas por CNPJ\r\n        SELECT 'CNPJ' as type, cnpj as key, id FROM contatos WHERE cnpj IS NOT NULL AND cnpj <> ''\r\n        UNION ALL\r\n        -- Duplicatas por Nome\r\n        SELECT 'Nome' as type, nome as key, id FROM contatos WHERE nome IS NOT NULL AND nome <> ''\r\n    ),\r\n    grouped_duplicates AS (\r\n        SELECT key, type, array_agg(id) as ids\r\n        FROM potential_duplicates\r\n        GROUP BY key, type\r\n        HAVING count(id) > 1\r\n    )\r\n    SELECT\r\n        gd.type,\r\n        gd.key,\r\n        json_build_object(\r\n            'id', c.id,\r\n            'nome', c.nome,\r\n            'tipo_contato', c.tipo_contato,\r\n            'cpf', c.cpf,\r\n            'cnpj', c.cnpj,\r\n            'telefones', (SELECT json_agg(t.telefone) FROM telefones t WHERE t.contato_id = c.id),\r\n            'emails', (SELECT json_agg(e.email) FROM emails e WHERE e.contato_id = c.id)\r\n        )\r\n    FROM grouped_duplicates gd\r\n    JOIN contatos c ON c.id = ANY(gd.ids)\r\n    ORDER BY gd.key, c.nome;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_empreendimentos_com_anexos_corretor",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_empreendimentos_com_anexos_corretor(org_id bigint)\n RETURNS TABLE(id bigint, nome text)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT DISTINCT\r\n    e.id,\r\n    e.nome\r\n  FROM\r\n    public.empreendimentos e\r\n  JOIN\r\n    public.empreendimento_anexos ea ON e.id = ea.empreendimento_id\r\n  WHERE\r\n    ea.organizacao_id = org_id AND\r\n    ea.disponivel_corretor = true\r\n  ORDER BY\r\n    e.nome;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_extrato_por_conta",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_extrato_por_conta(conta_id_param integer, data_inicio_param date, data_fim_param date)\n RETURNS TABLE(data date, descricao text, valor numeric, saldo numeric)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    saldo_inicial NUMERIC;\r\nBEGIN\r\n    -- 1. Calcular o Saldo Inicial\r\n    -- Soma o saldo inicial da conta com todos os lan√ßamentos ANTES da data de in√≠cio.\r\n    SELECT\r\n        COALESCE(cf.saldo_inicial, 0) + \r\n        COALESCE(SUM(\r\n            CASE\r\n                WHEN l.tipo = 'receita' THEN l.valor\r\n                WHEN l.tipo = 'despesa' THEN -l.valor\r\n                ELSE 0\r\n            END\r\n        ), 0)\r\n    INTO saldo_inicial\r\n    FROM contas_financeiras cf\r\n    LEFT JOIN lancamentos l ON cf.id = l.conta_id\r\n    WHERE cf.id = conta_id_param AND l.data_transacao < data_inicio_param;\r\n\r\n    -- Se n√£o houver lan√ßamentos anteriores, o saldo inicial √© apenas o da conta.\r\n    IF saldo_inicial IS NULL THEN\r\n        SELECT COALESCE(cf.saldo_inicial, 0)\r\n        INTO saldo_inicial\r\n        FROM contas_financeiras cf\r\n        WHERE cf.id = conta_id_param;\r\n    END IF;\r\n\r\n\r\n    -- 2. Retornar a tabela do extrato\r\n    -- Cria uma linha \"virtual\" para o saldo inicial e une com os lan√ßamentos do per√≠odo.\r\n    RETURN QUERY\r\n    WITH lancamentos_periodo AS (\r\n        SELECT\r\n            l.data_transacao,\r\n            l.descricao,\r\n            CASE\r\n                WHEN l.tipo = 'receita' THEN l.valor\r\n                ELSE -l.valor\r\n            END AS valor_calculado\r\n        FROM lancamentos l\r\n        WHERE l.conta_id = conta_id_param\r\n        AND l.data_transacao >= data_inicio_param\r\n        AND l.data_transacao <= data_fim_param\r\n    ),\r\n    extrato_com_saldo_inicial AS (\r\n        SELECT \r\n            (data_inicio_param - INTERVAL '1 day')::DATE AS data,\r\n            'Saldo Inicial' AS descricao,\r\n            saldo_inicial AS valor,\r\n            saldo_inicial AS saldo\r\n        UNION ALL\r\n        SELECT\r\n            lp.data_transacao,\r\n            lp.descricao,\r\n            lp.valor_calculado,\r\n            0 -- Saldo ser√° calculado na pr√≥xima etapa\r\n        FROM lancamentos_periodo lp\r\n    )\r\n    SELECT\r\n        s.data,\r\n        s.descricao,\r\n        s.valor,\r\n        -- Calcula a soma acumulada (saldo corrente)\r\n        SUM(s.valor) OVER (ORDER BY s.data, (CASE WHEN s.descricao = 'Saldo Inicial' THEN 0 ELSE 1 END))::NUMERIC AS saldo\r\n    FROM extrato_com_saldo_inicial s\r\n    ORDER BY s.data, (CASE WHEN s.descricao = 'Saldo Inicial' THEN 0 ELSE 1 END);\r\n\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_financeiro_consolidado",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_financeiro_consolidado(p_organizacao_id bigint, p_filtros jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\ndeclare\r\n  v_where text;\r\n  v_result jsonb;\r\nbegin\r\n  v_where := financeiro_montar_where(p_organizacao_id, p_filtros);\r\n\r\n  execute '\r\n    select jsonb_build_object(\r\n      ''totalReceitas'', coalesce(sum(case when tipo = ''Receita'' then valor else 0 end), 0),\r\n      ''totalDespesas'', coalesce(sum(case when tipo = ''Despesa'' then valor else 0 end), 0),\r\n      ''resultado'', coalesce(sum(case when tipo = ''Receita'' then valor else -valor end), 0),\r\n      ''totalPago'', coalesce(sum(case when status in (''Pago'', ''Conciliado'') then (case when tipo = ''Receita'' then valor else -valor end) else 0 end), 0),\r\n      ''totalPendente'', coalesce(sum(case when status = ''Pendente'' then (case when tipo = ''Receita'' then valor else -valor end) else 0 end), 0)\r\n    )\r\n    from lancamentos l\r\n    ' || v_where \r\n  into v_result;\r\n\r\n  return v_result;\r\nend;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_financeiro_dashboard",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_financeiro_dashboard(p_organizacao_id bigint, p_data_inicio date, p_data_fim date)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n    v_kpis jsonb;\r\n    v_grafico_fluxo jsonb;\r\n    v_grafico_pizza jsonb;\r\n    v_retorno jsonb;\r\nBEGIN\r\n    -- 1. CALCULAR KPIs (Totais do Per√≠odo - Isso continua igual)\r\n    SELECT jsonb_build_object(\r\n        'receita', COALESCE(SUM(CASE WHEN tipo = 'Receita' THEN valor ELSE 0 END), 0),\r\n        'despesa', COALESCE(SUM(CASE WHEN tipo = 'Despesa' THEN valor ELSE 0 END), 0),\r\n        'saldo',   COALESCE(SUM(CASE WHEN tipo = 'Receita' THEN valor ELSE -valor END), 0)\r\n    ) INTO v_kpis\r\n    FROM lancamentos\r\n    WHERE organizacao_id = p_organizacao_id\r\n      AND COALESCE(data_pagamento, data_transacao, data_vencimento) >= p_data_inicio \r\n      AND COALESCE(data_pagamento, data_transacao, data_vencimento) <= p_data_fim\r\n      AND status IN ('Pago', 'Conciliado', 'Pendente', 'Agendado');\r\n\r\n    -- 2. DADOS PARA O GR√ÅFICO DE FLUXO (AGORA POR DIA! üìÖ)\r\n    SELECT jsonb_agg(t) INTO v_grafico_fluxo\r\n    FROM (\r\n        SELECT \r\n            -- Nome exibe o Dia/M√™s (Ex: 05/06)\r\n            TO_CHAR(COALESCE(data_pagamento, data_transacao, data_vencimento), 'DD/MM') as name,\r\n            -- Ordena√ß√£o usa a data exata\r\n            COALESCE(data_pagamento, data_transacao, data_vencimento)::date as data_ordem,\r\n            COALESCE(SUM(CASE WHEN tipo = 'Receita' THEN valor ELSE 0 END), 0) as \"Receita\",\r\n            COALESCE(SUM(CASE WHEN tipo = 'Despesa' THEN valor ELSE 0 END), 0) as \"Despesa\"\r\n        FROM lancamentos\r\n        WHERE organizacao_id = p_organizacao_id\r\n          AND COALESCE(data_pagamento, data_transacao, data_vencimento) >= p_data_inicio \r\n          AND COALESCE(data_pagamento, data_transacao, data_vencimento) <= p_data_fim\r\n          AND status IN ('Pago', 'Conciliado', 'Pendente', 'Agendado')\r\n        -- MUDAN√áA AQUI: Agrupa pela data exata, n√£o pelo m√™s truncado\r\n        GROUP BY \r\n            TO_CHAR(COALESCE(data_pagamento, data_transacao, data_vencimento), 'DD/MM'),\r\n            COALESCE(data_pagamento, data_transacao, data_vencimento)::date\r\n        ORDER BY \r\n            COALESCE(data_pagamento, data_transacao, data_vencimento)::date ASC\r\n    ) t;\r\n\r\n    -- 3. DADOS PARA O GR√ÅFICO DE PIZZA (Top Despesas - Continua igual)\r\n    SELECT jsonb_agg(t) INTO v_grafico_pizza\r\n    FROM (\r\n        SELECT \r\n            c.nome as name,\r\n            SUM(l.valor) as value\r\n        FROM lancamentos l\r\n        JOIN categorias_financeiras c ON l.categoria_id = c.id\r\n        WHERE l.organizacao_id = p_organizacao_id\r\n          AND COALESCE(l.data_pagamento, l.data_transacao, l.data_vencimento) >= p_data_inicio \r\n          AND COALESCE(l.data_pagamento, l.data_transacao, l.data_vencimento) <= p_data_fim\r\n          AND l.status IN ('Pago', 'Conciliado', 'Pendente', 'Agendado')\r\n          AND l.tipo = 'Despesa'\r\n        GROUP BY c.nome\r\n        ORDER BY value DESC\r\n        LIMIT 5\r\n    ) t;\r\n\r\n    -- 4. MONTAR O PACOTE FINAL\r\n    v_retorno := jsonb_build_object(\r\n        'kpis', COALESCE(v_kpis, '{\"receita\": 0, \"despesa\": 0, \"saldo\": 0}'::jsonb),\r\n        'graficoFluxo', COALESCE(v_grafico_fluxo, '[]'::jsonb),\r\n        'graficoPizza', COALESCE(v_grafico_pizza, '[]'::jsonb)\r\n    );\r\n\r\n    RETURN v_retorno;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_financeiro_dashboard",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_financeiro_dashboard(p_organizacao_id bigint, p_data_inicio date, p_data_fim date, p_conta_ids bigint[] DEFAULT NULL::bigint[], p_categoria_ids bigint[] DEFAULT NULL::bigint[])\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n    v_kpis jsonb;\r\n    v_grafico_fluxo jsonb;\r\n    v_grafico_pizza jsonb;\r\n    v_retorno jsonb;\r\nBEGIN\r\n    -- 1. CALCULAR KPIs\r\n    SELECT jsonb_build_object(\r\n        'receita', COALESCE(SUM(CASE WHEN tipo = 'Receita' THEN valor ELSE 0 END), 0),\r\n        'despesa', COALESCE(SUM(CASE WHEN tipo = 'Despesa' THEN valor ELSE 0 END), 0),\r\n        'saldo',   COALESCE(SUM(CASE WHEN tipo = 'Receita' THEN valor ELSE -valor END), 0)\r\n    ) INTO v_kpis\r\n    FROM lancamentos\r\n    WHERE organizacao_id = p_organizacao_id\r\n      AND COALESCE(data_pagamento, data_transacao, data_vencimento) >= p_data_inicio \r\n      AND COALESCE(data_pagamento, data_transacao, data_vencimento) <= p_data_fim\r\n      AND status IN ('Pago', 'Conciliado', 'Pendente', 'Agendado')\r\n      -- Filtros Din√¢micos\r\n      AND (p_conta_ids IS NULL OR conta_id = ANY(p_conta_ids))\r\n      AND (p_categoria_ids IS NULL OR categoria_id = ANY(p_categoria_ids));\r\n\r\n    -- 2. DADOS PARA O GR√ÅFICO DE FLUXO (Por Dia)\r\n    SELECT jsonb_agg(t) INTO v_grafico_fluxo\r\n    FROM (\r\n        SELECT \r\n            TO_CHAR(COALESCE(data_pagamento, data_transacao, data_vencimento), 'DD/MM') as name,\r\n            COALESCE(data_pagamento, data_transacao, data_vencimento)::date as data_ordem,\r\n            COALESCE(SUM(CASE WHEN tipo = 'Receita' THEN valor ELSE 0 END), 0) as \"Receita\",\r\n            COALESCE(SUM(CASE WHEN tipo = 'Despesa' THEN valor ELSE 0 END), 0) as \"Despesa\"\r\n        FROM lancamentos\r\n        WHERE organizacao_id = p_organizacao_id\r\n          AND COALESCE(data_pagamento, data_transacao, data_vencimento) >= p_data_inicio \r\n          AND COALESCE(data_pagamento, data_transacao, data_vencimento) <= p_data_fim\r\n          AND status IN ('Pago', 'Conciliado', 'Pendente', 'Agendado')\r\n          -- Filtros Din√¢micos\r\n          AND (p_conta_ids IS NULL OR conta_id = ANY(p_conta_ids))\r\n          AND (p_categoria_ids IS NULL OR categoria_id = ANY(p_categoria_ids))\r\n        GROUP BY \r\n            TO_CHAR(COALESCE(data_pagamento, data_transacao, data_vencimento), 'DD/MM'),\r\n            COALESCE(data_pagamento, data_transacao, data_vencimento)::date\r\n        ORDER BY \r\n            COALESCE(data_pagamento, data_transacao, data_vencimento)::date ASC\r\n    ) t;\r\n\r\n    -- 3. DADOS PARA O GR√ÅFICO DE PIZZA\r\n    SELECT jsonb_agg(t) INTO v_grafico_pizza\r\n    FROM (\r\n        SELECT \r\n            c.nome as name,\r\n            SUM(l.valor) as value\r\n        FROM lancamentos l\r\n        JOIN categorias_financeiras c ON l.categoria_id = c.id\r\n        WHERE l.organizacao_id = p_organizacao_id\r\n          AND COALESCE(l.data_pagamento, l.data_transacao, l.data_vencimento) >= p_data_inicio \r\n          AND COALESCE(l.data_pagamento, l.data_transacao, l.data_vencimento) <= p_data_fim\r\n          AND l.status IN ('Pago', 'Conciliado', 'Pendente', 'Agendado')\r\n          -- Filtros Din√¢micos\r\n          AND (p_conta_ids IS NULL OR conta_id = ANY(p_conta_ids))\r\n          AND (p_categoria_ids IS NULL OR categoria_id = ANY(p_categoria_ids))\r\n          AND l.tipo = 'Despesa'\r\n        GROUP BY c.nome\r\n        ORDER BY value DESC\r\n        LIMIT 5\r\n    ) t;\r\n\r\n    -- 4. RETORNO\r\n    v_retorno := jsonb_build_object(\r\n        'kpis', COALESCE(v_kpis, '{\"receita\": 0, \"despesa\": 0, \"saldo\": 0}'::jsonb),\r\n        'graficoFluxo', COALESCE(v_grafico_fluxo, '[]'::jsonb),\r\n        'graficoPizza', COALESCE(v_grafico_pizza, '[]'::jsonb)\r\n    );\r\n\r\n    RETURN v_retorno;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_financeiro_grafico_pizza",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_financeiro_grafico_pizza(p_organizacao_id bigint, p_filtros jsonb)\n RETURNS TABLE(name text, value numeric)\n LANGUAGE plpgsql\nAS $function$\r\ndeclare\r\n  v_where text;\r\nbegin\r\n  v_where := financeiro_montar_where(p_organizacao_id, p_filtros);\r\n  \r\n  -- Adiciona filtro extra para pegar s√≥ Despesas no gr√°fico de pizza (opcional, mas comum)\r\n  -- Se quiser ver Receitas tamb√©m na pizza dependendo do filtro, remova a linha abaixo.\r\n  -- Mas geralmente pizza mistura tudo fica confuso, ent√£o focamos em onde o dinheiro sai.\r\n  v_where := v_where || ' and l.tipo = ''Despesa'''; \r\n  \r\n  return query execute '\r\n    select \r\n      coalesce(c.nome, ''Sem Categoria'') as name,\r\n      sum(l.valor) as value\r\n    from lancamentos l\r\n    left join categorias_financeiras c on l.categoria_id = c.id\r\n    ' || v_where || '\r\n    group by c.nome\r\n    having sum(l.valor) > 0\r\n    order by value desc\r\n    limit 6\r\n  ';\r\nend;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_funcionarios_com_pendencias_ponto",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_funcionarios_com_pendencias_ponto()\n RETURNS TABLE(id bigint, full_name text)\n LANGUAGE plpgsql\nAS $function$\r\ndeclare\r\n    data_inicio date;\r\n    data_fim date;\r\nbegin\r\n    -- Define o per√≠odo como o m√™s atual, at√© o dia de ontem.\r\n    data_inicio := date_trunc('month', current_date)::date;\r\n    data_fim := (current_date - interval '1 day')::date;\r\n\r\n    -- Se for o primeiro dia do m√™s, n√£o h√° dias anteriores para verificar.\r\n    if data_fim < data_inicio then\r\n        return;\r\n    end if;\r\n\r\n    return query\r\n    with dias_uteis as (\r\n        -- Gera todos os dias do per√≠odo a ser verificado\r\n        select generate_series(data_inicio, data_fim, '1 day'::interval)::date as dia\r\n    ),\r\n    jornadas_dias as (\r\n        -- Mapeia cada funcion√°rio para seus dias de trabalho na semana\r\n        select\r\n            f.id as funcionario_id,\r\n            jd.dia_semana\r\n        from\r\n            public.funcionarios f\r\n            join public.jornadas j on f.jornada_id = j.id\r\n            join public.jornada_detalhes jd on j.id = jd.jornada_id\r\n        where\r\n            f.status = 'Ativo'\r\n            and (jd.horario_entrada is not null and jd.horario_saida is not null)\r\n    ),\r\n    dias_a_trabalhar as (\r\n        -- Filtra os dias √∫teis para cada funcion√°rio com base na sua jornada\r\n        select\r\n            jd.funcionario_id,\r\n            du.dia\r\n        from\r\n            dias_uteis du\r\n            join jornadas_dias jd on extract(isodow from du.dia) = jd.dia_semana\r\n    ),\r\n    pontos_do_dia as (\r\n        -- Agrupa as marca√ß√µes de ponto por funcion√°rio e dia\r\n        select\r\n            p.funcionario_id,\r\n            p.data_hora::date as dia,\r\n            count(case when p.tipo_registro = 'Entrada' then 1 end) > 0 as tem_entrada,\r\n            count(case when p.tipo_registro = 'Saida' then 1 end) > 0 as tem_saida,\r\n            count(case when p.tipo_registro = 'Inicio_Intervalo' then 1 end) > 0 as tem_inicio_intervalo,\r\n            count(case when p.tipo_registro = 'Fim_Intervalo' then 1 end) > 0 as tem_fim_intervalo\r\n        from\r\n            public.pontos p\r\n        where\r\n            p.data_hora::date between data_inicio and data_fim\r\n        group by\r\n            p.funcionario_id, p.data_hora::date\r\n    ),\r\n    abonos_do_dia as (\r\n        select funcionario_id, data_abono from public.abonos where data_abono between data_inicio and data_fim\r\n    )\r\n    -- Seleciona os funcion√°rios que t√™m dias a trabalhar sem as marca√ß√µes completas e sem abono\r\n    select distinct\r\n        f.id,\r\n        f.full_name\r\n    from\r\n        dias_a_trabalhar dat\r\n        join public.funcionarios f on dat.funcionario_id = f.id\r\n        left join pontos_do_dia pd on dat.funcionario_id = pd.funcionario_id and dat.dia = pd.dia\r\n        left join abonos_do_dia ad on dat.funcionario_id = ad.funcionario_id and dat.dia = ad.data_abono\r\n    where\r\n        ad.data_abono is null -- Ignora dias com abono\r\n        and (\r\n            pd.dia is null -- N√£o bateu ponto no dia\r\n            or pd.tem_entrada = false\r\n            or pd.tem_saida = false\r\n            or pd.tem_inicio_intervalo = false\r\n            or pd.tem_fim_intervalo = false\r\n        )\r\n    order by\r\n        f.full_name;\r\n\r\nend;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_inbox_conversations",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_inbox_conversations(p_organizacao_id bigint)\n RETURNS TABLE(id bigint, contato_id bigint, phone_number text, nome text, avatar_url text, unread_count bigint, last_message text, last_message_time timestamp with time zone, message_type text)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  WITH grouped_convs AS (\r\n    SELECT \r\n      COALESCE(wc.contato_id, -wc.id) as group_key,\r\n      MAX(wc.id) as representative_id,\r\n      MAX(wc.updated_at) as last_update\r\n    FROM whatsapp_conversations wc\r\n    GROUP BY 1\r\n  ),\r\n  latest_msg AS (\r\n    SELECT \r\n      m.contato_id,\r\n      COUNT(*) FILTER (WHERE m.is_read = false AND m.direction = 'inbound') as unread\r\n    FROM whatsapp_messages m\r\n    WHERE m.organizacao_id = p_organizacao_id\r\n    GROUP BY 1\r\n  )\r\n  SELECT \r\n    gc.representative_id as id,\r\n    c.id as contato_id,\r\n    COALESCE((SELECT t.telefone FROM telefones t WHERE t.contato_id = c.id LIMIT 1), wc.phone_number) as phone_number,\r\n    -- Prioriza o nome do contato. Se for nulo, usa o n√∫mero formatado\r\n    COALESCE(NULLIF(c.nome, ''), 'Lead (' || wc.phone_number || ')') as nome,\r\n    c.foto_url as avatar_url,\r\n    COALESCE(lm.unread, 0) as unread_count,\r\n    (SELECT content FROM whatsapp_messages wm \r\n     WHERE (wm.contato_id = c.id AND c.id IS NOT NULL) \r\n        OR (wm.sender_id = wc.phone_number OR wm.receiver_id = wc.phone_number)\r\n     ORDER BY sent_at DESC LIMIT 1) as last_message,\r\n    gc.last_update as last_message_time,\r\n    'text' as message_type\r\n  FROM grouped_convs gc\r\n  JOIN whatsapp_conversations wc ON wc.id = gc.representative_id\r\n  LEFT JOIN contatos c ON c.id = wc.contato_id\r\n  LEFT JOIN latest_msg lm ON lm.contato_id = c.id\r\n  ORDER BY gc.last_update DESC;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_lancamentos_avancado",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_lancamentos_avancado(p_organizacao_id bigint, p_filtros jsonb, p_page integer, p_items_per_page integer, p_sort_field text, p_sort_direction text)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\ndeclare\r\n  v_where text;\r\n  v_offset integer;\r\n  v_total_count bigint;\r\n  v_data jsonb;\r\n  v_stats jsonb; -- 1. Criamos a vari√°vel para guardar os totais\r\nbegin\r\n  v_offset := (p_page - 1) * p_items_per_page;\r\n\r\n  -- Chama o c√©rebro central (Isso garante que o filtro √© ID√äNTICO para lista e stats)\r\n  v_where := financeiro_montar_where(p_organizacao_id, p_filtros);\r\n\r\n  -- 2. Calcula os Totais (KPIs) usando o MESMO filtro\r\n  -- Reutilizamos a fun√ß√£o que j√° existe para garantir consist√™ncia matem√°tica\r\n  v_stats := get_financeiro_consolidado(p_organizacao_id, p_filtros);\r\n\r\n  -- 3. Conta Total de itens da lista\r\n  execute 'select count(*) from lancamentos l' || v_where into v_total_count;\r\n\r\n  -- 4. Busca os Dados da Lista (Pagina√ß√£o)\r\n  execute '\r\n    select json_agg(t) from (\r\n      select \r\n        l.*,\r\n        (select jsonb_build_object(''id'', c.id, ''nome'', c.nome, ''tipo'', c.tipo, ''empresa'', (select jsonb_build_object(''nome_fantasia'', ce.nome_fantasia, ''razao_social'', ce.razao_social) from cadastro_empresa ce where ce.id = c.empresa_id)) from contas_financeiras c where c.id = l.conta_id) as conta,\r\n        (select jsonb_build_object(''id'', cat.id, ''nome'', cat.nome) from categorias_financeiras cat where cat.id = l.categoria_id) as categoria,\r\n        (select jsonb_build_object(''id'', emp.id, ''nome'', emp.nome) from empreendimentos emp where emp.id = l.empreendimento_id) as empreendimento,\r\n        (select jsonb_build_object(''id'', fav.id, ''nome'', fav.nome, ''razao_social'', fav.razao_social) from contatos fav where fav.id = l.favorecido_contato_id) as favorecido\r\n      from lancamentos l\r\n      ' || v_where || '\r\n      order by l.' || p_sort_field || ' ' || p_sort_direction || '\r\n      limit ' || p_items_per_page || ' offset ' || v_offset || '\r\n    ) t'\r\n  into v_data;\r\n\r\n  -- 5. O Grande Retorno Unificado\r\n  return jsonb_build_object(\r\n    'data', coalesce(v_data, '[]'::jsonb),\r\n    'count', v_total_count,\r\n    'stats', v_stats -- <--- AGORA SIM! O \"Motor √önico\" entrega tudo!\r\n  );\r\nend;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_lancamentos_com_saldo",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_lancamentos_com_saldo(p_conta_id bigint, p_start_date date, p_end_date date)\n RETURNS TABLE(id bigint, descricao text, valor numeric, data_transacao date, tipo text, status text, conta_id bigint, categoria_id bigint, empreendimento_id bigint, etapa_id bigint, pedido_compra_id bigint, funcionario_id bigint, created_at timestamp with time zone, data_vencimento date, data_pagamento date, parcela_info text, recorrencia_id bigint, favorecido_contato_id bigint, conciliado boolean, id_transacao_externa text, empresa_id bigint, criado_por_usuario_id uuid, conta_destino_id bigint, observacao text, mes_competencia date, saldo numeric)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    saldo_inicial NUMERIC;\r\nBEGIN\r\n    -- Calcula o saldo inicial da conta ANTES da data de in√≠cio do filtro.\r\n    SELECT COALESCE(SUM(CASE WHEN l.tipo = 'Receita' THEN l.valor ELSE -l.valor END), 0)\r\n    INTO saldo_inicial\r\n    FROM lancamentos l\r\n    WHERE l.conta_id = p_conta_id AND l.data_transacao < p_start_date;\r\n\r\n    -- Retorna os lan√ßamentos do per√≠odo, calculando o saldo progressivo.\r\n    RETURN QUERY\r\n    SELECT\r\n        l.id,\r\n        l.descricao,\r\n        l.valor,\r\n        l.data_transacao,\r\n        l.tipo,\r\n        l.status,\r\n        l.conta_id,\r\n        l.categoria_id,\r\n        l.empreendimento_id,\r\n        l.etapa_id,\r\n        l.pedido_compra_id,\r\n        l.funcionario_id,\r\n        l.created_at,\r\n        l.data_vencimento,\r\n        l.data_pagamento,\r\n        l.parcela_info,\r\n        l.recorrencia_id,\r\n        l.favorecido_contato_id,\r\n        l.conciliado,\r\n        l.id_transacao_externa,\r\n        l.empresa_id,\r\n        l.criado_por_usuario_id,\r\n        l.conta_destino_id,\r\n        l.observacao,\r\n        l.mes_competencia,\r\n        saldo_inicial + SUM(CASE WHEN l.tipo = 'Receita' THEN l.valor ELSE -l.valor END) OVER (ORDER BY l.data_transacao, l.created_at, l.id) AS saldo\r\n    FROM\r\n        lancamentos l\r\n    WHERE\r\n        l.conta_id = p_conta_id\r\n        AND l.data_transacao >= p_start_date\r\n        AND l.data_transacao <= p_end_date\r\n    ORDER BY\r\n        l.data_transacao, l.created_at, l.id;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_last_messages_for_contacts",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_last_messages_for_contacts()\n RETURNS TABLE(contato_id bigint, content text, sent_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    WITH ranked_messages AS (\r\n        SELECT\r\n            wm.contato_id,\r\n            wm.content,\r\n            wm.sent_at,\r\n            ROW_NUMBER() OVER(PARTITION BY wm.contato_id ORDER BY wm.sent_at DESC) as rn\r\n        FROM\r\n            public.whatsapp_messages AS wm\r\n    )\r\n    SELECT\r\n        rm.contato_id,\r\n        rm.content,\r\n        rm.sent_at\r\n    FROM\r\n        ranked_messages AS rm\r\n    WHERE\r\n        rm.rn = 1;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_latest_ad_snapshots",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_latest_ad_snapshots(p_organizacao_id bigint)\n RETURNS SETOF meta_ads_historico\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT DISTINCT ON (ad_id)\r\n        *\r\n    FROM\r\n        public.meta_ads_historico\r\n    WHERE\r\n        organizacao_id = p_organizacao_id\r\n    ORDER BY\r\n        ad_id, created_at DESC;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_latest_ad_snapshots_with_details",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_latest_ad_snapshots_with_details(p_organizacao_id bigint)\n RETURNS TABLE(ad_id text, ad_name text, campaign_name text, adset_name text, status text, thumbnail_url text, spend numeric, reach integer, impressions integer, leads integer, campaign_id text, adset_id text)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    -- Primeiro, encontramos o √∫ltimo \"snapshot\" de performance para cada an√∫ncio.\r\n    WITH latest_snapshots AS (\r\n        SELECT\r\n            h.ad_id,\r\n            h.spend,\r\n            h.impressions,\r\n            h.reach,\r\n            h.leads,\r\n            -- Esta fun√ß√£o m√°gica classifica os registros de cada an√∫ncio do mais novo para o mais antigo.\r\n            ROW_NUMBER() OVER(PARTITION BY h.ad_id ORDER BY h.data_snapshot DESC) as rn\r\n        FROM\r\n            public.meta_ads_historico h\r\n        WHERE\r\n            h.organizacao_id = p_organizacao_id\r\n    )\r\n    -- Agora, montamos o \"dossi√™\" completo.\r\n    SELECT\r\n        a.id AS ad_id,\r\n        a.name AS ad_name,          -- Nome do an√∫ncio (da tabela meta_ads)\r\n        camp.name AS campaign_name, -- Nome da campanha (da tabela meta_campaigns)\r\n        aset.name AS adset_name,    -- Nome do conjunto (da tabela meta_adsets)\r\n        a.status,                   -- Status atual (da tabela meta_ads)\r\n        a.thumbnail_url,            -- Imagem (da tabela meta_ads)\r\n        ls.spend,                   -- Performance do √∫ltimo dia (do hist√≥rico)\r\n        ls.reach,                   -- Performance do √∫ltimo dia (do hist√≥rico)\r\n        ls.impressions,             -- Performance do √∫ltimo dia (do hist√≥rico)\r\n        ls.leads,                   -- Performance do √∫ltimo dia (do hist√≥rico)\r\n        a.campaign_id,              -- ID da campanha para o filtro\r\n        a.adset_id                  -- ID do conjunto para o filtro\r\n    FROM\r\n        public.meta_ads a\r\n    -- Juntamos com o hist√≥rico para pegar a performance\r\n    JOIN latest_snapshots ls ON a.id = ls.ad_id\r\n    -- Juntamos com os conjuntos para pegar o nome\r\n    JOIN public.meta_adsets aset ON a.adset_id = aset.id\r\n    -- Juntamos com as campanhas para pegar o nome\r\n    JOIN public.meta_campaigns camp ON a.campaign_id = camp.id\r\n    WHERE\r\n        -- A condi√ß√£o final: s√≥ queremos o registro mais recente (o n√∫mero 1 do ranking)\r\n        ls.rn = 1 AND a.organizacao_id = p_organizacao_id;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_my_organization_id",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_my_organization_id()\n RETURNS bigint\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nBEGIN\r\n  RETURN (\r\n    SELECT organizacao_id\r\n    FROM public.usuarios\r\n    WHERE id = auth.uid() -- auth.uid() pega o ID do usu√°rio autenticado\r\n    LIMIT 1 -- Garante que retorne apenas um valor\r\n  );\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_or_create_contact_by_phone",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_or_create_contact_by_phone(p_phone_number text)\n RETURNS TABLE(found_contact_id bigint, found_empresa_id bigint)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_sanitized_phone TEXT;\r\n    v_contact_id BIGINT;\r\n    v_empresa_id BIGINT;\r\nBEGIN\r\n    -- Remove todos os caracteres n√£o num√©ricos do telefone recebido\r\n    v_sanitized_phone := regexp_replace(p_phone_number, '\\D', '', 'g');\r\n\r\n    -- Tenta encontrar o contato pelo n√∫mero de telefone j√° limpo na tabela 'telefones'\r\n    SELECT t.contato_id, c.empresa_id INTO v_contact_id, v_empresa_id\r\n    FROM public.telefones t\r\n    JOIN public.contatos c ON t.contato_id = c.id\r\n    WHERE t.telefone = v_sanitized_phone\r\n    LIMIT 1;\r\n\r\n    -- Se um contato for encontrado, retorna seus IDs\r\n    IF v_contact_id IS NOT NULL THEN\r\n        RETURN QUERY SELECT v_contact_id, v_empresa_id;\r\n        RETURN;\r\n    END IF;\r\n\r\n    -- Se NENHUM contato for encontrado, cria um novo\r\n    -- 1. Cria o registro na tabela 'contatos'\r\n    INSERT INTO public.contatos (nome, tipo_contato, personalidade_juridica)\r\n    VALUES ('Contato ' || v_sanitized_phone, 'Contato', 'Pessoa F√≠sica')\r\n    RETURNING id INTO v_contact_id;\r\n\r\n    -- 2. Cria o registro do telefone associado a este novo contato\r\n    INSERT INTO public.telefones (contato_id, telefone)\r\n    VALUES (v_contact_id, v_sanitized_phone);\r\n\r\n    -- 3. Retorna o ID do contato rec√©m-criado\r\n    RETURN QUERY SELECT v_contact_id, NULL::BIGINT;\r\n\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_organizacao_do_usuario_atual",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_organizacao_do_usuario_atual()\n RETURNS bigint\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\r\n  SELECT organizacao_id\r\n  FROM public.usuarios\r\n  WHERE id = auth.uid();\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_organizacao_id",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_organizacao_id()\n RETURNS bigint\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nBEGIN\r\n  RETURN (\r\n    SELECT organizacao_id FROM public.usuarios WHERE id = auth.uid()\r\n  );\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_performance_por_periodo",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_performance_por_periodo(p_organizacao_id bigint, p_start_date date, p_end_date date)\n RETURNS TABLE(ad_id text, ad_name text, campaign_name text, adset_name text, period_spend numeric, period_impressions bigint, period_clicks bigint, period_reach bigint, period_leads bigint)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    WITH end_values AS (\r\n        SELECT DISTINCT ON (h.ad_id)\r\n            h.ad_id,\r\n            h.ad_name,\r\n            h.campaign_name,\r\n            h.adset_name,\r\n            h.spend,\r\n            h.impressions,\r\n            h.clicks,\r\n            h.reach,\r\n            h.leads\r\n        FROM public.meta_ads_historico h\r\n        WHERE h.organizacao_id = p_organizacao_id AND h.created_at < (p_end_date + INTERVAL '1 day')\r\n        ORDER BY h.ad_id, h.created_at DESC\r\n    ),\r\n    start_values AS (\r\n        SELECT DISTINCT ON (ad_id)\r\n            ad_id,\r\n            spend,\r\n            impressions,\r\n            clicks,\r\n            reach,\r\n            leads\r\n        FROM public.meta_ads_historico\r\n        WHERE organizacao_id = p_organizacao_id AND created_at < p_start_date::timestamp\r\n        ORDER BY ad_id, created_at DESC\r\n    )\r\n    SELECT\r\n        ev.ad_id,\r\n        ev.ad_name,\r\n        ev.campaign_name,\r\n        ev.adset_name,\r\n        COALESCE(ev.spend, 0) - COALESCE(sv.spend, 0) AS period_spend,\r\n        (COALESCE(ev.impressions, 0) - COALESCE(sv.impressions, 0))::BIGINT AS period_impressions,\r\n        (COALESCE(ev.clicks, 0) - COALESCE(sv.clicks, 0))::BIGINT AS period_clicks,\r\n        (COALESCE(ev.reach, 0) - COALESCE(sv.reach, 0))::BIGINT AS period_reach,\r\n        (COALESCE(ev.leads, 0) - COALESCE(sv.leads, 0))::BIGINT AS period_leads\r\n    FROM end_values ev\r\n    LEFT JOIN start_values sv ON ev.ad_id = sv.ad_id\r\n    WHERE ev.ad_id IS NOT NULL;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_previsao_folha_detalhada",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_previsao_folha_detalhada(p_organizacao_id bigint, p_mes_ref text)\n RETURNS TABLE(funcionario_id bigint, nome text, cargo text, modelo_contratacao text, salario_base numeric, valor_diaria numeric, dias_considerados numeric, custo_calculado numeric, observacao text)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_inicio_mes date;\r\n  v_fim_mes date;\r\n  \r\n  -- Vari√°veis de Loop\r\n  r_func record;\r\n  v_inicio_efetivo date;\r\n  v_fim_efetivo date;\r\n  \r\n  -- Vari√°veis de C√°lculo\r\n  v_dias_corridos_trab int;\r\n  v_dias_uteis_trab numeric;\r\n  v_custo_individual numeric;\r\n  v_modelo text;\r\n  v_dias_final numeric;\r\n  v_obs text;\r\n  \r\n  -- Auxiliares\r\n  v_dia_loop date;\r\n  v_tipo_feriado text;\r\nBEGIN\r\n  v_inicio_mes := to_date(p_mes_ref, 'YYYY-MM-DD');\r\n  v_fim_mes := (v_inicio_mes + interval '1 month' - interval '1 day')::date;\r\n\r\n  FOR r_func IN\r\n    SELECT \r\n      f.id, \r\n      f.full_name,\r\n      COALESCE(c.nome, f.contract_role, 'N√£o definido') as cargo_nome,\r\n      f.admission_date, \r\n      f.demission_date,\r\n      h.salario_base, \r\n      h.valor_diaria\r\n    FROM funcionarios f\r\n    LEFT JOIN cargos c ON f.cargo_id = c.id\r\n    LEFT JOIN LATERAL (\r\n      SELECT salario_base, valor_diaria \r\n      FROM historico_salarial \r\n      WHERE funcionario_id = f.id \r\n      ORDER BY data_inicio_vigencia DESC \r\n      LIMIT 1\r\n    ) h ON true\r\n    WHERE f.organizacao_id = p_organizacao_id\r\n      AND f.status = 'Ativo'\r\n      AND f.admission_date <= v_fim_mes::text\r\n      AND (f.demission_date IS NULL OR f.demission_date >= v_inicio_mes)\r\n    ORDER BY f.full_name\r\n  LOOP\r\n    \r\n    -- 1. Definir Per√≠odo Efetivo\r\n    v_inicio_efetivo := GREATEST(v_inicio_mes, r_func.admission_date::date);\r\n    IF r_func.demission_date IS NOT NULL THEN\r\n       v_fim_efetivo := LEAST(v_fim_mes, r_func.demission_date::date);\r\n    ELSE\r\n       v_fim_efetivo := v_fim_mes;\r\n    END IF;\r\n\r\n    v_obs := '';\r\n    \r\n    -- Verifica se entrou ou saiu no m√™s para avisar na observa√ß√£o\r\n    IF v_inicio_efetivo > v_inicio_mes THEN v_obs := v_obs || 'Admiss√£o no m√™s. '; END IF;\r\n    IF v_fim_efetivo < v_fim_mes THEN v_obs := v_obs || 'Demiss√£o no m√™s. '; END IF;\r\n\r\n    -- 2. Calcular conforme Modelo\r\n    IF COALESCE(r_func.salario_base, 0) > 0 THEN\r\n      -- MENSALISTA\r\n      v_modelo := 'Mensalista';\r\n      \r\n      -- Regra 30 dias (Proporcionalidade)\r\n      v_dias_corridos_trab := (v_fim_efetivo - v_inicio_efetivo) + 1;\r\n      \r\n      -- Se trabalhou o m√™s todo (mesmo que seja Fev com 28 ou Mar com 31), considera 30\r\n      IF v_inicio_efetivo = v_inicio_mes AND v_fim_efetivo = v_fim_mes THEN\r\n         v_dias_final := 30;\r\n         v_custo_individual := r_func.salario_base;\r\n      ELSE\r\n         -- Proporcional: Se trabalhou 31 dias num m√™s de 31, trava em 30? Geralmente sim.\r\n         IF v_dias_corridos_trab > 30 THEN v_dias_corridos_trab := 30; END IF;\r\n         v_dias_final := v_dias_corridos_trab;\r\n         v_custo_individual := (r_func.salario_base / 30.0) * v_dias_corridos_trab;\r\n      END IF;\r\n\r\n    ELSE\r\n      -- DIARISTA\r\n      v_modelo := 'Diarista';\r\n      v_dias_uteis_trab := 0;\r\n      v_dia_loop := v_inicio_efetivo;\r\n      \r\n      WHILE v_dia_loop <= v_fim_efetivo LOOP\r\n        IF EXTRACT(DOW FROM v_dia_loop) NOT IN (0, 6) THEN\r\n          SELECT tipo INTO v_tipo_feriado FROM feriados WHERE organizacao_id = p_organizacao_id AND data_feriado = v_dia_loop;\r\n          IF v_tipo_feriado IS NULL THEN\r\n            v_dias_uteis_trab := v_dias_uteis_trab + 1;\r\n          ELSIF v_tipo_feriado = 'Meio Per√≠odo' THEN\r\n             v_dias_uteis_trab := v_dias_uteis_trab + 0.5;\r\n          END IF;\r\n        END IF;\r\n        v_dia_loop := v_dia_loop + 1;\r\n      END LOOP;\r\n      \r\n      v_dias_final := v_dias_uteis_trab;\r\n      v_custo_individual := (COALESCE(r_func.valor_diaria, 0) * v_dias_uteis_trab);\r\n    END IF;\r\n\r\n    -- 3. Preencher a linha da tabela\r\n    funcionario_id := r_func.id;\r\n    nome := r_func.full_name;\r\n    cargo := r_func.cargo_nome;\r\n    modelo_contratacao := v_modelo;\r\n    salario_base := COALESCE(r_func.salario_base, 0);\r\n    valor_diaria := COALESCE(r_func.valor_diaria, 0);\r\n    dias_considerados := v_dias_final;\r\n    custo_calculado := ROUND(v_custo_individual, 2);\r\n    observacao := TRIM(v_obs);\r\n    \r\n    RETURN NEXT;\r\n  END LOOP;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_primeiro_funil_id",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_primeiro_funil_id()\n RETURNS uuid\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    funil_id UUID;\r\nBEGIN\r\n    SELECT id INTO funil_id FROM funis ORDER BY created_at LIMIT 1;\r\n    RETURN funil_id;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_recursive_categories",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_recursive_categories(p_ids_json jsonb)\n RETURNS TABLE(id bigint)\n LANGUAGE plpgsql\nAS $function$\r\nbegin\r\n  return query\r\n  with recursive cat_tree as (\r\n    -- Pega os IDs selecionados (base)\r\n    select c.id from categorias_financeiras c \r\n    where c.id in (\r\n        select (elem::text)::bigint \r\n        from jsonb_array_elements(p_ids_json) as elem \r\n        where (elem::text) <> '\"IS_NULL\"' and (elem::text) <> 'IS_NULL'\r\n    )\r\n    \r\n    union\r\n    \r\n    -- Pega os filhos (recurs√£o)\r\n    select c.id from categorias_financeiras c\r\n    inner join cat_tree t on c.parent_id = t.id\r\n  )\r\n  select * from cat_tree;\r\nend;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_relatorio_financeiro",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_relatorio_financeiro(p_organizacao_id bigint, p_filtros jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\ndeclare\r\n  v_where text;\r\n  v_kpis jsonb;\r\n  v_fluxo jsonb;\r\n  v_pizza jsonb;\r\n  v_use_competencia boolean;\r\n  v_coluna_data text;\r\nbegin\r\n  -- 1. Ler prefer√™ncia\r\n  v_use_competencia := coalesce((p_filtros->>'useCompetencia')::boolean, false);\r\n\r\n  -- 2. Definir qual coluna de data usar para o GR√ÅFICO (Agrupamento)\r\n  if v_use_competencia then\r\n      v_coluna_data := 'l.data_transacao';\r\n  else\r\n      v_coluna_data := 'CASE WHEN l.data_pagamento IS NOT NULL THEN l.data_pagamento WHEN l.data_vencimento IS NOT NULL THEN l.data_vencimento ELSE l.data_transacao END';\r\n  end if;\r\n\r\n  -- 3. CHAMA O C√âREBRO COMPARTILHADO (Garante que o filtro WHERE √© id√™ntico √† lista)\r\n  v_where := financeiro_montar_where(p_organizacao_id, p_filtros);\r\n\r\n  -- 4. Calcular KPIs (Totais Gerais - A mesma matem√°tica da lista)\r\n  execute '\r\n    select jsonb_build_object(\r\n      ''receita'', coalesce(sum(case when tipo = ''Receita'' then valor else 0 end), 0),\r\n      ''despesa'', coalesce(sum(case when tipo = ''Despesa'' then valor else 0 end), 0),\r\n      ''saldo'', coalesce(sum(case when tipo = ''Receita'' then valor else -valor end), 0)\r\n    )\r\n    from lancamentos l\r\n    ' || v_where \r\n  into v_kpis;\r\n\r\n  -- 5. Calcular Gr√°fico de Fluxo (Agora DIN√ÇMICO conforme a vis√£o)\r\n  execute '\r\n    select json_agg(t) from (\r\n      select \r\n        to_char(' || v_coluna_data || ', ''YYYY-MM-DD'') as data_ordem,\r\n        sum(case when tipo = ''Receita'' then valor else 0 end) as \"Receita\",\r\n        sum(case when tipo = ''Despesa'' then valor else 0 end) as \"Despesa\"\r\n      from lancamentos l\r\n      ' || v_where || '\r\n      group by 1\r\n      order by 1\r\n    ) t'\r\n  into v_fluxo;\r\n\r\n  -- 6. Calcular Gr√°fico de Pizza (Top 5 Despesas)\r\n  execute '\r\n    select json_agg(t) from (\r\n      select \r\n        coalesce(c.nome, ''Sem Categoria'') as name,\r\n        sum(l.valor) as value\r\n      from lancamentos l\r\n      left join categorias_financeiras c on c.id = l.categoria_id\r\n      ' || v_where || '\r\n      and l.tipo = ''Despesa''\r\n      group by 1\r\n      order by 2 desc\r\n      limit 5\r\n    ) t'\r\n  into v_pizza;\r\n\r\n  return jsonb_build_object(\r\n    'kpis', coalesce(v_kpis, '{}'::jsonb),\r\n    'graficoFluxo', coalesce(v_fluxo, '[]'::jsonb),\r\n    'graficoPizza', coalesce(v_pizza, '[]'::jsonb)\r\n  );\r\nend;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_rh_dashboard_stats",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_rh_dashboard_stats(p_organizacao_id bigint, p_mes_ref date)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_total_ativos integer;\r\n    v_admissoes integer;\r\n    v_demissoes integer;\r\n    v_aniversariantes integer;\r\n    v_tempo_medio numeric;\r\n    v_custo_folha numeric;\r\n    v_distribuicao_cargos jsonb;\r\n    v_inicio_mes date := date_trunc('month', p_mes_ref);\r\n    v_fim_mes date := (date_trunc('month', p_mes_ref) + interval '1 month' - interval '1 day')::date;\r\nBEGIN\r\n    -- Contagens B√°sicas\r\n    SELECT COUNT(*) INTO v_total_ativos \r\n    FROM funcionarios \r\n    WHERE status = 'Ativo' AND organizacao_id = p_organizacao_id;\r\n    \r\n    SELECT COUNT(*) INTO v_admissoes \r\n    FROM funcionarios \r\n    WHERE admission_date::date BETWEEN v_inicio_mes AND v_fim_mes AND organizacao_id = p_organizacao_id;\r\n    \r\n    SELECT COUNT(*) INTO v_demissoes \r\n    FROM funcionarios \r\n    WHERE demission_date BETWEEN v_inicio_mes AND v_fim_mes AND organizacao_id = p_organizacao_id;\r\n\r\n    -- Aniversariantes\r\n    SELECT COUNT(*) INTO v_aniversariantes \r\n    FROM funcionarios \r\n    WHERE EXTRACT(MONTH FROM birth_date::date) = EXTRACT(MONTH FROM p_mes_ref) \r\n    AND status = 'Ativo' AND organizacao_id = p_organizacao_id;\r\n\r\n    -- Tempo M√©dio\r\n    SELECT COALESCE(AVG(\r\n        EXTRACT(YEAR FROM age(CURRENT_DATE, admission_date::date)) * 12 + \r\n        EXTRACT(MONTH FROM age(CURRENT_DATE, admission_date::date))\r\n    ), 0) INTO v_tempo_medio\r\n    FROM funcionarios WHERE status = 'Ativo' AND organizacao_id = p_organizacao_id;\r\n\r\n    -- Custo Folha (CORRE√á√ÉO DE FORMATO: Troca v√≠rgula por ponto)\r\n    SELECT COALESCE(SUM(\r\n        CASE \r\n            WHEN base_salary IS NULL OR base_salary = '' THEN 0\r\n            ELSE \r\n                COALESCE(\r\n                    CAST(\r\n                        NULLIF(\r\n                            REPLACE(\r\n                                REGEXP_REPLACE(base_salary, '[^0-9,]', '', 'g'), -- Remove \"R$\", pontos de milhar e espa√ßos\r\n                                ',', '.' -- Troca a v√≠rgula decimal por ponto\r\n                            ), \r\n                            ''\r\n                        ) \r\n                    AS numeric),\r\n                    0\r\n                )\r\n        END\r\n    ), 0) INTO v_custo_folha\r\n    FROM funcionarios WHERE status = 'Ativo' AND organizacao_id = p_organizacao_id;\r\n\r\n    -- Distribui√ß√£o por Cargo\r\n    SELECT jsonb_agg(t) INTO v_distribuicao_cargos FROM (\r\n        SELECT \r\n            COALESCE(c.nome, 'Cargo n√£o definido') as nome, \r\n            COUNT(f.id) as valor\r\n        FROM funcionarios f\r\n        LEFT JOIN cargos c ON f.cargo_id = c.id\r\n        WHERE f.status = 'Ativo' AND f.organizacao_id = p_organizacao_id\r\n        GROUP BY c.nome\r\n        ORDER BY valor DESC\r\n    ) t;\r\n\r\n    RETURN jsonb_build_object(\r\n        'total_ativos', v_total_ativos,\r\n        'admissoes', v_admissoes,\r\n        'demissoes', v_demissoes,\r\n        'aniversariantes', v_aniversariantes,\r\n        'tempo_medio_meses', ROUND(v_tempo_medio, 1),\r\n        'custo_folha', v_custo_folha,\r\n        'distribuicao_cargos', COALESCE(v_distribuicao_cargos, '[]'::jsonb),\r\n        'dias_uteis_mes', 22\r\n    );\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_rh_financial_evolution",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_rh_financial_evolution(p_organizacao_id bigint, p_ano integer)\n RETURNS json\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_mes int;\r\n  v_data_ref text;\r\n  v_resultado_calc record; -- Vari√°vel para guardar o retorno da calculadora\r\n  v_historico jsonB := '[]'::jsonB;\r\n  v_total_anual numeric := 0;\r\n  v_media_anual numeric := 0;\r\n  v_meses_com_dados int := 0;\r\nBEGIN\r\n  -- Loop de Janeiro (1) a Dezembro (12)\r\n  FOR v_mes IN 1..12 LOOP\r\n    -- Cria a data de refer√™ncia: '2025-01-01', '2025-02-01'...\r\n    v_data_ref := to_char(make_date(p_ano, v_mes, 1), 'YYYY-MM-DD');\r\n\r\n    -- AQUI EST√Å O SEGREDO:\r\n    -- Chamamos a MESMA fun√ß√£o que alimenta o KPI (calcular_previsao_folha)\r\n    -- Assim garantimos que a l√≥gica √© id√™ntica (dias √∫teis, feriados, pro-rata)\r\n    SELECT custo_total \r\n    INTO v_resultado_calc\r\n    FROM calcular_previsao_folha(p_organizacao_id, v_data_ref);\r\n\r\n    -- Monta o objeto para o gr√°fico\r\n    v_historico := v_historico || jsonb_build_object(\r\n      'mes', v_mes,\r\n      'total', COALESCE(v_resultado_calc.custo_total, 0)\r\n    );\r\n\r\n    -- Acumula para m√©dia anual (se tiver valor > 0)\r\n    IF COALESCE(v_resultado_calc.custo_total, 0) > 0 THEN\r\n      v_total_anual := v_total_anual + v_resultado_calc.custo_total;\r\n      v_meses_com_dados := v_meses_com_dados + 1;\r\n    END IF;\r\n    \r\n  END LOOP;\r\n\r\n  -- Calcula m√©dia simples dos meses que tiveram movimento\r\n  IF v_meses_com_dados > 0 THEN\r\n    v_media_anual := ROUND(v_total_anual / v_meses_com_dados, 2);\r\n  END IF;\r\n\r\n  RETURN json_build_object(\r\n    'historico', v_historico,\r\n    'media_anual', v_media_anual,\r\n    'total_anual', v_total_anual\r\n  );\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_rh_yearly_stats",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_rh_yearly_stats(p_organizacao_id bigint, p_ano integer)\n RETURNS TABLE(mes integer, admissoes bigint, demissoes bigint, ativos bigint)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  WITH meses AS (\r\n    SELECT generate_series(1, 12) AS m\r\n  ),\r\n  funcionarios_tratados AS (\r\n    SELECT \r\n      id,\r\n      organizacao_id,\r\n      demission_date,\r\n      -- Tenta converter a admiss√£o (texto) para Data real\r\n      CASE \r\n        WHEN admission_date LIKE '%/%' THEN to_date(admission_date, 'DD/MM/YYYY') -- Formato BR\r\n        WHEN admission_date LIKE '%-%' THEN to_date(admission_date, 'YYYY-MM-DD') -- Formato ISO\r\n        ELSE NULL -- Se for lixo, ignora\r\n      END AS data_admissao_real\r\n    FROM funcionarios\r\n    WHERE organizacao_id = p_organizacao_id\r\n  )\r\n  SELECT \r\n    ms.m AS mes,\r\n    \r\n    -- 1. ADMISS√ïES\r\n    (SELECT count(*) FROM funcionarios_tratados f \r\n     WHERE f.data_admissao_real IS NOT NULL \r\n     AND extract(year FROM f.data_admissao_real) = p_ano \r\n     AND extract(month FROM f.data_admissao_real) = ms.m) AS admissoes,\r\n     \r\n    -- 2. DEMISS√ïES (Esse j√° √© date, mais f√°cil)\r\n    (SELECT count(*) FROM funcionarios_tratados f \r\n     WHERE f.demission_date IS NOT NULL\r\n     AND extract(year FROM f.demission_date) = p_ano \r\n     AND extract(month FROM f.demission_date) = ms.m) AS demissoes,\r\n\r\n    -- 3. ATIVOS (Saldo)\r\n    (SELECT count(*) FROM funcionarios_tratados f \r\n     WHERE f.data_admissao_real IS NOT NULL\r\n     -- Entrou at√© o fim deste m√™s\r\n     AND f.data_admissao_real <= (make_date(p_ano, ms.m, 1) + interval '1 month' - interval '1 day')\r\n     -- E (N√ÉO saiu OU saiu DEPOIS desse m√™s)\r\n     AND (f.demission_date IS NULL OR f.demission_date > (make_date(p_ano, ms.m, 1) + interval '1 month' - interval '1 day'))\r\n    ) AS ativos\r\n  FROM meses ms;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_salario_atual",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_salario_atual(p_funcionario_id bigint)\n RETURNS TABLE(salario_base numeric, valor_diaria numeric)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    -- Etapa 1: Tenta encontrar o sal√°rio mais recente que j√° est√° em vigor (data de in√≠cio <= hoje)\r\n    RETURN QUERY\r\n    SELECT\r\n        hs.salario_base,\r\n        hs.valor_diaria\r\n    FROM\r\n        public.historico_salarial hs\r\n    WHERE\r\n        hs.funcionario_id = p_funcionario_id\r\n        AND hs.data_inicio_vigencia <= CURRENT_DATE\r\n    ORDER BY\r\n        hs.data_inicio_vigencia DESC, hs.criado_em DESC\r\n    LIMIT 1;\r\n\r\n    -- Etapa 2: Se NADA foi retornado acima (ou seja, n√£o h√° hist√≥rico v√°lido para o presente/passado),\r\n    -- ent√£o a fun√ß√£o continua para o pr√≥ximo passo.\r\n    IF NOT FOUND THEN\r\n        -- Etapa 2a: Procura por sal√°rios agendados para o FUTURO.\r\n        RETURN QUERY\r\n        SELECT\r\n            hs.salario_base,\r\n            hs.valor_diaria\r\n        FROM\r\n            public.historico_salarial hs\r\n        WHERE\r\n            hs.funcionario_id = p_funcionario_id\r\n        ORDER BY\r\n            hs.data_inicio_vigencia ASC, hs.criado_em ASC -- Pega o mais pr√≥ximo do futuro\r\n        LIMIT 1;\r\n\r\n        -- Etapa 3: Se ainda n√£o encontrou NADA (nem passado, nem futuro),\r\n        -- usa o plano B e busca os valores da ficha do funcion√°rio.\r\n        IF NOT FOUND THEN\r\n            RETURN QUERY\r\n            SELECT \r\n                CAST(REPLACE(REPLACE(f.base_salary, '.', ''), ',', '.') AS NUMERIC),\r\n                CAST(REPLACE(REPLACE(f.daily_value, '.', ''), ',', '.') AS NUMERIC)\r\n            FROM \r\n                public.funcionarios f\r\n            WHERE \r\n                f.id = p_funcionario_id;\r\n        END IF;\r\n    END IF;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_saldo_banco_horas",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_saldo_banco_horas(p_funcionario_id bigint)\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    total_minutos integer;\r\nBEGIN\r\n    SELECT COALESCE(SUM(saldo_minutos), 0)\r\n    INTO total_minutos\r\n    FROM public.banco_de_horas\r\n    WHERE funcionario_id = p_funcionario_id;\r\n\r\n    RETURN total_minutos;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_saldo_banco_horas_ate_mes_anterior",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_saldo_banco_horas_ate_mes_anterior(p_funcionario_id bigint, p_mes_referencia text)\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_data_inicio_mes date;\r\n    v_total_minutos_saldo integer;\r\n    v_total_minutos_ajustes integer;\r\nBEGIN\r\n    -- Converte a string 'AAAA-MM' para o primeiro dia do m√™s.\r\n    v_data_inicio_mes := (p_mes_referencia || '-01')::date;\r\n\r\n    -- 1. Calcula o saldo do banco de horas de todos os meses ANTERIORES usando a VIEW.\r\n    -- Esta consulta agora soma os saldos di√°rios pr√©-calculados.\r\n    SELECT COALESCE(SUM(saldo_minutos_dia), 0)::integer\r\n    INTO v_total_minutos_saldo\r\n    FROM public.saldos_diarios_ponto\r\n    WHERE funcionario_id = p_funcionario_id\r\n      AND data < v_data_inicio_mes;\r\n      \r\n    -- 2. Soma todos os ajustes manuais feitos AT√â o final do m√™s anterior.\r\n    SELECT COALESCE(SUM(minutos_ajustados), 0)\r\n    INTO v_total_minutos_ajustes\r\n    FROM public.ajustes_banco_horas\r\n    WHERE funcionario_id = p_funcionario_id\r\n      AND data_ajuste < v_data_inicio_mes;\r\n\r\n    -- 3. Retorna o saldo total (horas calculadas + ajustes manuais)\r\n    RETURN v_total_minutos_saldo + v_total_minutos_ajustes;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_unread_counts",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_unread_counts(p_account_id uuid)\n RETURNS TABLE(path text, count bigint)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT folder_path as path, COUNT(*) as count\r\n    FROM email_messages_cache\r\n    WHERE account_id = p_account_id\r\n    AND is_read = false\r\n    GROUP BY folder_path;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_user_funcao_id",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_user_funcao_id()\n RETURNS bigint\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n    funcao_id_result BIGINT;\r\nBEGIN\r\n    -- Busca o funcao_id na tabela usuarios usando o ID do usu√°rio autenticado (auth.uid())\r\n    SELECT\r\n        funcao_id\r\n    INTO\r\n        funcao_id_result\r\n    FROM\r\n        public.usuarios\r\n    WHERE\r\n        id = auth.uid(); -- auth.uid() √© uma fun√ß√£o especial do Supabase que retorna o ID do usu√°rio logado\r\n\r\n    -- Retorna o ID encontrado ou NULL se n√£o encontrar\r\n    RETURN funcao_id_result;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_user_role",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_user_role(user_id uuid)\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    role_name TEXT;\r\nBEGIN\r\n    SELECT f.nome_funcao INTO role_name\r\n    FROM public.usuarios u\r\n    JOIN public.funcoes f ON u.funcao_id = f.id\r\n    WHERE u.id = user_id;\r\n    RETURN role_name;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_whatsapp_conversations",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_whatsapp_conversations()\n RETURNS TABLE(contato_id bigint, nome_contato text, ultima_mensagem_conteudo text, ultima_mensagem_em timestamp with time zone, nao_lidas bigint, foto_url text, numero_telefone text)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    WITH latest_messages AS (\r\n        SELECT\r\n            wm.contato_id,\r\n            wm.content,\r\n            wm.sent_at,\r\n            wm.direction,\r\n            c.nome AS nome_contato,\r\n            c.foto_url,\r\n            ROW_NUMBER() OVER(PARTITION BY wm.contato_id ORDER BY wm.sent_at DESC) as rn\r\n        FROM\r\n            public.whatsapp_messages wm\r\n        JOIN\r\n            public.contatos c ON wm.contato_id = c.id\r\n    ),\r\n    unread_counts AS (\r\n        SELECT\r\n            wm.contato_id,\r\n            COUNT(*) as unread_count\r\n        FROM\r\n            public.whatsapp_messages wm\r\n        WHERE\r\n            wm.status = 'received' AND wm.direction = 'incoming'\r\n        GROUP BY\r\n            wm.contato_id\r\n    ),\r\n    contact_phones AS (\r\n        SELECT\r\n            t.contato_id,\r\n            (SELECT tel.telefone FROM public.telefones tel WHERE tel.contato_id = t.contato_id LIMIT 1) as numero_telefone\r\n        FROM\r\n            public.telefones t\r\n        GROUP BY t.contato_id\r\n    )\r\n    SELECT\r\n        lm.contato_id,\r\n        lm.nome_contato,\r\n        lm.content AS ultima_mensagem_conteudo,\r\n        lm.sent_at AS ultima_mensagem_em,\r\n        COALESCE(uc.unread_count, 0) AS nao_lidas,\r\n        lm.foto_url,\r\n        cp.numero_telefone\r\n    FROM\r\n        latest_messages lm\r\n    LEFT JOIN\r\n        unread_counts uc ON lm.contato_id = uc.contato_id\r\n    LEFT JOIN\r\n        contact_phones cp ON lm.contato_id = cp.contato_id\r\n    WHERE\r\n        lm.rn = 1\r\n    ORDER BY\r\n        lm.sent_at DESC;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "get_whatsapp_conversations_v2",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.get_whatsapp_conversations_v2(p_organizacao_id bigint)\n RETURNS TABLE(conversation_id bigint, phone_number text, contato_id bigint, nome text, avatar_url text, unread_count integer, last_message_content text, last_message_at timestamp with time zone, last_direction text, last_status text, tipo_contato text, etapa_funil text, is_archived boolean, last_inbound_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT \r\n        wc.id as conversation_id,\r\n        wc.phone_number,\r\n        wc.contato_id,\r\n        c.nome,\r\n        c.foto_url as avatar_url,\r\n        wc.unread_count,\r\n        wm.content as last_message_content,\r\n        wc.updated_at as last_message_at,\r\n        wc.last_direction, -- 'inbound' ou 'outbound'\r\n        wc.last_status,\r\n        c.tipo_contato::text,\r\n        col.nome as etapa_funil,\r\n        wc.is_archived,\r\n        -- Busca a data da √∫ltima mensagem recebida para o timer de 24h\r\n        (SELECT MAX(sent_at) FROM whatsapp_messages m WHERE m.conversation_record_id = wc.id AND m.direction = 'inbound') as last_inbound_at\r\n    FROM \r\n        public.whatsapp_conversations wc\r\n    LEFT JOIN \r\n        public.contatos c ON wc.contato_id = c.id\r\n    LEFT JOIN \r\n        public.whatsapp_messages wm ON wc.last_message_id = wm.id\r\n    LEFT JOIN\r\n        public.contatos_no_funil cnf ON c.id = cnf.contato_id\r\n    LEFT JOIN\r\n        public.colunas_funil col ON cnf.coluna_id = col.id\r\n    WHERE \r\n        wc.organizacao_id = p_organizacao_id\r\n    ORDER BY \r\n        wc.updated_at DESC;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "halfvec",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.halfvec(halfvec, integer, boolean)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "halfvec_accum",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.halfvec_accum(double precision[], halfvec)\n RETURNS double precision[]\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_accum$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "halfvec_add",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.halfvec_add(halfvec, halfvec)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_add$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "halfvec_avg",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.halfvec_avg(double precision[])\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_avg$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "halfvec_cmp",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.halfvec_cmp(halfvec, halfvec)\n RETURNS integer\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_cmp$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "halfvec_combine",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.halfvec_combine(double precision[], double precision[])\n RETURNS double precision[]\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_combine$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "halfvec_concat",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.halfvec_concat(halfvec, halfvec)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_concat$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "halfvec_eq",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.halfvec_eq(halfvec, halfvec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_eq$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "halfvec_ge",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.halfvec_ge(halfvec, halfvec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_ge$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "halfvec_gt",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.halfvec_gt(halfvec, halfvec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_gt$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "halfvec_in",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.halfvec_in(cstring, oid, integer)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_in$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "halfvec_l2_squared_distance",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.halfvec_l2_squared_distance(halfvec, halfvec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_l2_squared_distance$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "halfvec_le",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.halfvec_le(halfvec, halfvec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_le$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "halfvec_lt",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.halfvec_lt(halfvec, halfvec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_lt$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "halfvec_mul",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.halfvec_mul(halfvec, halfvec)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_mul$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "halfvec_ne",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.halfvec_ne(halfvec, halfvec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_ne$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "halfvec_negative_inner_product",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.halfvec_negative_inner_product(halfvec, halfvec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_negative_inner_product$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "halfvec_out",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.halfvec_out(halfvec)\n RETURNS cstring\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_out$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "halfvec_recv",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.halfvec_recv(internal, oid, integer)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_recv$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "halfvec_send",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.halfvec_send(halfvec)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_send$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "halfvec_spherical_distance",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.halfvec_spherical_distance(halfvec, halfvec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_spherical_distance$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "halfvec_sub",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.halfvec_sub(halfvec, halfvec)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_sub$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "halfvec_to_float4",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.halfvec_to_float4(halfvec, integer, boolean)\n RETURNS real[]\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_to_float4$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "halfvec_to_sparsevec",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.halfvec_to_sparsevec(halfvec, integer, boolean)\n RETURNS sparsevec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_to_sparsevec$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "halfvec_to_vector",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.halfvec_to_vector(halfvec, integer, boolean)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_to_vector$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "halfvec_typmod_in",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.halfvec_typmod_in(cstring[])\n RETURNS integer\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_typmod_in$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "hamming_distance",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.hamming_distance(bit, bit)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$hamming_distance$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "handle_activity_start_date",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.handle_activity_start_date()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Verifica se o status est√° sendo mudado PARA 'Em Andamento'\r\n    -- E se a data de in√≠cio real ainda n√£o foi definida\r\n    IF NEW.status = 'Em Andamento' AND OLD.data_inicio_real IS NULL THEN\r\n        -- Define a data de in√≠cio real como a data/hora atual\r\n        NEW.data_inicio_real = timezone('America/Sao_Paulo', now());\r\n    END IF;\r\n    \r\n    -- Retorna o registro modificado para ser salvo na tabela\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "handle_activity_status_change",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.handle_activity_status_change()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Se a opera√ß√£o for uma ATUALIZA√á√ÉO (UPDATE)\r\n    IF (TG_OP = 'UPDATE') THEN\r\n        -- Verifica se o status mudou para 'Em andamento' e a data de in√≠cio real est√° vazia\r\n        IF NEW.status = 'Em andamento' AND OLD.status IS DISTINCT FROM 'Em andamento' AND NEW.data_inicio_real IS NULL THEN\r\n            NEW.data_inicio_real := CURRENT_DATE;\r\n        END IF;\r\n\r\n        -- Verifica se o status mudou para 'Conclu√≠do' e a data de fim real est√° vazia\r\n        IF NEW.status = 'Conclu√≠do' AND OLD.status IS DISTINCT FROM 'Conclu√≠do' AND NEW.data_fim_real IS NULL THEN\r\n            NEW.data_fim_real := CURRENT_DATE;\r\n        END IF;\r\n    \r\n    -- Se a opera√ß√£o for uma CRIA√á√ÉO (INSERT)\r\n    ELSIF (TG_OP = 'INSERT') THEN\r\n        -- Se a nova atividade j√° for criada como 'Em andamento', preenche a data de in√≠cio real\r\n        IF NEW.status = 'Em andamento' THEN\r\n            NEW.data_inicio_real := CURRENT_DATE;\r\n        END IF;\r\n\r\n        -- Se a nova atividade j√° for criada como 'Conclu√≠do', preenche a data de fim real (e a de in√≠cio, se vazia)\r\n        IF NEW.status = 'Conclu√≠do' THEN\r\n            IF NEW.data_inicio_real IS NULL THEN\r\n                NEW.data_inicio_real := CURRENT_DATE;\r\n            END IF;\r\n            NEW.data_fim_real := CURRENT_DATE;\r\n        END IF;\r\n    END IF;\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "handle_activity_status_changes",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.handle_activity_status_changes()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- REGRA 1: Ao iniciar uma atividade\r\n    -- Se o status for alterado para 'Em Andamento' e o in√≠cio real estiver vazio,\r\n    -- preenche o in√≠cio real com a data de HOJE.\r\n    IF NEW.status = 'Em Andamento' AND OLD.data_inicio_real IS NULL THEN\r\n        NEW.data_inicio_real := timezone('America/Sao_Paulo', now())::date;\r\n    END IF;\r\n\r\n    -- REGRA 2: Ao concluir uma atividade\r\n    -- Se o status for alterado para 'Conclu√≠do' e o fim real estiver vazio,\r\n    -- preenche o fim real com a data de HOJE.\r\n    IF NEW.status = 'Conclu√≠do' AND OLD.data_fim_real IS NULL THEN\r\n        NEW.data_fim_real := timezone('America/Sao_Paulo', now())::date;\r\n    END IF;\r\n    \r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "handle_new_contact_funnel",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.handle_new_contact_funnel()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_funil_id uuid;\r\n    v_coluna_id uuid;\r\nBEGIN\r\n    -- S√≥ processa se for da mesma organiza√ß√£o\r\n    -- (Opcional: Voc√™ pode filtrar por tipo se quiser, ex: IF NEW.tipo_contato = 'Lead' THEN...)\r\n\r\n    -- 2. Busca o Funil Principal da Organiza√ß√£o (o primeiro criado)\r\n    SELECT id INTO v_funil_id\r\n    FROM public.funis\r\n    WHERE organizacao_id = NEW.organizacao_id\r\n    ORDER BY created_at ASC\r\n    LIMIT 1;\r\n\r\n    -- 3. Busca a Primeira Coluna desse Funil (onde tem ordem menor, ex: 0 ou 1)\r\n    SELECT id INTO v_coluna_id\r\n    FROM public.colunas_funil\r\n    WHERE funil_id = v_funil_id\r\n    ORDER BY ordem ASC\r\n    LIMIT 1;\r\n\r\n    -- 4. Insere o Contato no Funil (Se achou funil e coluna)\r\n    IF v_coluna_id IS NOT NULL THEN\r\n        INSERT INTO public.contatos_no_funil (\r\n            contato_id, \r\n            coluna_id, \r\n            organizacao_id, \r\n            created_at\r\n        )\r\n        VALUES (\r\n            NEW.id, \r\n            v_coluna_id, \r\n            NEW.organizacao_id, \r\n            now()\r\n        )\r\n        ON CONFLICT (contato_id) DO NOTHING; -- Se j√° estiver l√°, tudo bem, segue a vida\r\n    END IF;\r\n\r\n    RETURN NEW;\r\nEXCEPTION\r\n    WHEN OTHERS THEN\r\n        -- Seguran√ßa: Se der erro no funil, N√ÉO impede a cria√ß√£o do contato. \r\n        -- Apenas avisa no log e deixa passar.\r\n        RAISE WARNING 'Erro ao adicionar contato % ao funil: %', NEW.id, SQLERRM;\r\n        RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "handle_new_message_update_conversation",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.handle_new_message_update_conversation()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_phone_raw text;\r\n    v_phone_clean text;\r\n    v_direction text;\r\n    v_status text;\r\n    v_existing_conv_id bigint;\r\nBEGIN\r\n    -- 1. Quem √© o n√∫mero alvo?\r\n    IF NEW.direction = 'outbound' THEN\r\n        v_phone_raw := NEW.receiver_id;\r\n        v_direction := 'outbound';\r\n        v_status := NEW.status;\r\n    ELSE\r\n        v_phone_raw := NEW.sender_id;\r\n        v_direction := 'inbound';\r\n        v_status := 'received';\r\n    END IF;\r\n\r\n    -- 2. Normaliza para busca (Remove + e caracteres)\r\n    v_phone_clean := regexp_replace(v_phone_raw, '[^0-9]', '', 'g');\r\n\r\n    -- 3. Tenta encontrar conversa existente (Busca Flex√≠vel)\r\n    -- Isso impede que 5533... crie uma nova se 33... j√° existir\r\n    SELECT id INTO v_existing_conv_id\r\n    FROM public.whatsapp_conversations\r\n    WHERE \r\n        regexp_replace(phone_number, '[^0-9]', '', 'g') = v_phone_clean\r\n        AND organizacao_id = NEW.organizacao_id\r\n    LIMIT 1;\r\n\r\n    -- 4. Atualiza ou Cria\r\n    IF v_existing_conv_id IS NOT NULL THEN\r\n        UPDATE public.whatsapp_conversations\r\n        SET \r\n            updated_at = NEW.created_at,\r\n            last_message_id = NEW.id,\r\n            last_message_direction = v_direction,\r\n            last_status = v_status,\r\n            contato_id = COALESCE(contato_id, NEW.contato_id),\r\n            unread_count = CASE WHEN v_direction = 'inbound' THEN unread_count + 1 ELSE unread_count END,\r\n            is_archived = false -- Traz a conversa de volta se estiver arquivada\r\n        WHERE id = v_existing_conv_id;\r\n        \r\n        NEW.conversation_record_id := v_existing_conv_id;\r\n    ELSE\r\n        -- Cria√ß√£o Blindada\r\n        INSERT INTO public.whatsapp_conversations (\r\n            phone_number, contato_id, organizacao_id, created_at, updated_at, \r\n            last_message_id, last_direction, last_status, unread_count, is_archived\r\n        )\r\n        VALUES (\r\n            v_phone_raw, NEW.contato_id, NEW.organizacao_id, NEW.created_at, NEW.created_at, \r\n            NEW.id, v_direction, v_status, CASE WHEN v_direction = 'inbound' THEN 1 ELSE 0 END, false\r\n        )\r\n        RETURNING id INTO v_existing_conv_id;\r\n\r\n        NEW.conversation_record_id := v_existing_conv_id;\r\n    END IF;\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "handle_new_user",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.handle_new_user()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  -- Vari√°veis para os dados do signup\r\n  v_funcao_id bigint;\r\n  v_organizacao_id bigint;\r\n  v_nome text;\r\n  v_creci text;\r\n  v_cpf text;\r\n  \r\n  -- Vari√°veis para o caminho de \"Nova Organiza√ß√£o\"\r\n  proprietario_funcao_id bigint;\r\n  template_funcao_id bigint;\r\n  \r\nBEGIN\r\n  -- 1. Extrai os dados b√°sicos dos metadados\r\n  -- (Usando 'nome' que a nossa action.js envia)\r\n  v_funcao_id := (new.raw_user_meta_data->>'funcao_id')::bigint;\r\n  v_organizacao_id := (new.raw_user_meta_data->>'organizacao_id')::bigint;\r\n  v_nome := new.raw_user_meta_data->>'nome'; \r\n  v_creci := new.raw_user_meta_data->>'creci';\r\n  v_cpf := new.raw_user_meta_data->>'cpf';\r\n\r\n  -- =============================================\r\n  -- 2. L√ìGICA INTELIGENTE: Corretor ou Novo Propriet√°rio?\r\n  -- =============================================\r\n  IF v_funcao_id = 20 THEN\r\n    -- ----------- CAMINHO A: CADASTRO DE CORRETOR -----------\r\n    \r\n    -- Define a organiza√ß√£o como Studio 57 (ID 2), ignorando o que veio nos metadados\r\n    v_organizacao_id := 2; \r\n    \r\n    -- Insere o usu√°rio na tabela 'usuarios' com a fun√ß√£o CORRETOR (ID 20)\r\n    INSERT INTO public.usuarios (id, nome, email, funcao_id, organizacao_id)\r\n    VALUES (new.id, v_nome, new.email, v_funcao_id, v_organizacao_id);\r\n\r\n    -- Cria o registro na tabela 'contatos'\r\n    INSERT INTO public.contatos (criado_por_usuario_id, nome, creci, cpf, tipo_contato, organizacao_id)\r\n    VALUES (new.id, v_nome, v_creci, v_cpf, 'Corretor', v_organizacao_id);\r\n\r\n  ELSE\r\n    -- ----------- CAMINHO B: CADASTRO ORIGINAL (NOVA ORGANIZA√á√ÉO/PROPRIET√ÅRIO) -----------\r\n    \r\n    -- Verifica se o ID da *nova* organiza√ß√£o foi passado (essencial para este caminho)\r\n    IF v_organizacao_id IS NULL THEN\r\n       RAISE EXCEPTION 'Cadastro de nova organiza√ß√£o requer organizacao_id nos metadados do signup.';\r\n    END IF;\r\n\r\n    -- Cria a fun√ß√£o \"Propriet√°rio\" para a NOVA organiza√ß√£o\r\n    INSERT INTO public.funcoes (nome_funcao, descricao, organizacao_id)\r\n    VALUES ('Propriet√°rio', 'Acesso total ao sistema.', v_organizacao_id)\r\n    RETURNING id INTO proprietario_funcao_id;\r\n\r\n    -- Encontra o ID da fun√ß√£o \"Propriet√°rio\" da Studio 57 (ID 2) para usar como modelo\r\n    SELECT f.id INTO template_funcao_id\r\n    FROM public.funcoes f\r\n    WHERE f.nome_funcao = 'Propriet√°rio' AND f.organizacao_id = 2 \r\n    LIMIT 1;\r\n    \r\n    -- Copia as permiss√µes do modelo (se encontrado) para a nova fun√ß√£o, associando √† nova organiza√ß√£o\r\n    IF template_funcao_id IS NOT NULL THEN\r\n      INSERT INTO public.permissoes (funcao_id, recurso, pode_ver, pode_criar, pode_editar, pode_excluir, organizacao_id)\r\n      SELECT\r\n        proprietario_funcao_id, -- ID da nova fun√ß√£o Propriet√°rio\r\n        p.recurso, p.pode_ver, p.pode_criar, p.pode_editar, p.pode_excluir,\r\n        v_organizacao_id -- Associa √† nova organiza√ß√£o\r\n      FROM public.permissoes p\r\n      WHERE p.funcao_id = template_funcao_id;\r\n    END IF;\r\n\r\n    -- Insere o usu√°rio na tabela 'usuarios' como PROPRIET√ÅRIO da NOVA organiza√ß√£o\r\n    INSERT INTO public.usuarios (id, nome, email, organizacao_id, funcao_id)\r\n    VALUES (\r\n      new.id,\r\n      -- Tenta usar 'nome', sen√£o usa 'full_name' como no c√≥digo original\r\n      COALESCE(v_nome, new.raw_user_meta_data->>'full_name'), \r\n      new.email,\r\n      v_organizacao_id, -- ID da nova organiza√ß√£o\r\n      proprietario_funcao_id -- ID da nova fun√ß√£o Propriet√°rio\r\n    );\r\n  END IF; -- Fim da l√≥gica inteligente\r\n\r\n  RETURN new;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "handle_new_whatsapp_message",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.handle_new_whatsapp_message()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_contato_id bigint;\r\n    v_phone_clean text;\r\n    v_conversation_id bigint;\r\nBEGIN\r\n    -- S√≥ processa mensagens que est√£o entrando (inbound)\r\n    IF NEW.direction = 'inbound' THEN\r\n        \r\n        -- A. TENTA ACHAR O CONTATO (Se j√° n√£o veio preenchido)\r\n        IF NEW.contato_id IS NULL THEN\r\n            -- Limpa o n√∫mero para buscar (remove + e espa√ßos)\r\n            v_phone_clean := regexp_replace(NEW.sender_id, '\\D', '', 'g');\r\n            \r\n            -- Busca na tabela de telefones (Tenta com e sem o 9 se for BR)\r\n            SELECT contato_id INTO v_contato_id\r\n            FROM public.telefones\r\n            WHERE regexp_replace(telefone, '\\D', '', 'g') = v_phone_clean\r\n               OR regexp_replace(telefone, '\\D', '', 'g') = RIGHT(v_phone_clean, 11) -- Caso sem 55\r\n            LIMIT 1;\r\n            \r\n            -- Se achou, atualiza a vari√°vel e a pr√≥pria mensagem\r\n            IF v_contato_id IS NOT NULL THEN\r\n                NEW.contato_id := v_contato_id;\r\n            END IF;\r\n        ELSE\r\n            v_contato_id := NEW.contato_id;\r\n        END IF;\r\n\r\n        -- B. GERENCIA A CONVERSA (Cria ou Atualiza)\r\n        INSERT INTO public.whatsapp_conversations (\r\n            phone_number, \r\n            contato_id, \r\n            organizacao_id, \r\n            updated_at, \r\n            last_message_direction,\r\n            unread_count\r\n        )\r\n        VALUES (\r\n            NEW.sender_id, \r\n            v_contato_id, \r\n            NEW.organizacao_id, \r\n            NEW.sent_at, \r\n            'inbound',\r\n            1\r\n        )\r\n        ON CONFLICT (phone_number) \r\n        DO UPDATE SET \r\n            updated_at = EXCLUDED.updated_at,\r\n            last_message_direction = 'inbound',\r\n            contato_id = COALESCE(whatsapp_conversations.contato_id, EXCLUDED.contato_id),\r\n            unread_count = whatsapp_conversations.unread_count + 1\r\n        RETURNING id INTO v_conversation_id;\r\n\r\n        -- Vincula a mensagem √† conversa criada/atualizada\r\n        NEW.conversation_record_id := v_conversation_id;\r\n\r\n    END IF;\r\n\r\n    -- Se for mensagem enviada (outbound), tamb√©m atualiza a conversa para zerar contador ou mudar data\r\n    IF NEW.direction = 'outbound' THEN\r\n         INSERT INTO public.whatsapp_conversations (phone_number, organizacao_id, updated_at, last_message_direction)\r\n         VALUES (NEW.receiver_id, NEW.organizacao_id, NEW.sent_at, 'outbound')\r\n         ON CONFLICT (phone_number)\r\n         DO UPDATE SET \r\n            updated_at = EXCLUDED.updated_at,\r\n            last_message_direction = 'outbound';\r\n            -- N√£o altera unread_count aqui (ou zera se quiser ler automaticamente)\r\n    END IF;\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "handle_new_whatsapp_notification",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.handle_new_whatsapp_notification()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  v_owner_id uuid;\r\n  v_contact_name text;\r\n  v_message_preview text;\r\nBEGIN\r\n  -- Busca o dono\r\n  SELECT criado_por_usuario_id, nome\r\n  INTO v_owner_id, v_contact_name\r\n  FROM public.contatos\r\n  WHERE id = NEW.contato_id;\r\n\r\n  -- S√≥ tenta criar notifica√ß√£o se achou um ID v√°lido (UUID)\r\n  IF v_owner_id IS NOT NULL THEN\r\n    \r\n    v_message_preview := substring(NEW.content from 1 for 100);\r\n    IF length(NEW.content) > 100 THEN\r\n        v_message_preview := v_message_preview || '...';\r\n    END IF;\r\n\r\n    INSERT INTO public.notificacoes (\r\n      user_id,\r\n      organizacao_id,\r\n      titulo,\r\n      mensagem,\r\n      link,\r\n      lida,\r\n      tipo,\r\n      enviar_push,\r\n      icone,\r\n      created_at\r\n    ) VALUES (\r\n      v_owner_id,  -- Aqui entra o UUID certinho\r\n      NEW.organizacao_id,\r\n      'Nova mensagem de ' || COALESCE(v_contact_name, 'Lead'),\r\n      COALESCE(v_message_preview, 'M√≠dia recebida'),\r\n      '/chat',                 \r\n      false,\r\n      'whatsapp',\r\n      true,                    \r\n      'fa-brands fa-whatsapp',\r\n      now()\r\n    );\r\n  END IF;\r\n\r\n  RETURN NEW;\r\nEXCEPTION\r\n  WHEN OTHERS THEN\r\n    -- BLINDAGEM: Se der qualquer erro na notifica√ß√£o, IGNORA e deixa a mensagem entrar\r\n    RAISE WARNING 'Erro ao criar notifica√ß√£o ignorado para salvar mensagem: %', SQLERRM;\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "handle_pedido_entregue_estoque",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.handle_pedido_entregue_estoque()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    item_pedido RECORD; -- Vari√°vel para guardar cada item do pedido no loop\r\n    v_estoque_id bigint; -- Vari√°vel para guardar o ID do estoque (existente ou novo)\r\n    v_usuario_id uuid; -- Vari√°vel para guardar o ID do usu√°rio que alterou o status (se dispon√≠vel)\r\nBEGIN\r\n    -- Verifica se a atualiza√ß√£o foi para o status 'Entregue'\r\n    -- E se o status antigo era diferente de 'Entregue' (para n√£o rodar de novo se j√° estava entregue)\r\n    IF NEW.status = 'Entregue' AND OLD.status IS DISTINCT FROM 'Entregue' THEN\r\n\r\n        -- Tenta pegar o ID do usu√°rio que fez a altera√ß√£o (√∫til para auditoria)\r\n        -- Se n√£o conseguir, usa NULL (ajuste conforme sua necessidade de auditoria)\r\n        BEGIN\r\n            v_usuario_id := auth.uid();\r\n        EXCEPTION WHEN OTHERS THEN\r\n            v_usuario_id := NULL; -- Ou algum usu√°rio padr√£o do sistema\r\n        END;\r\n\r\n        -- Loop atrav√©s de cada item do pedido que foi atualizado (NEW.id)\r\n        FOR item_pedido IN\r\n            SELECT *\r\n            FROM public.pedidos_compra_itens pci\r\n            WHERE pci.pedido_compra_id = NEW.id\r\n        LOOP\r\n            -- Verifica se o item tem material_id e quantidade v√°lida\r\n            IF item_pedido.material_id IS NOT NULL AND item_pedido.quantidade_solicitada IS NOT NULL AND item_pedido.quantidade_solicitada > 0 THEN\r\n\r\n                -- Tenta inserir no estoque. Se j√° existir, atualiza a quantidade. (UPSERT)\r\n                INSERT INTO public.estoque (\r\n                    empreendimento_id,\r\n                    material_id,\r\n                    quantidade_atual,\r\n                    unidade_medida,\r\n                    organizacao_id,\r\n                    ultima_atualizacao\r\n                )\r\n                VALUES (\r\n                    NEW.empreendimento_id, -- Pega o empreendimento do pedido\r\n                    item_pedido.material_id,\r\n                    item_pedido.quantidade_solicitada,\r\n                    item_pedido.unidade_medida,\r\n                    NEW.organizacao_id, -- Pega a organiza√ß√£o do pedido\r\n                    now() -- Data/Hora atual\r\n                )\r\n                ON CONFLICT (empreendimento_id, material_id) -- Chave √∫nica para detectar conflito\r\n                DO UPDATE SET\r\n                    quantidade_atual = public.estoque.quantidade_atual + EXCLUDED.quantidade_atual, -- Soma a quantidade nova √† existente\r\n                    ultima_atualizacao = now()\r\n                RETURNING id INTO v_estoque_id; -- Salva o ID do estoque (novo ou atualizado) na vari√°vel\r\n\r\n                -- Registra a movimenta√ß√£o de entrada no estoque\r\n                INSERT INTO public.movimentacoes_estoque (\r\n                    estoque_id,\r\n                    tipo,\r\n                    quantidade,\r\n                    pedido_compra_id,\r\n                    usuario_id, -- ID do usu√°rio que alterou o status do pedido\r\n                    observacao,\r\n                    organizacao_id\r\n                )\r\n                VALUES (\r\n                    v_estoque_id, -- O ID que pegamos do UPSERT acima\r\n                    'Entrada por Compra', -- Tipo v√°lido\r\n                    item_pedido.quantidade_solicitada,\r\n                    NEW.id, -- ID do pedido de compra\r\n                    v_usuario_id, -- Usu√°rio que disparou a a√ß√£o (pode ser NULL)\r\n                    'Entrada autom√°tica via Pedido #' || NEW.id || ' (' || item_pedido.descricao_item || ')',\r\n                    NEW.organizacao_id -- Organiza√ß√£o do pedido\r\n                );\r\n\r\n            END IF; -- Fim da verifica√ß√£o do item_pedido\r\n\r\n        END LOOP; -- Fim do loop pelos itens\r\n\r\n    END IF; -- Fim da verifica√ß√£o do status 'Entregue'\r\n\r\n    RETURN NEW; -- Necess√°rio para triggers AFTER UPDATE\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "handle_updated_at",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.handle_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    NEW.updated_at = NOW();\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "hnsw_bit_support",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.hnsw_bit_support(internal)\n RETURNS internal\n LANGUAGE c\nAS '$libdir/vector', $function$hnsw_bit_support$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "hnsw_halfvec_support",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.hnsw_halfvec_support(internal)\n RETURNS internal\n LANGUAGE c\nAS '$libdir/vector', $function$hnsw_halfvec_support$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "hnsw_sparsevec_support",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.hnsw_sparsevec_support(internal)\n RETURNS internal\n LANGUAGE c\nAS '$libdir/vector', $function$hnsw_sparsevec_support$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "hnswhandler",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.hnswhandler(internal)\n RETURNS index_am_handler\n LANGUAGE c\nAS '$libdir/vector', $function$hnswhandler$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "importar_lancamentos_financeiros_com_transferencias",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.importar_lancamentos_financeiros_com_transferencias(p_novos_lancamentos jsonb, p_empresa_id bigint, p_usuario_id uuid)\n RETURNS TABLE(import_status text, details text, original_descricao text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    lancamento jsonb;\r\n    v_conta_origem_id bigint;\r\n    v_conta_destino_id bigint;\r\n    v_categoria_id bigint;\r\n    v_favorecido_id bigint;\r\n    v_empreendimento_id bigint;\r\n    v_data_transacao date;\r\n    v_valor numeric;\r\n    v_tipo text;\r\n    v_descricao text;\r\nBEGIN\r\n    -- Itera sobre cada novo registro enviado do arquivo\r\n    FOR lancamento IN SELECT * FROM jsonb_array_elements(p_novos_lancamentos)\r\n    LOOP\r\n        -- Extrai os IDs (j√° resolvidos pelo front-end)\r\n        v_conta_origem_id := (lancamento->>'conta_id')::bigint;\r\n        v_conta_destino_id := (lancamento->>'conta_destino_id')::bigint;\r\n        v_categoria_id := (lancamento->>'categoria_id')::bigint;\r\n        v_favorecido_id := (lancamento->>'favorecido_contato_id')::bigint;\r\n        v_empreendimento_id := (lancamento->>'empreendimento_id')::bigint;\r\n        v_data_transacao := (lancamento->>'data_transacao')::date;\r\n        v_valor := (lancamento->>'valor')::numeric;\r\n        v_tipo := lancamento->>'tipo';\r\n        v_descricao := lancamento->>'descricao';\r\n\r\n        -- CASO 1: √â UMA TRANSFER√äNCIA (quando conta_destino_id √© informado)\r\n        IF v_conta_destino_id IS NOT NULL THEN\r\n            -- VERIFICA SE A TRANSFER√äNCIA J√Å EXISTE (a sa√≠da ou a entrada)\r\n            IF NOT EXISTS (\r\n                SELECT 1 FROM public.lancamentos\r\n                WHERE tipo = 'Transfer√™ncia'\r\n                AND data_transacao = v_data_transacao\r\n                AND valor = v_valor\r\n                AND (\r\n                    (conta_id = v_conta_origem_id AND conta_destino_id = v_conta_destino_id)\r\n                    OR\r\n                    (conta_id = v_conta_destino_id AND conta_destino_id = v_conta_origem_id)\r\n                )\r\n            ) THEN\r\n                -- Se n√£o existe, INSERE OS DOIS LAN√áAMENTOS\r\n                INSERT INTO public.lancamentos (descricao, valor, data_transacao, tipo, status, conta_id, conta_destino_id, empresa_id, criado_por_usuario_id)\r\n                VALUES (v_descricao, v_valor, v_data_transacao, 'Transfer√™ncia', 'Pago', v_conta_origem_id, v_conta_destino_id, p_empresa_id, p_usuario_id);\r\n\r\n                import_status := 'Sucesso (Transfer√™ncia)';\r\n                details := 'Sa√≠da e Entrada criadas.';\r\n\r\n            ELSE\r\n                -- Se a transfer√™ncia j√° existe, marca como ignorada\r\n                import_status := 'Ignorado (Duplicado)';\r\n                details := 'Transfer√™ncia j√° registrada anteriormente.';\r\n            END IF;\r\n\r\n        -- CASO 2: N√ÉO √â TRANSFER√äNCIA\r\n        ELSE\r\n            INSERT INTO public.lancamentos (descricao, valor, data_transacao, tipo, status, conta_id, categoria_id, favorecido_contato_id, empreendimento_id, empresa_id, criado_por_usuario_id)\r\n            VALUES (v_descricao, v_valor, v_data_transacao, v_tipo, 'Pago', v_conta_origem_id, v_categoria_id, v_favorecido_id, v_empreendimento_id, p_empresa_id, p_usuario_id);\r\n            \r\n            import_status := 'Sucesso';\r\n            details := 'Lan√ßamento padr√£o importado.';\r\n        END IF;\r\n\r\n        original_descricao := v_descricao;\r\n        RETURN NEXT;\r\n\r\n    END LOOP;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "importar_registros_ponto_se_vazio",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.importar_registros_ponto_se_vazio(novos_registros jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    registro jsonb;\r\n    dia_registro date;\r\n    tipo_registro_txt text;\r\n    funcionario_id_int bigint;\r\n    ponto_existente int;\r\nBEGIN\r\n    -- Itera sobre cada registro de ponto enviado pelo frontend\r\n    FOR registro IN SELECT * FROM jsonb_array_elements(novos_registros)\r\n    LOOP\r\n        -- Extrai os dados de cada registro\r\n        dia_registro := (registro->>'data_hora')::date;\r\n        tipo_registro_txt := registro->>'tipo_registro';\r\n        funcionario_id_int := (registro->>'funcionario_id')::bigint;\r\n\r\n        -- Verifica se j√° existe uma batida daquele tipo, para aquele funcion√°rio, naquele dia\r\n        SELECT count(*)\r\n        INTO ponto_existente\r\n        FROM public.pontos p\r\n        WHERE p.funcionario_id = funcionario_id_int\r\n          AND p.tipo_registro = tipo_registro_txt\r\n          AND p.data_hora::date = dia_registro;\r\n\r\n        -- Se o campo estiver vazio (n√£o existe batida), insere o novo registro\r\n        IF ponto_existente = 0 THEN\r\n            INSERT INTO public.pontos (\r\n                funcionario_id,\r\n                data_hora,\r\n                tipo_registro,\r\n                observacao,\r\n                organizacao_id -- <-- O campo de seguran√ßa\r\n            )\r\n            VALUES (\r\n                (registro->>'funcionario_id')::bigint,\r\n                (registro->>'data_hora')::timestamp,\r\n                (registro->>'tipo_registro')::text,\r\n                (registro->>'observacao')::text,\r\n                (registro->>'organizacao_id')::bigint -- <-- O valor de seguran√ßa, agora lido do payload\r\n            );\r\n        END IF;\r\n    END LOOP;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "inner_product",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.inner_product(halfvec, halfvec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_inner_product$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "inner_product",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.inner_product(sparsevec, sparsevec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_inner_product$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "inner_product",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.inner_product(vector, vector)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$inner_product$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "ivfflat_bit_support",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.ivfflat_bit_support(internal)\n RETURNS internal\n LANGUAGE c\nAS '$libdir/vector', $function$ivfflat_bit_support$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "ivfflat_halfvec_support",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.ivfflat_halfvec_support(internal)\n RETURNS internal\n LANGUAGE c\nAS '$libdir/vector', $function$ivfflat_halfvec_support$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "ivfflathandler",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.ivfflathandler(internal)\n RETURNS index_am_handler\n LANGUAGE c\nAS '$libdir/vector', $function$ivfflathandler$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "jaccard_distance",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.jaccard_distance(bit, bit)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$jaccard_distance$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "jsonb_to_bigint_array",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.jsonb_to_bigint_array(p_json jsonb)\n RETURNS bigint[]\n LANGUAGE sql\n IMMUTABLE\nAS $function$\r\n  select array_agg(elem::text::bigint)\r\n  from jsonb_array_elements(p_json) as elem\r\n  where elem::text <> '\"IS_NULL\"' and elem::text <> 'IS_NULL';\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "jsonb_to_text_array",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.jsonb_to_text_array(p_json jsonb)\n RETURNS text[]\n LANGUAGE sql\n IMMUTABLE\nAS $function$\r\n  select array_agg(elem::text)\r\n  from jsonb_array_elements_text(p_json) as elem;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "l1_distance",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.l1_distance(halfvec, halfvec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_l1_distance$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "l1_distance",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.l1_distance(vector, vector)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$l1_distance$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "l1_distance",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.l1_distance(sparsevec, sparsevec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_l1_distance$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "l2_distance",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.l2_distance(halfvec, halfvec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_l2_distance$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "l2_distance",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.l2_distance(sparsevec, sparsevec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_l2_distance$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "l2_distance",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.l2_distance(vector, vector)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$l2_distance$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "l2_norm",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.l2_norm(halfvec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_l2_norm$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "l2_norm",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.l2_norm(sparsevec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_l2_norm$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "l2_normalize",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.l2_normalize(vector)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$l2_normalize$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "l2_normalize",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.l2_normalize(halfvec)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_l2_normalize$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "l2_normalize",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.l2_normalize(sparsevec)\n RETURNS sparsevec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_l2_normalize$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "limpar_conversas_duplicadas",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.limpar_conversas_duplicadas()\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    r_grupo RECORD;\r\n    v_vencedor_id bigint;\r\n    v_ids_perdedores bigint[];\r\n    v_total_unificados int := 0;\r\nBEGIN\r\n    -- 1. Encontrar grupos de n√∫meros que s√£o iguais (ex: com e sem 55)\r\n    FOR r_grupo IN\r\n        WITH numeros_limpos AS (\r\n            SELECT \r\n                id, \r\n                phone_number,\r\n                contato_id,\r\n                -- Normaliza: Se for BR, pega os √∫ltimos 8 d√≠gitos. Se for gringo, pega tudo.\r\n                CASE \r\n                    WHEN phone_number LIKE '55%' OR length(phone_number) BETWEEN 12 AND 13 \r\n                    THEN RIGHT(REGEXP_REPLACE(phone_number, '\\D', '', 'g'), 8)\r\n                    ELSE REGEXP_REPLACE(phone_number, '\\D', '', 'g')\r\n                END as final_numero\r\n            FROM public.whatsapp_conversations\r\n        )\r\n        SELECT \r\n            final_numero,\r\n            -- O Vencedor √© o n√∫mero mais longo (mais completo) e mais antigo\r\n            ARRAY_AGG(id ORDER BY length(phone_number) DESC, id ASC) as ids\r\n        FROM numeros_limpos\r\n        GROUP BY final_numero\r\n        HAVING COUNT(*) > 1\r\n    LOOP\r\n        -- Define quem fica e quem sai\r\n        v_vencedor_id := r_grupo.ids[1];\r\n        v_ids_perdedores := r_grupo.ids[2:array_length(r_grupo.ids, 1)];\r\n\r\n        -- A. Move as mensagens dos perdedores para o vencedor\r\n        UPDATE public.whatsapp_messages\r\n        SET conversation_record_id = v_vencedor_id\r\n        WHERE conversation_record_id = ANY(v_ids_perdedores);\r\n\r\n        -- B. Se o vencedor n√£o tem Dono (contato_id), herda de um perdedor\r\n        UPDATE public.whatsapp_conversations v\r\n        SET contato_id = (\r\n            SELECT p.contato_id \r\n            FROM public.whatsapp_conversations p \r\n            WHERE p.id = ANY(v_ids_perdedores) \r\n            AND p.contato_id IS NOT NULL \r\n            LIMIT 1\r\n        )\r\n        WHERE v.id = v_vencedor_id AND v.contato_id IS NULL;\r\n\r\n        -- C. Remove os perdedores do mapa\r\n        DELETE FROM public.whatsapp_conversations\r\n        WHERE id = ANY(v_ids_perdedores);\r\n\r\n        v_total_unificados := v_total_unificados + 1;\r\n    END LOOP;\r\n\r\n    RETURN 'Sucesso! ' || v_total_unificados || ' grupos de conversas foram unificados.';\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "link_contato_to_whatsapp_message",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.link_contato_to_whatsapp_message()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    found_contato_id BIGINT;\r\nBEGIN\r\n    -- S√≥ executa a l√≥gica se for uma mensagem RECEBIDA (inbound) e se o contato_id estiver VAZIO.\r\n    IF NEW.contato_id IS NULL AND NEW.direction = 'inbound' THEN\r\n\r\n        -- Procura na tabela 'telefones' por um n√∫mero correspondente.\r\n        -- A fun√ß√£o regexp_replace('...', '\\D', '', 'g') remove todos os caracteres n√£o num√©ricos,\r\n        -- garantindo que a gente consiga comparar '5533991912291' com '(33) 99191-2291'.\r\n        SELECT T.contato_id INTO found_contato_id\r\n        FROM public.telefones T\r\n        WHERE regexp_replace(T.telefone, '\\D', '', 'g') = regexp_replace(NEW.sender_id, '\\D', '', 'g')\r\n        LIMIT 1;\r\n\r\n        -- Se um contato_id correspondente foi encontrado, atualiza a nova mensagem ANTES de ela ser salva.\r\n        IF found_contato_id IS NOT NULL THEN\r\n            NEW.contato_id := found_contato_id;\r\n        END IF;\r\n\r\n    END IF;\r\n\r\n    -- Retorna a nova linha (com o contato_id preenchido, se encontrado) para ser inserida na tabela.\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "link_funcionario_e_contato",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.link_funcionario_e_contato(p_funcionario_id bigint)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_contato_id bigint;\r\n    v_funcionario_cpf text;\r\nBEGIN\r\n    -- 1. Pega o CPF do funcion√°rio.\r\n    SELECT cpf INTO v_funcionario_cpf FROM public.funcionarios WHERE id = p_funcionario_id;\r\n\r\n    IF v_funcionario_cpf IS NULL THEN\r\n        RETURN 'Erro: Funcion√°rio n√£o possui CPF para realizar a busca.';\r\n    END IF;\r\n\r\n    -- 2. Encontra o ID do contato que possui o mesmo CPF.\r\n    SELECT id INTO v_contato_id FROM public.contatos WHERE cpf = v_funcionario_cpf LIMIT 1;\r\n\r\n    -- 3. Se encontrou um contato, atualiza o funcion√°rio com o ID do contato.\r\n    IF v_contato_id IS NOT NULL THEN\r\n        UPDATE public.funcionarios\r\n        SET contato_id = v_contato_id\r\n        WHERE id = p_funcionario_id;\r\n        \r\n        RETURN 'Sucesso: Funcion√°rio ID ' || p_funcionario_id || ' foi vinculado ao Contato ID ' || v_contato_id;\r\n    ELSE\r\n        RETURN 'Aviso: Nenhum contato encontrado com o CPF ' || v_funcionario_cpf;\r\n    END IF;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "manutencao_provisionamento_salarial",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.manutencao_provisionamento_salarial()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_funcionario record;\r\n    v_mes_a_provisionar date;\r\nBEGIN\r\n    -- Define o m√™s a ser criado (o 12¬∫ m√™s a partir de hoje, ou seja, 11 meses no futuro)\r\n    v_mes_a_provisionar := (date_trunc('month', NOW()) + '11 months'::interval)::date;\r\n\r\n    -- Itera sobre todos os funcion√°rios que n√£o foram demitidos\r\n    FOR v_funcionario IN SELECT id, full_name FROM public.funcionarios WHERE demission_date IS NULL\r\n    LOOP\r\n        -- Verifica se a provis√£o para este funcion√°rio e este m√™s futuro j√° n√£o existe\r\n        IF NOT EXISTS (\r\n            SELECT 1 FROM public.lancamentos \r\n            WHERE funcionario_id = v_funcionario.id\r\n              AND mes_competencia = v_mes_a_provisionar\r\n        ) THEN\r\n            -- Se n√£o existe, cria a provis√£o\r\n            PERFORM public.agendar_salario_provisionado(v_funcionario.id, v_mes_a_provisionar);\r\n        END IF;\r\n    END LOOP;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "marcar_pedido_entregue",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.marcar_pedido_entregue(p_pedido_id bigint, p_usuario_id uuid)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Chama a fun√ß√£o que j√° criamos para registrar o hist√≥rico\r\n    -- e atualizar o status do pedido para 'Entregue'.\r\n    PERFORM public.atualizar_status_pedido(p_pedido_id, 'Entregue', p_usuario_id);\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "marcar_pedido_entregue",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.marcar_pedido_entregue(p_pedido_id bigint, p_usuario_id uuid, p_organizacao_id bigint)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_empreendimento_id bigint;\r\n    v_data_entrega_prevista date;\r\nBEGIN\r\n    -- 1. Atualiza o status do pedido para 'Entregue'.\r\n    -- CORRE√á√ÉO: Removida a coluna 'data_entrega_real' que n√£o existe.\r\n    UPDATE public.pedidos_compra\r\n    SET\r\n        status = 'Entregue'\r\n    WHERE\r\n        id = p_pedido_id AND organizacao_id = p_organizacao_id\r\n    RETURNING empreendimento_id, data_entrega_prevista INTO v_empreendimento_id, v_data_entrega_prevista;\r\n\r\n    -- 2. Cria uma atividade para registrar o evento da entrega.\r\n    IF v_empreendimento_id IS NOT NULL THEN\r\n        INSERT INTO public.activities (\r\n            nome,\r\n            tipo_atividade,\r\n            status,\r\n            data_inicio_prevista,\r\n            data_fim_prevista,\r\n            data_fim_real,\r\n            empreendimento_id,\r\n            criado_por_usuario_id, -- CORRE√á√ÉO: Nome da coluna ajustado de 'usuario_responsavel_id'\r\n            organizacao_id\r\n        )\r\n        VALUES (\r\n            'Entrega Pedido #' || p_pedido_id,\r\n            'Entrega de Pedido',\r\n            'Conclu√≠do',\r\n            v_data_entrega_prevista,\r\n            v_data_entrega_prevista,\r\n            CURRENT_DATE,\r\n            v_empreendimento_id,\r\n            p_usuario_id,\r\n            p_organizacao_id\r\n        );\r\n    END IF;\r\n\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "match_documento_empreendimento",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.match_documento_empreendimento(query_embedding vector, match_threshold double precision, match_count integer, p_empreendimento_id bigint)\n RETURNS TABLE(id uuid, content text, similarity double precision)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT\r\n    ede.id,\r\n    ede.content,\r\n    1 - (ede.embedding <=> query_embedding) as similarity\r\n  FROM\r\n    empreendimento_documento_embeddings AS ede\r\n  JOIN\r\n    empreendimento_anexos AS ea ON ede.anexo_id = ea.id\r\n  WHERE\r\n    ea.empreendimento_id = p_empreendimento_id\r\n    AND ea.usar_para_pesquisa = TRUE  -- AQUI EST√Å A NOVA REGRA!\r\n    AND 1 - (ede.embedding <=> query_embedding) > match_threshold\r\n  ORDER BY\r\n    similarity DESC\r\n  LIMIT\r\n    match_count;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "merge_contacts_and_relink_all_references",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.merge_contacts_and_relink_all_references(p_primary_contact_id bigint, p_secondary_contact_ids bigint[], p_final_data jsonb, p_final_telefones jsonb, p_final_emails jsonb, p_organizacao_id bigint)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    secondary_id bigint;\r\nBEGIN\r\n    -- 1. ATUALIZAR DADOS DO VENCEDOR (Com os dados escolhidos no Modal)\r\n    UPDATE contatos\r\n    SET \r\n        nome = COALESCE((p_final_data->>'nome'), nome),\r\n        razao_social = COALESCE((p_final_data->>'razao_social'), razao_social),\r\n        cpf = COALESCE((p_final_data->>'cpf'), cpf),\r\n        cnpj = COALESCE((p_final_data->>'cnpj'), cnpj),\r\n        rg = COALESCE((p_final_data->>'rg'), rg),\r\n        -- CORRE√á√ÉO AQUI: Convertendo explicitamente para o tipo ENUM correto\r\n        tipo_contato = COALESCE((p_final_data->>'tipo_contato')::public.tipo_contato_enum, tipo_contato),\r\n        estado_civil = COALESCE((p_final_data->>'estado_civil'), estado_civil),\r\n        cargo = COALESCE((p_final_data->>'cargo'), cargo),\r\n        address_street = COALESCE((p_final_data->>'address_street'), address_street),\r\n        address_number = COALESCE((p_final_data->>'address_number'), address_number),\r\n        address_complement = COALESCE((p_final_data->>'address_complement'), address_complement),\r\n        neighborhood = COALESCE((p_final_data->>'neighborhood'), neighborhood),\r\n        city = COALESCE((p_final_data->>'city'), city),\r\n        state = COALESCE((p_final_data->>'state'), state),\r\n        cep = COALESCE((p_final_data->>'cep'), cep)\r\n    WHERE id = p_primary_contact_id;\r\n\r\n    -- 2. REFAZER TELEFONES (Remove os atuais e insere a lista final limpa do Modal)\r\n    DELETE FROM telefones WHERE contato_id = p_primary_contact_id;\r\n    \r\n    IF jsonb_array_length(p_final_telefones) > 0 THEN\r\n        INSERT INTO telefones (contato_id, telefone, tipo, country_code, organizacao_id)\r\n        SELECT \r\n            p_primary_contact_id, \r\n            t->>'telefone', \r\n            COALESCE(t->>'tipo', 'Celular'), \r\n            COALESCE(t->>'country_code', '+55'), \r\n            p_organizacao_id\r\n        FROM jsonb_array_elements(p_final_telefones) as t;\r\n    END IF;\r\n\r\n    -- 3. REFAZER EMAILS\r\n    DELETE FROM emails WHERE contato_id = p_primary_contact_id;\r\n    \r\n    IF jsonb_array_length(p_final_emails) > 0 THEN\r\n        INSERT INTO emails (contato_id, email, tipo, organizacao_id)\r\n        SELECT \r\n            p_primary_contact_id, \r\n            e->>'email', \r\n            COALESCE(e->>'tipo', 'Pessoal'), \r\n            p_organizacao_id\r\n        FROM jsonb_array_elements(p_final_emails) as e;\r\n    END IF;\r\n\r\n    -- 4. PROCESSAR OS CONTATOS SECUND√ÅRIOS (Relinkar refer√™ncias com BLINDAGEM)\r\n    FOREACH secondary_id IN ARRAY p_secondary_contact_ids LOOP\r\n        \r\n        -- A. BLINDAGEM: LISTAS DE WHATSAPP (Evita erro unique_contato_na_lista)\r\n        -- Copia s√≥ o que o vencedor N√ÉO tem.\r\n        INSERT INTO whatsapp_list_members (lista_id, contato_id)\r\n        SELECT lista_id, p_primary_contact_id\r\n        FROM whatsapp_list_members\r\n        WHERE contato_id = secondary_id\r\n        AND NOT EXISTS (\r\n            SELECT 1 FROM whatsapp_list_members existing\r\n            WHERE existing.contato_id = p_primary_contact_id\r\n            AND existing.lista_id = whatsapp_list_members.lista_id\r\n        );\r\n        -- Apaga do secund√°rio para liberar\r\n        DELETE FROM whatsapp_list_members WHERE contato_id = secondary_id;\r\n\r\n        -- B. BLINDAGEM: FUNIL DE VENDAS\r\n        -- Se o vencedor j√° tem card, deleta o do secund√°rio. Se n√£o, move.\r\n        IF EXISTS (SELECT 1 FROM contatos_no_funil WHERE contato_id = p_primary_contact_id) THEN\r\n            DELETE FROM contatos_no_funil WHERE contato_id = secondary_id;\r\n        ELSE\r\n            UPDATE contatos_no_funil SET contato_id = p_primary_contact_id WHERE contato_id = secondary_id;\r\n        END IF;\r\n\r\n        -- C. MOVER O RESTO (Conversas, Mensagens, Notas, etc)\r\n        UPDATE whatsapp_conversations SET contato_id = p_primary_contact_id WHERE contato_id = secondary_id;\r\n        UPDATE whatsapp_messages SET contato_id = p_primary_contact_id WHERE contato_id = secondary_id;\r\n        \r\n        BEGIN UPDATE crm_notas SET contato_id = p_primary_contact_id WHERE contato_id = secondary_id; EXCEPTION WHEN OTHERS THEN NULL; END;\r\n        BEGIN UPDATE whatsapp_attachments SET contato_id = p_primary_contact_id WHERE contato_id = secondary_id; EXCEPTION WHEN OTHERS THEN NULL; END;\r\n        \r\n        -- D. TCHAU SECUND√ÅRIO üëã\r\n        DELETE FROM contatos WHERE id = secondary_id;\r\n        -- Limpeza final de tabelas dependentes\r\n        DELETE FROM telefones WHERE contato_id = secondary_id; \r\n        DELETE FROM emails WHERE contato_id = secondary_id;\r\n\r\n    END LOOP;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "merge_contacts_and_relink_all_references",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.merge_contacts_and_relink_all_references(p_primary_contact_id bigint, p_secondary_contact_ids bigint[], p_final_data jsonb, p_final_telefones jsonb[], p_final_emails jsonb[])\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    secondary_id bigint;\r\nBEGIN\r\n    -- Etapa 1: \"Transferir a Heran√ßa\"\r\n    FOREACH secondary_id IN ARRAY p_secondary_contact_ids\r\n    LOOP\r\n        UPDATE public.simulacoes SET corretor_id = p_primary_contact_id WHERE corretor_id = secondary_id;\r\n        UPDATE public.simulacoes SET contato_id = p_primary_contact_id WHERE contato_id = secondary_id;\r\n        UPDATE public.contratos SET corretor_id = p_primary_contact_id WHERE corretor_id = secondary_id;\r\n        UPDATE public.contratos SET contato_id = p_primary_contact_id WHERE contato_id = secondary_id;\r\n        UPDATE public.lancamentos SET favorecido_contato_id = p_primary_contact_id WHERE favorecido_contato_id = secondary_id;\r\n        UPDATE public.contatos_no_funil SET corretor_id = p_primary_contact_id WHERE corretor_id = secondary_id;\r\n        UPDATE public.contatos_no_funil SET contato_id = p_primary_contact_id WHERE contato_id = secondary_id;\r\n        UPDATE public.crm_notas SET contato_id = p_primary_contact_id WHERE contato_id = secondary_id;\r\n        UPDATE public.activities SET contato_id = p_primary_contact_id WHERE contato_id = secondary_id;\r\n        UPDATE public.funcionarios SET contato_id = p_primary_contact_id WHERE contato_id = secondary_id;\r\n        UPDATE public.pedidos_compra_itens SET fornecedor_id = p_primary_contact_id WHERE fornecedor_id = secondary_id;\r\n        UPDATE public.whatsapp_messages SET contato_id = p_primary_contact_id WHERE contato_id = secondary_id;\r\n        UPDATE public.whatsapp_conversations SET contato_id = p_primary_contact_id WHERE contato_id = secondary_id;\r\n    END LOOP;\r\n\r\n    -- Etapa 2: Atualizar os dados do contato principal\r\n    UPDATE public.contatos\r\n    SET\r\n        nome = p_final_data->>'nome',\r\n        razao_social = p_final_data->>'razao_social',\r\n        cpf = p_final_data->>'cpf',\r\n        cnpj = p_final_data->>'cnpj',\r\n        -- ***** AQUI EST√Å A CORRE√á√ÉO DA CORRE√á√ÉO :) *****\r\n        -- Usando o nome completo e correto do tipo: tipo_contato_enum\r\n        tipo_contato = (p_final_data->>'tipo_contato')::public.tipo_contato_enum\r\n    WHERE id = p_primary_contact_id;\r\n\r\n    -- Etapa 3: Limpar e reinserir telefones e e-mails\r\n    DELETE FROM public.telefones WHERE contato_id = p_primary_contact_id;\r\n    DELETE FROM public.emails WHERE contato_id = p_primary_contact_id;\r\n\r\n    IF array_length(p_final_telefones, 1) > 0 THEN\r\n        INSERT INTO public.telefones (contato_id, telefone, country_code)\r\n        SELECT p_primary_contact_id, (elem->>'telefone')::text, (elem->>'country_code')::text FROM jsonb_array_elements(array_to_json(p_final_telefones)::jsonb) elem;\r\n    END IF;\r\n\r\n    IF array_length(p_final_emails, 1) > 0 THEN\r\n        INSERT INTO public.emails (contato_id, email)\r\n        SELECT p_primary_contact_id, (elem->>'email')::text FROM jsonb_array_elements(array_to_json(p_final_emails)::jsonb) elem;\r\n    END IF;\r\n\r\n    -- Etapa 4: Excluir os contatos secund√°rios\r\n    DELETE FROM public.contatos WHERE id = ANY(p_secondary_contact_ids);\r\n\r\n    RETURN 'Contatos mesclados com sucesso! Todas as refer√™ncias foram atualizadas.';\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "merge_contatos_manualmente",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.merge_contatos_manualmente(p_primary_contact_id bigint, p_secondary_contact_ids bigint[], p_final_data jsonb, p_final_telefones jsonb, p_final_emails jsonb)\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\ndeclare\r\n  secondary_id bigint;\r\nbegin\r\n  -- Atualiza o contato principal com os dados finais escolhidos pelo usu√°rio\r\n  update public.contatos\r\n  set\r\n    nome = p_final_data->>'nome',\r\n    razao_social = p_final_data->>'razao_social',\r\n    cpf = p_final_data->>'cpf',\r\n    cnpj = p_final_data->>'cnpj',\r\n    -- ##### CORRE√á√ÉO AQUI: Converte o texto para o tipo enum correto #####\r\n    tipo_contato = (p_final_data->>'tipo_contato')::public.tipo_contato_enum\r\n    -- Adicionar outros campos aqui se necess√°rio\r\n  where id = p_primary_contact_id;\r\n\r\n  -- Deleta todos os telefones e emails antigos do contato principal\r\n  delete from public.telefones where contato_id = p_primary_contact_id;\r\n  delete from public.emails where contato_id = p_primary_contact_id;\r\n\r\n  -- Insere os novos telefones e emails finais escolhidos pelo usu√°rio\r\n  if jsonb_array_length(p_final_telefones) > 0 then\r\n    insert into public.telefones (contato_id, telefone, tipo)\r\n    select p_primary_contact_id, (t->>'telefone'), 'Principal' from jsonb_array_elements(p_final_telefones) as t;\r\n  end if;\r\n  \r\n  if jsonb_array_length(p_final_emails) > 0 then\r\n    insert into public.emails (contato_id, email, tipo)\r\n    select p_primary_contact_id, (e->>'email'), 'Principal' from jsonb_array_elements(p_final_emails) as e;\r\n  end if;\r\n\r\n  -- Loop para re-parentar registros dos contatos secund√°rios para o principal\r\n  foreach secondary_id in array p_secondary_contact_ids\r\n  loop\r\n    update public.contatos_no_funil set contato_id = p_primary_contact_id where contato_id = secondary_id;\r\n    update public.crm_notas set contato_id = p_primary_contact_id where contato_id = secondary_id;\r\n    update public.activities set contato_id = p_primary_contact_id where contato_id = secondary_id;\r\n    update public.contratos set contato_id = p_primary_contact_id where contato_id = secondary_id;\r\n    update public.contratos set corretor_id = p_primary_contact_id where corretor_id = secondary_id;\r\n    update public.lancamentos set favorecido_contato_id = p_primary_contact_id where favorecido_contato_id = secondary_id;\r\n    update public.funcionarios set contato_id = p_primary_contact_id where contato_id = secondary_id;\r\n    \r\n    -- Finalmente, deleta o contato secund√°rio\r\n    delete from public.contatos where id = secondary_id;\r\n  end loop;\r\n\r\n  return 'Contatos mesclados com sucesso no ID ' || p_primary_contact_id;\r\nend;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "mover_contato_e_atualizar_produto",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.mover_contato_e_atualizar_produto(p_contato_no_funil_id uuid, p_nova_coluna_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_produto_id BIGINT;\r\n    v_nova_coluna_nome TEXT;\r\nBEGIN\r\n    -- 1. Atualiza a coluna do contato no funil\r\n    UPDATE public.contatos_no_funil\r\n    SET coluna_id = p_nova_coluna_id, updated_at = NOW()\r\n    WHERE id = p_contato_no_funil_id\r\n    RETURNING produto_id INTO v_produto_id;\r\n\r\n    -- 2. Busca o nome da nova coluna\r\n    SELECT nome INTO v_nova_coluna_nome\r\n    FROM public.colunas_funil\r\n    WHERE id = p_nova_coluna_id;\r\n\r\n    -- 3. Se a nova coluna for 'Vendido' e houver um produto associado, atualiza o status do produto\r\n    IF v_nova_coluna_nome = 'Vendido' AND v_produto_id IS NOT NULL THEN\r\n        UPDATE public.produtos_empreendimento\r\n        SET status = 'Vendido'\r\n        WHERE id = v_produto_id;\r\n    END IF;\r\n\r\n    -- Retorna 'true' para indicar que a opera√ß√£o foi bem-sucedida\r\n    RETURN TRUE;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "normalizar_telefone",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.normalizar_telefone(telefone_bruto text)\n RETURNS text\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\r\nBEGIN\r\n  -- Retorna NULL se a entrada for nula para evitar erros\r\n  IF telefone_bruto IS NULL THEN\r\n    RETURN NULL;\r\n  END IF;\r\n  RETURN REGEXP_REPLACE(telefone_bruto, '\\D', '', 'g');\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "obter_faixa_inss",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.obter_faixa_inss(salario_base numeric)\n RETURNS numeric\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    IF salario_base <= 1412.00 THEN\r\n        RETURN 7.5;\r\n    ELSIF salario_base <= 2666.68 THEN\r\n        RETURN 9.0;\r\n    ELSIF salario_base <= 4000.03 THEN\r\n        RETURN 12.0;\r\n    ELSE\r\n        RETURN 14.0;\r\n    END IF;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "obter_resumo_financeiro",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.obter_resumo_financeiro(p_organizacao_id bigint, p_filtros jsonb)\n RETURNS TABLE(tipo_lancamento text, status_lancamento text, valor_total numeric)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_query text;\r\nBEGIN\r\n    -- Come√ßa a query base filtrando pela organiza√ß√£o\r\n    v_query := 'SELECT tipo, status, SUM(valor) as valor_total FROM lancamentos WHERE organizacao_id = ' || p_organizacao_id;\r\n\r\n    -- 1. Filtro de Transfer√™ncias (Ignorar)\r\n    IF (p_filtros->>'ignoreTransfers')::boolean IS TRUE THEN\r\n        v_query := v_query || ' AND transferencia_id IS NULL';\r\n    END IF;\r\n\r\n    -- 2. Filtro de Busca Textual (Descri√ß√£o)\r\n    IF (p_filtros->>'searchTerm') IS NOT NULL AND (p_filtros->>'searchTerm') <> '' THEN\r\n        v_query := v_query || ' AND descricao ILIKE ''%' || (p_filtros->>'searchTerm') || '%''';\r\n    END IF;\r\n\r\n    -- 3. Filtro de Datas (Vencimento)\r\n    IF (p_filtros->>'startDate') IS NOT NULL AND (p_filtros->>'startDate') <> '' THEN\r\n        v_query := v_query || ' AND data_vencimento >= ''' || (p_filtros->>'startDate') || '''::date';\r\n    END IF;\r\n    IF (p_filtros->>'endDate') IS NOT NULL AND (p_filtros->>'endDate') <> '' THEN\r\n        v_query := v_query || ' AND data_vencimento <= ''' || (p_filtros->>'endDate') || '''::date';\r\n    END IF;\r\n\r\n    -- 4. Filtros de M√∫ltipla Sele√ß√£o (Arrays)\r\n    -- Contas\r\n    IF jsonb_array_length(p_filtros->'contaIds') > 0 THEN\r\n        v_query := v_query || ' AND conta_id IN (SELECT (jsonb_array_elements_text(''' || (p_filtros->'contaIds') || '''::jsonb))::bigint)';\r\n    END IF;\r\n    -- Categorias\r\n    IF jsonb_array_length(p_filtros->'categoriaIds') > 0 THEN\r\n        v_query := v_query || ' AND categoria_id IN (SELECT (jsonb_array_elements_text(''' || (p_filtros->'categoriaIds') || '''::jsonb))::bigint)';\r\n    END IF;\r\n    -- Empresas\r\n    IF jsonb_array_length(p_filtros->'empresaIds') > 0 THEN\r\n        v_query := v_query || ' AND empresa_id IN (SELECT (jsonb_array_elements_text(''' || (p_filtros->'empresaIds') || '''::jsonb))::bigint)';\r\n    END IF;\r\n    -- Empreendimentos\r\n    IF jsonb_array_length(p_filtros->'empreendimentoIds') > 0 THEN\r\n        v_query := v_query || ' AND empreendimento_id IN (SELECT (jsonb_array_elements_text(''' || (p_filtros->'empreendimentoIds') || '''::jsonb))::bigint)';\r\n    END IF;\r\n    -- Favorecido\r\n    IF (p_filtros->>'favorecidoId') IS NOT NULL THEN\r\n        v_query := v_query || ' AND favorecido_contato_id = ' || (p_filtros->>'favorecidoId');\r\n    END IF;\r\n\r\n    -- 5. Filtro de Status (A L√≥gica Poderosa aqui!)\r\n    IF jsonb_array_length(p_filtros->'status') > 0 THEN\r\n        v_query := v_query || ' AND (';\r\n        \r\n        -- L√≥gica para 'Pago'\r\n        IF p_filtros->'status' @> '\"Pago\"'::jsonb OR p_filtros->'status' @> '\"Conciliado\"'::jsonb THEN\r\n             v_query := v_query || ' status IN (''Pago'', ''Conciliado'')';\r\n        END IF;\r\n\r\n        -- Conector OR se tiver multiplos status selecionados\r\n        IF (p_filtros->'status' @> '\"Pago\"'::jsonb OR p_filtros->'status' @> '\"Conciliado\"'::jsonb) \r\n           AND (p_filtros->'status' @> '\"Pendente\"'::jsonb OR p_filtros->'status' @> '\"Atrasada\"'::jsonb) THEN\r\n            v_query := v_query || ' OR ';\r\n        END IF;\r\n\r\n        -- L√≥gica para 'Pendente' (Geral)\r\n        IF p_filtros->'status' @> '\"Pendente\"'::jsonb THEN\r\n             v_query := v_query || ' status = ''Pendente''';\r\n        \r\n        -- L√≥gica para 'Atrasada' (Espec√≠fico: Pendente E Vencido)\r\n        ELSIF p_filtros->'status' @> '\"Atrasada\"'::jsonb THEN\r\n             v_query := v_query || ' (status = ''Pendente'' AND data_vencimento < CURRENT_DATE)';\r\n        END IF;\r\n\r\n        v_query := v_query || ')';\r\n    END IF;\r\n    \r\n    -- 6. Filtro de Tipo (Receita/Despesa)\r\n    IF jsonb_array_length(p_filtros->'tipo') > 0 THEN\r\n        v_query := v_query || ' AND tipo IN (SELECT jsonb_array_elements_text(''' || (p_filtros->'tipo') || '''::jsonb))';\r\n    END IF;\r\n\r\n    -- Agrupamento Final\r\n    v_query := v_query || ' GROUP BY tipo, status';\r\n\r\n    RETURN QUERY EXECUTE v_query;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "pagar_descontar_saldo_banco_horas",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.pagar_descontar_saldo_banco_horas(p_funcionario_id bigint, p_mes_referencia_str text, p_saldo_minutos integer)\n RETURNS TABLE(success boolean, message text)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_valor_diaria NUMERIC;\r\n    v_carga_horaria NUMERIC;\r\n    v_valor_hora NUMERIC;\r\n    v_valor_ajuste NUMERIC;\r\n    v_tipo_lancamento TEXT;\r\n    v_categoria_id BIGINT;\r\n    v_categoria_nome TEXT;\r\n    v_conta_id BIGINT;\r\n    v_lancamento_id BIGINT;\r\n    v_descricao_lancamento TEXT;\r\n    v_mes_referencia DATE;\r\nBEGIN\r\n    -- Converte a string de m√™s para o tipo DATE\r\n    v_mes_referencia := to_date(p_mes_referencia_str, 'YYYY-MM-DD');\r\n\r\n    -- Pega o √∫ltimo sal√°rio/di√°ria cadastrado para o funcion√°rio\r\n    SELECT valor_diaria INTO v_valor_diaria\r\n    FROM public.historico_salarial\r\n    WHERE funcionario_id = p_funcionario_id\r\n    ORDER BY data_inicio_vigencia DESC\r\n    LIMIT 1;\r\n\r\n    -- Pega a jornada de trabalho\r\n    SELECT j.carga_horaria_semanal INTO v_carga_horaria\r\n    FROM public.funcionarios f\r\n    JOIN public.jornadas j ON f.jornada_id = j.id\r\n    WHERE f.id = p_funcionario_id;\r\n\r\n    -- Valida√ß√µes\r\n    IF v_valor_diaria IS NULL OR v_valor_diaria <= 0 THEN\r\n        RETURN QUERY SELECT FALSE, 'Erro: Valor da di√°ria n√£o encontrado ou inv√°lido para o funcion√°rio.';\r\n        RETURN;\r\n    END IF;\r\n    IF v_carga_horaria IS NULL OR v_carga_horaria <= 0 THEN\r\n        v_carga_horaria := 44; -- Valor padr√£o se n√£o houver jornada\r\n    END IF;\r\n\r\n    -- Calcula o valor da hora e o valor total do ajuste\r\n    v_valor_hora := (v_valor_diaria * 5) / v_carga_horaria;\r\n    v_valor_ajuste := (abs(p_saldo_minutos) / 60.0) * v_valor_hora;\r\n\r\n    -- Define o tipo de lan√ßamento e a categoria\r\n    IF p_saldo_minutos > 0 THEN\r\n        v_tipo_lancamento := 'Despesa';\r\n        v_categoria_nome := 'Pagamento de Banco de Horas';\r\n    ELSE\r\n        v_tipo_lancamento := 'Receita';\r\n        v_categoria_nome := 'Desconto de Banco de Horas';\r\n    END IF;\r\n\r\n    -- Busca o ID da categoria\r\n    SELECT id INTO v_categoria_id FROM public.categorias_financeiras WHERE nome = v_categoria_nome AND tipo = v_tipo_lancamento LIMIT 1;\r\n\r\n    -- Se a categoria n√£o existir, retorna erro\r\n    IF v_categoria_id IS NULL THEN\r\n        RETURN QUERY SELECT FALSE, 'Erro: Categoria \"' || v_categoria_nome || '\" n√£o encontrada. Por favor, crie-a no m√≥dulo financeiro.';\r\n        RETURN;\r\n    END IF;\r\n    \r\n    -- Pega a primeira conta financeira como padr√£o (ou a que for mais adequada)\r\n    SELECT id INTO v_conta_id FROM public.contas_financeiras LIMIT 1;\r\n    IF v_conta_id IS NULL THEN\r\n        RETURN QUERY SELECT FALSE, 'Erro: Nenhuma conta financeira encontrada para registrar o lan√ßamento.';\r\n        RETURN;\r\n    END IF;\r\n\r\n    -- Cria a descri√ß√£o do lan√ßamento\r\n    v_descricao_lancamento := 'Ref. ' || v_tipo_lancamento || ' de banco de horas - ' || (SELECT full_name FROM public.funcionarios WHERE id = p_funcionario_id) || ' - M√™s ' || to_char(v_mes_referencia, 'MM/YYYY');\r\n\r\n    -- Insere o lan√ßamento financeiro\r\n    INSERT INTO public.lancamentos (descricao, valor, data_transacao, tipo, status, conta_id, categoria_id, funcionario_id, empresa_id)\r\n    VALUES (v_descricao_lancamento, v_valor_ajuste, current_date, v_tipo_lancamento, 'Pago', v_conta_id, v_categoria_id, p_funcionario_id, (SELECT empresa_id FROM public.funcionarios WHERE id = p_funcionario_id))\r\n    RETURNING id INTO v_lancamento_id;\r\n\r\n    -- Atualiza o registro no banco de horas para \"Pago\" ou \"Descontado\"\r\n    UPDATE public.banco_de_horas\r\n    SET \r\n        status = CASE WHEN p_saldo_minutos > 0 THEN 'Pago' ELSE 'Descontado' END,\r\n        lancamento_id = v_lancamento_id\r\n    WHERE funcionario_id = p_funcionario_id AND mes_referencia = v_mes_referencia;\r\n\r\n    RETURN QUERY SELECT TRUE, 'Opera√ß√£o realizada e lan√ßamento financeiro criado com sucesso!';\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "preencher_nome_mensagem",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.preencher_nome_mensagem()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Tenta buscar o nome na tabela de contatos usando o ID\r\n    -- Se n√£o achar contato (NULL), mant√©m o que vier ou fica NULL\r\n    NEW.nome_remetente := (\r\n        SELECT nome \r\n        FROM public.contatos \r\n        WHERE id = NEW.contato_id\r\n    );\r\n    \r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "preencher_nomes_historico_anuncios",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.preencher_nomes_historico_anuncios()\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    updated_rows_count INTEGER;\r\nBEGIN\r\n    -- Usamos um CTE (Common Table Expression) com a cl√°usula RETURNING\r\n    -- para contar de forma eficiente quantas linhas foram realmente atualizadas.\r\n    WITH updated_rows AS (\r\n        UPDATE public.meta_ads_historico h\r\n        SET\r\n            ad_name = a.name,\r\n            campaign_name = c.name,\r\n            adset_name = s.name\r\n        FROM\r\n            public.meta_ads a\r\n        JOIN\r\n            public.meta_campaigns c ON a.campaign_id = c.id\r\n        JOIN\r\n            public.meta_adsets s ON a.adset_id = s.id\r\n        WHERE\r\n            h.ad_id = a.id\r\n        AND (\r\n            h.ad_name IS NULL OR\r\n            h.campaign_name IS NULL OR\r\n            h.adset_name IS NULL\r\n        )\r\n        RETURNING h.id\r\n    )\r\n    SELECT count(*) INTO updated_rows_count FROM updated_rows;\r\n\r\n    -- Retorna uma mensagem amig√°vel com a contagem de registros atualizados.\r\n    RETURN 'Preenchimento conclu√≠do. ' || updated_rows_count || ' registros do hist√≥rico foram atualizados.';\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "preencher_nomes_meta",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.preencher_nomes_meta()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_ad_name TEXT;\r\n    v_adset_name TEXT;\r\n    v_campaign_name TEXT;\r\nBEGIN\r\n    -- O 'NEW' √© uma vari√°vel especial que representa a nova linha que est√° sendo inserida.\r\n    -- Vamos usar os IDs dessa nova linha para buscar os nomes.\r\n\r\n    -- 1. Busca o nome do An√∫ncio (se o ID existir)\r\n    IF NEW.meta_ad_id IS NOT NULL THEN\r\n        SELECT name INTO v_ad_name FROM public.meta_ads WHERE id = NEW.meta_ad_id;\r\n    END IF;\r\n\r\n    -- 2. Busca o nome do Conjunto de An√∫ncios (se o ID existir)\r\n    IF NEW.meta_adgroup_id IS NOT NULL THEN\r\n        SELECT name INTO v_adset_name FROM public.meta_adsets WHERE id = NEW.meta_adgroup_id;\r\n    END IF;\r\n    \r\n    -- 3. Busca o nome da Campanha (se o ID existir)\r\n    IF NEW.meta_campaign_id IS NOT NULL THEN\r\n        SELECT name INTO v_campaign_name FROM public.meta_campaigns WHERE id = NEW.meta_campaign_id;\r\n    END IF;\r\n\r\n    -- 4. Atualiza a nova linha com os nomes encontrados ANTES de ela ser salva.\r\n    NEW.meta_ad_name := v_ad_name;\r\n    NEW.meta_adset_name := v_adset_name;\r\n    NEW.meta_campaign_name := v_campaign_name;\r\n\r\n    -- 5. Retorna a linha modificada para que o banco de dados possa salv√°-la.\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "processar_ajuste_banco_horas",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.processar_ajuste_banco_horas(p_funcionario_id bigint, p_minutos_ajustados integer, p_motivo text, p_conta_id bigint, p_categoria_id bigint, p_criado_por_usuario_id uuid)\n RETURNS TABLE(success boolean, message text)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_valor_diaria numeric;\r\n    v_carga_horaria_semanal integer;\r\n    v_valor_hora numeric;\r\n    v_valor_ajuste numeric;\r\n    v_tipo_lancamento text;\r\n    v_descricao_lancamento text;\r\n    v_favorecido_contato_id bigint;\r\n    novo_lancamento_id bigint;\r\nBEGIN\r\n    -- 1. Buscar dados do funcion√°rio para c√°lculo\r\n    SELECT\r\n        REPLACE(f.daily_value, ',', '.')::numeric,\r\n        j.carga_horaria_semanal,\r\n        f.contato_id\r\n    INTO\r\n        v_valor_diaria,\r\n        v_carga_horaria_semanal,\r\n        v_favorecido_contato_id\r\n    FROM funcionarios f\r\n    LEFT JOIN jornadas j ON f.jornada_id = j.id\r\n    WHERE f.id = p_funcionario_id;\r\n\r\n    IF v_valor_diaria IS NULL OR v_valor_diaria <= 0 THEN\r\n        RETURN QUERY SELECT false, 'Erro: Funcion√°rio n√£o possui um valor de di√°ria v√°lido cadastrado.';\r\n        RETURN;\r\n    END IF;\r\n\r\n    IF v_carga_horaria_semanal IS NULL OR v_carga_horaria_semanal <= 0 THEN\r\n       v_carga_horaria_semanal := 44; -- Valor padr√£o se n√£o houver jornada\r\n    END IF;\r\n\r\n    -- 2. Calcular valor da hora e o valor total do ajuste\r\n    v_valor_hora := (v_valor_diaria * 5) / v_carga_horaria_semanal;\r\n    v_valor_ajuste := (abs(p_minutos_ajustados) / 60.0) * v_valor_hora;\r\n\r\n    -- 3. Definir tipo e descri√ß√£o do lan√ßamento financeiro\r\n    IF p_minutos_ajustados < 0 THEN\r\n        v_tipo_lancamento := 'Despesa';\r\n        v_descricao_lancamento := 'Pagamento de Banco de Horas - ' || p_motivo;\r\n    ELSE\r\n        v_tipo_lancamento := 'Receita';\r\n        v_descricao_lancamento := 'Desconto de Banco de Horas - ' || p_motivo;\r\n    END IF;\r\n\r\n    -- 4. Inserir o lan√ßamento financeiro\r\n    INSERT INTO public.lancamentos (\r\n        descricao, valor, tipo, status, data_transacao, data_vencimento, data_pagamento,\r\n        conta_id, categoria_id, favorecido_contato_id, criado_por_usuario_id\r\n    ) VALUES (\r\n        v_descricao_lancamento,\r\n        v_valor_ajuste,\r\n        v_tipo_lancamento,\r\n        'Pago',\r\n        CURRENT_DATE,\r\n        CURRENT_DATE,\r\n        CURRENT_DATE,\r\n        p_conta_id,\r\n        p_categoria_id,\r\n        v_favorecido_contato_id,\r\n        p_criado_por_usuario_id\r\n    ) RETURNING id INTO novo_lancamento_id;\r\n\r\n    -- 5. Inserir o registro de ajuste, vinculando ao lan√ßamento\r\n    INSERT INTO public.ajustes_banco_horas (\r\n        funcionario_id, lancamento_financeiro_id, minutos_ajustados,\r\n        valor_ajustado, data_ajuste, motivo, criado_por_usuario_id\r\n    ) VALUES (\r\n        p_funcionario_id,\r\n        novo_lancamento_id,\r\n        p_minutos_ajustados,\r\n        v_valor_ajuste,\r\n        CURRENT_DATE,\r\n        p_motivo,\r\n        p_criado_por_usuario_id\r\n    );\r\n\r\n    RETURN QUERY SELECT true, 'Ajuste de banco de horas e lan√ßamento financeiro criados com sucesso!';\r\n\r\nEXCEPTION\r\n    WHEN others THEN\r\n        RETURN QUERY SELECT false, 'Erro inesperado: ' || SQLERRM;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "processar_entrada_pedido_no_estoque",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.processar_entrada_pedido_no_estoque(p_pedido_id bigint, p_usuario_id uuid)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    item_record RECORD;\r\n    v_estoque_id BIGINT;\r\n    v_empreendimento_id BIGINT;\r\n    v_custo_total_anterior NUMERIC;\r\n    v_quantidade_anterior NUMERIC;\r\n    v_novo_custo_medio NUMERIC;\r\nBEGIN\r\n    -- Busca o empreendimento do pedido\r\n    SELECT empreendimento_id INTO v_empreendimento_id\r\n    FROM public.pedidos_compra\r\n    WHERE id = p_pedido_id;\r\n\r\n    -- Se n√£o encontrar o pedido ou o empreendimento, encerra a fun√ß√£o\r\n    IF v_empreendimento_id IS NULL THEN\r\n        RAISE EXCEPTION 'Pedido de compra ou empreendimento n√£o encontrado.';\r\n    END IF;\r\n\r\n    -- Itera sobre cada item do pedido de compra\r\n    FOR item_record IN\r\n        SELECT\r\n            pci.material_id,\r\n            pci.quantidade_solicitada,\r\n            pci.unidade_medida,\r\n            pci.custo_total_real\r\n        FROM\r\n            public.pedidos_compra_itens AS pci\r\n        WHERE\r\n            pci.pedido_compra_id = p_pedido_id AND pci.material_id IS NOT NULL\r\n    LOOP\r\n        -- Tenta encontrar um registro de estoque existente para o material no empreendimento\r\n        SELECT id, quantidade_atual, custo_medio INTO v_estoque_id, v_quantidade_anterior, v_custo_total_anterior\r\n        FROM public.estoque\r\n        WHERE empreendimento_id = v_empreendimento_id AND material_id = item_record.material_id;\r\n        \r\n        -- Garante que valores nulos sejam tratados como zero para o c√°lculo\r\n        v_quantidade_anterior := COALESCE(v_quantidade_anterior, 0);\r\n        v_custo_total_anterior := COALESCE(v_custo_total_anterior, 0);\r\n\r\n        -- Calcula o novo custo m√©dio ponderado, evitando divis√£o por zero\r\n        IF (v_quantidade_anterior + item_record.quantidade_solicitada) > 0 THEN\r\n            v_custo_total_anterior := (v_quantidade_anterior * v_custo_total_anterior);\r\n            v_novo_custo_medio := (v_custo_total_anterior + COALESCE(item_record.custo_total_real, 0)) / (v_quantidade_anterior + item_record.quantidade_solicitada);\r\n        ELSE\r\n            v_novo_custo_medio := 0;\r\n        END IF;\r\n\r\n\r\n        IF v_estoque_id IS NOT NULL THEN\r\n            -- Se o item j√° existe no estoque, atualiza a quantidade e o custo m√©dio\r\n            UPDATE public.estoque\r\n            SET\r\n                quantidade_atual = quantidade_atual + item_record.quantidade_solicitada,\r\n                custo_medio = v_novo_custo_medio,\r\n                ultima_atualizacao = NOW()\r\n            WHERE\r\n                id = v_estoque_id;\r\n        ELSE\r\n            -- Se o item n√£o existe, insere um novo registro no estoque\r\n            INSERT INTO public.estoque (empreendimento_id, material_id, quantidade_atual, unidade_medida, custo_medio)\r\n            VALUES (v_empreendimento_id, item_record.material_id, item_record.quantidade_solicitada, item_record.unidade_medida, (COALESCE(item_record.custo_total_real, 0) / item_record.quantidade_solicitada))\r\n            RETURNING id INTO v_estoque_id;\r\n        END IF;\r\n\r\n        -- ***** CORRE√á√ÉO AQUI *****\r\n        -- O tipo da movimenta√ß√£o foi alterado de 'Entrada' para 'Entrada por Compra'\r\n        INSERT INTO public.movimentacoes_estoque (estoque_id, tipo, quantidade, pedido_compra_id, usuario_id)\r\n        VALUES (v_estoque_id, 'Entrada por Compra', item_record.quantidade_solicitada, p_pedido_id, p_usuario_id);\r\n\r\n    END LOOP;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "processar_entrada_pedido_no_estoque",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.processar_entrada_pedido_no_estoque(p_pedido_id bigint, p_usuario_id uuid, p_organizacao_id bigint)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    item_row RECORD;\r\n    v_empreendimento_id bigint;\r\n    v_estoque_id bigint;\r\nBEGIN\r\n    -- Busca o ID do empreendimento do pedido.\r\n    SELECT empreendimento_id INTO v_empreendimento_id\r\n    FROM public.pedidos_compra\r\n    WHERE id = p_pedido_id AND organizacao_id = p_organizacao_id;\r\n\r\n    IF v_empreendimento_id IS NULL THEN\r\n        RAISE WARNING 'Empreendimento n√£o encontrado para o pedido %', p_pedido_id;\r\n        RETURN;\r\n    END IF;\r\n\r\n    -- Itera sobre cada item do pedido.\r\n    -- CORRE√á√ÉO: Nomes das colunas ajustados para 'material_id' e 'quantidade_solicitada'.\r\n    FOR item_row IN\r\n        SELECT\r\n            pi.material_id,\r\n            pi.quantidade_solicitada,\r\n            pi.unidade_medida\r\n        FROM public.pedidos_compra_itens AS pi\r\n        WHERE pi.pedido_compra_id = p_pedido_id\r\n    LOOP\r\n        -- Etapa crucial: Verifica se o item j√° existe no estoque deste empreendimento.\r\n        SELECT id INTO v_estoque_id\r\n        FROM public.estoque\r\n        WHERE empreendimento_id = v_empreendimento_id\r\n          AND material_id = item_row.material_id\r\n          AND organizacao_id = p_organizacao_id;\r\n\r\n        -- Se n√£o existir, CRIA o registro no estoque central.\r\n        IF v_estoque_id IS NULL THEN\r\n            INSERT INTO public.estoque (empreendimento_id, material_id, unidade_medida, organizacao_id)\r\n            VALUES (v_empreendimento_id, item_row.material_id, item_row.unidade_medida, p_organizacao_id)\r\n            RETURNING id INTO v_estoque_id;\r\n        END IF;\r\n\r\n        -- Insere a movimenta√ß√£o de ENTRADA, agora com o ID de estoque correto.\r\n        -- CORRE√á√ÉO: Nomes da tabela e colunas ajustados.\r\n        INSERT INTO public.movimentacoes_estoque (\r\n            estoque_id,\r\n            tipo,\r\n            quantidade,\r\n            data_movimentacao,\r\n            pedido_compra_id,\r\n            usuario_id,\r\n            observacao,\r\n            organizacao_id\r\n        )\r\n        VALUES (\r\n            v_estoque_id,\r\n            'Entrada por Compra', -- Valor conforme o CHECK da sua tabela\r\n            item_row.quantidade_solicitada,\r\n            CURRENT_TIMESTAMP,\r\n            p_pedido_id,\r\n            p_usuario_id,\r\n            'Entrada referente ao Pedido de Compra #' || p_pedido_id,\r\n            p_organizacao_id\r\n        );\r\n    END LOOP;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "processar_notificacao_automatica",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.processar_notificacao_automatica()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    r_regra RECORD;\r\n    r_user RECORD;\r\n    \r\n    -- Vari√°veis Finais para o Template\r\n    v_titulo_final text;\r\n    v_mensagem_final text;\r\n    v_link_final text;\r\n    \r\n    -- Vari√°veis de Cache\r\n    v_nome_empreendimento text := '';\r\n    v_nome_contato text := '';\r\n    v_unidade text := '';\r\n    \r\n    -- Prefer√™ncias\r\n    v_pref_sistema boolean;\r\n    v_pref_push boolean;\r\nBEGIN\r\n    -- =================================================================================\r\n    -- üìç 1. MAPA DE APONTAMENTO MANUAL (Onde buscamos os nomes?)\r\n    -- =================================================================================\r\n\r\n    -- CASO A: Tabela de Produtos (Unidades)\r\n    IF (TG_TABLE_NAME = 'produtos_empreendimento') THEN\r\n        -- Pega o n√∫mero da unidade da linha que est√° sendo salva\r\n        v_unidade := COALESCE(NEW.unidade, 'N/A');\r\n\r\n        -- Busca o NOME do Empreendimento usando o ID que est√° no produto\r\n        IF (NEW.empreendimento_id IS NOT NULL) THEN\r\n            SELECT nome INTO v_nome_empreendimento\r\n            FROM public.empreendimentos \r\n            WHERE id = NEW.empreendimento_id;\r\n        END IF;\r\n    END IF;\r\n\r\n    -- CASO B: Tabela de Mensagens do WhatsApp\r\n    IF (TG_TABLE_NAME = 'whatsapp_messages') THEN\r\n        IF (NEW.contato_id IS NOT NULL) THEN\r\n            SELECT nome INTO v_nome_contato\r\n            FROM public.contatos \r\n            WHERE id = NEW.contato_id;\r\n        END IF;\r\n    END IF;\r\n\r\n    -- Garantir que n√£o temos valores nulos para n√£o quebrar o texto\r\n    v_nome_empreendimento := COALESCE(v_nome_empreendimento, 'Empreendimento');\r\n    v_nome_contato := COALESCE(v_nome_contato, 'Contato Desconhecido');\r\n    v_unidade := COALESCE(v_unidade, '');\r\n\r\n    -- =================================================================================\r\n    -- üöÄ 2. PROCESSAMENTO DAS REGRAS\r\n    -- =================================================================================\r\n\r\n    FOR r_regra IN \r\n        SELECT * FROM public.regras_notificacao \r\n        WHERE tabela_alvo = TG_TABLE_NAME \r\n          AND evento = TG_OP \r\n          AND ativo = true \r\n          AND organizacao_id = (NEW.organizacao_id)\r\n    LOOP\r\n        \r\n        -- Verifica Gatilho de Valor (Ex: S√≥ dispara se status == 'Reservado')\r\n        IF r_regra.coluna_monitorada IS NOT NULL AND r_regra.coluna_monitorada <> '' THEN\r\n             -- Se o valor novo for diferente do gatilho, ignora e pula para o pr√≥ximo\r\n             IF (to_jsonb(NEW)->>r_regra.coluna_monitorada) IS DISTINCT FROM r_regra.valor_gatilho THEN\r\n                CONTINUE; \r\n             END IF;\r\n        END IF;\r\n\r\n        -- Loop pelos Usu√°rios que devem receber (baseado no cargo/fun√ß√£o)\r\n        FOR r_user IN \r\n            SELECT u.id \r\n            FROM public.usuarios u\r\n            WHERE (u.funcao_id::text = ANY(r_regra.funcoes_ids::text[]) OR r_regra.funcoes_ids IS NULL)\r\n        LOOP\r\n            -- Checa se o usu√°rio quer receber notifica√ß√µes\r\n            SELECT canal_sistema, canal_push \r\n            INTO v_pref_sistema, v_pref_push\r\n            FROM public.usuario_preferencias_notificacao\r\n            WHERE usuario_id = r_user.id AND regra_id = r_regra.id;\r\n\r\n            -- Padr√£o √© TRUE se n√£o tiver prefer√™ncia salva\r\n            IF v_pref_sistema IS NULL THEN v_pref_sistema := true; END IF;\r\n            IF v_pref_push IS NULL THEN v_pref_push := true; END IF;\r\n\r\n            -- Envio SISTEMA (Sininho)\r\n            IF v_pref_sistema = true THEN\r\n                v_titulo_final := r_regra.titulo_template;\r\n                v_mensagem_final := r_regra.mensagem_template;\r\n                v_link_final := r_regra.link_template;\r\n\r\n                -- üîÑ SUBSTITUI√á√ÉO DE VARI√ÅVEIS (A M√°gica acontece aqui)\r\n                v_titulo_final := replace(v_titulo_final, '{nome_empreendimento}', v_nome_empreendimento);\r\n                v_mensagem_final := replace(v_mensagem_final, '{nome_empreendimento}', v_nome_empreendimento);\r\n                \r\n                v_titulo_final := replace(v_titulo_final, '{nome_contato}', v_nome_contato);\r\n                v_mensagem_final := replace(v_mensagem_final, '{nome_contato}', v_nome_contato);\r\n                \r\n                v_titulo_final := replace(v_titulo_final, '{unidade}', v_unidade);\r\n                v_mensagem_final := replace(v_mensagem_final, '{unidade}', v_unidade);\r\n                \r\n                v_link_final := replace(v_link_final, '{empreendimento_id}', COALESCE(NEW.empreendimento_id::text, ''));\r\n\r\n                -- INSERIR NOTIFICA√á√ÉO (CORRIGIDO: user_id e icone)\r\n                INSERT INTO public.notificacoes (\r\n                    titulo, \r\n                    mensagem, \r\n                    link, \r\n                    user_id, -- ‚úÖ CORRIGIDO: Era usuario_id, agora √© user_id\r\n                    organizacao_id, \r\n                    lida, \r\n                    created_at, \r\n                    enviar_push, \r\n                    icone\r\n                ) VALUES (\r\n                    v_titulo_final, \r\n                    v_mensagem_final, \r\n                    v_link_final, \r\n                    r_user.id, \r\n                    NEW.organizacao_id, \r\n                    false, \r\n                    now(), \r\n                    (r_regra.enviar_push AND v_pref_push), \r\n                    r_regra.icone\r\n                );\r\n            END IF;\r\n        END LOOP;\r\n    END LOOP;\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "processar_regras_notificacao",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.processar_regras_notificacao()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    r_regra RECORD;\r\n    r_user RECORD;\r\n    r_variavel RECORD; -- Vari√°vel para o loop do Linkador\r\n    \r\n    -- Vari√°veis de Texto\r\n    v_titulo_final text;\r\n    v_mensagem_final text;\r\n    v_link_final text;\r\n    \r\n    -- Dados e Vari√°veis\r\n    v_json_dados jsonb;\r\n    v_valor_novo text;\r\n    \r\n    -- Vari√°veis de Nomes (Intelig√™ncia Nativa)\r\n    v_nome_empreendimento text := '';\r\n    v_nome_contato text := '';\r\n    v_unidade text := '';\r\n    v_dono_id uuid;\r\n    \r\n    -- Auxiliares\r\n    v_phone_clean text;\r\n    v_query_dinamica text;\r\n    v_valor_resolvido text;\r\n    \r\nBEGIN\r\n    v_json_dados := to_jsonb(NEW);\r\n\r\n    -- ====================================================================\r\n    -- üïµÔ∏è‚Äç‚ôÇÔ∏è 1. INTELIG√äNCIA NATIVA (Padr√µes do Sistema)\r\n    -- ====================================================================\r\n    -- Mantemos isso pois √© r√°pido e cobre o b√°sico sem voc√™ precisar configurar\r\n    \r\n    -- WhatsApp: Busca nome do contato\r\n    IF (TG_TABLE_NAME = 'whatsapp_messages') THEN\r\n        IF (NEW.contato_id IS NOT NULL) THEN\r\n            SELECT nome INTO v_nome_contato FROM public.contatos WHERE id = NEW.contato_id;\r\n        END IF;\r\n        -- Busca profunda por telefone se falhar\r\n        IF (v_nome_contato IS NULL OR v_nome_contato = '') AND NEW.sender_id IS NOT NULL THEN\r\n            v_phone_clean := regexp_replace(NEW.sender_id, '\\D', '', 'g');\r\n            SELECT c.nome INTO v_nome_contato\r\n            FROM public.contatos c\r\n            JOIN public.telefones t ON c.id = t.contato_id\r\n            WHERE t.telefone LIKE '%' || right(v_phone_clean, 8) LIMIT 1;\r\n        END IF;\r\n        v_nome_contato := COALESCE(v_nome_contato, NEW.nome_remetente, NEW.sender_id, 'Lead');\r\n    END IF;\r\n\r\n    -- Vendas\r\n    IF (TG_TABLE_NAME = 'produtos_empreendimento') THEN\r\n        v_unidade := COALESCE(NEW.unidade, 'N/A');\r\n        IF (NEW.empreendimento_id IS NOT NULL) THEN\r\n            SELECT nome INTO v_nome_empreendimento FROM public.empreendimentos WHERE id = NEW.empreendimento_id;\r\n        END IF;\r\n    END IF;\r\n\r\n    v_nome_empreendimento := COALESCE(v_nome_empreendimento, '');\r\n    v_nome_contato := COALESCE(v_nome_contato, '');\r\n\r\n    -- ====================================================================\r\n    -- üîÑ 2. PROCESSAMENTO DAS REGRAS\r\n    -- ====================================================================\r\n    FOR r_regra IN \r\n        SELECT * FROM public.regras_notificacao \r\n        WHERE tabela_alvo = TG_TABLE_NAME \r\n          AND evento = TG_OP \r\n          AND ativo = true \r\n          AND organizacao_id = NEW.organizacao_id\r\n    LOOP\r\n        BEGIN -- Bloco de Prote√ß√£o\r\n            \r\n            -- A. Filtros (Condi√ß√£o)\r\n            IF r_regra.coluna_monitorada IS NOT NULL AND r_regra.coluna_monitorada <> '' THEN\r\n                 v_valor_novo := v_json_dados->>r_regra.coluna_monitorada;\r\n                 IF v_valor_novo IS DISTINCT FROM r_regra.valor_gatilho THEN\r\n                    CONTINUE; \r\n                 END IF;\r\n            END IF;\r\n\r\n            -- B. Templates Iniciais\r\n            v_titulo_final := r_regra.titulo_template;\r\n            v_mensagem_final := r_regra.mensagem_template;\r\n            v_link_final := r_regra.link_template;\r\n\r\n            -- C. Substitui√ß√µes Nativas\r\n            v_titulo_final := replace(v_titulo_final, '{nome_contato}', v_nome_contato);\r\n            v_mensagem_final := replace(v_mensagem_final, '{nome_contato}', v_nome_contato);\r\n            v_titulo_final := replace(v_titulo_final, '{nome_empreendimento}', v_nome_empreendimento);\r\n            v_mensagem_final := replace(v_mensagem_final, '{nome_empreendimento}', v_nome_empreendimento);\r\n            v_titulo_final := replace(v_titulo_final, '{unidade}', v_unidade);\r\n            v_mensagem_final := replace(v_mensagem_final, '{unidade}', v_unidade);\r\n\r\n            -- D. Substitui√ß√µes Simples (Campos da pr√≥pria tabela)\r\n            DECLARE\r\n                key text;\r\n                val text;\r\n            BEGIN\r\n                FOR key, val IN SELECT * FROM jsonb_each_text(v_json_dados) LOOP\r\n                    v_titulo_final := replace(v_titulo_final, '{' || key || '}', COALESCE(val, ''));\r\n                    v_mensagem_final := replace(v_mensagem_final, '{' || key || '}', COALESCE(val, ''));\r\n                END LOOP;\r\n            END;\r\n\r\n            -- ============================================================\r\n            -- üîó E. O LINKADOR (Variaveis Virtuais) - AQUI EST√Å A CORRE√á√ÉO!\r\n            -- ============================================================\r\n            -- Verifica se existem vari√°veis configuradas para esta tabela\r\n            FOR r_variavel IN SELECT * FROM public.variaveis_virtuais WHERE tabela_gatilho = TG_TABLE_NAME LOOP\r\n                \r\n                -- Se o template usa esta vari√°vel (ex: {nome_cliente})\r\n                IF (v_titulo_final LIKE '%{' || r_variavel.nome_variavel || '}%') OR (v_mensagem_final LIKE '%{' || r_variavel.nome_variavel || '}%') THEN\r\n                    \r\n                    -- 1. Pega o valor da FK na linha atual (ex: pega o valor de 'cliente_id')\r\n                    v_valor_novo := v_json_dados->>r_variavel.coluna_origem;\r\n\r\n                    IF v_valor_novo IS NOT NULL AND v_valor_novo <> '' THEN\r\n                        -- 2. Monta a query din√¢mica para buscar na outra tabela\r\n                        -- SELECT nome FROM clientes WHERE id = '123'\r\n                        v_query_dinamica := format(\r\n                            'SELECT %I::text FROM public.%I WHERE %I = %L LIMIT 1',\r\n                            r_variavel.coluna_retorno,\r\n                            r_variavel.tabela_destino,\r\n                            r_variavel.coluna_chave_destino,\r\n                            v_valor_novo\r\n                        );\r\n\r\n                        -- 3. Executa e pega o valor\r\n                        BEGIN\r\n                            EXECUTE v_query_dinamica INTO v_valor_resolvido;\r\n                        EXCEPTION WHEN OTHERS THEN\r\n                            v_valor_resolvido := NULL; -- Se der erro na busca din√¢mica, segue o jogo\r\n                        END;\r\n\r\n                        -- 4. Substitui no texto\r\n                        v_titulo_final := replace(v_titulo_final, '{' || r_variavel.nome_variavel || '}', COALESCE(v_valor_resolvido, '...'));\r\n                        v_mensagem_final := replace(v_mensagem_final, '{' || r_variavel.nome_variavel || '}', COALESCE(v_valor_resolvido, '...'));\r\n                    END IF;\r\n                END IF;\r\n            END LOOP;\r\n            -- ============================================================\r\n\r\n            -- F. Envio para Fun√ß√µes\r\n            IF r_regra.funcoes_ids IS NOT NULL AND array_length(r_regra.funcoes_ids, 1) > 0 THEN\r\n                FOR r_user IN SELECT id FROM public.usuarios WHERE funcao_id::text = ANY(r_regra.funcoes_ids::text[]) AND organizacao_id = NEW.organizacao_id LOOP\r\n                    INSERT INTO public.notificacoes (user_id, organizacao_id, titulo, mensagem, link, lida, tipo, enviar_push, icone, created_at)\r\n                    VALUES (r_user.id, NEW.organizacao_id, v_titulo_final, v_mensagem_final, v_link_final, false, 'sistema', r_regra.enviar_push, r_regra.icone, now())\r\n                    ON CONFLICT DO NOTHING;\r\n                END LOOP;\r\n            END IF;\r\n\r\n            -- G. Envio para Dono\r\n            IF r_regra.enviar_para_dono = true THEN\r\n                v_dono_id := NULL;\r\n                IF v_json_dados ? 'criado_por_usuario_id' THEN v_dono_id := (v_json_dados->>'criado_por_usuario_id')::uuid;\r\n                ELSIF v_json_dados ? 'user_id' THEN v_dono_id := (v_json_dados->>'user_id')::uuid;\r\n                ELSIF v_json_dados ? 'corretor_id' THEN v_dono_id := (v_json_dados->>'corretor_id')::uuid;\r\n                END IF;\r\n\r\n                IF v_dono_id IS NOT NULL AND EXISTS(SELECT 1 FROM public.usuarios WHERE id = v_dono_id) THEN\r\n                    INSERT INTO public.notificacoes (user_id, organizacao_id, titulo, mensagem, link, lida, tipo, enviar_push, icone, created_at)\r\n                    VALUES (v_dono_id, NEW.organizacao_id, v_titulo_final, v_mensagem_final, v_link_final, false, 'sistema', r_regra.enviar_push, r_regra.icone, now());\r\n                END IF;\r\n            END IF;\r\n\r\n        EXCEPTION WHEN OTHERS THEN\r\n            RAISE WARNING 'Erro ao processar regra %: %', r_regra.id, SQLERRM;\r\n        END;\r\n    END LOOP;\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "provisionar_parcelas_contrato",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.provisionar_parcelas_contrato(p_contrato_id bigint, p_organizacao_id bigint)\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  v_parcela RECORD;\r\n  v_contrato RECORD;\r\n  v_empreendimento RECORD;\r\n  v_categoria_id BIGINT;\r\n  v_lancamento_id BIGINT;\r\n  v_parcelas_criadas_count INT := 0;\r\n  v_cliente_nome TEXT; -- Vari√°vel para armazenar o nome do cliente\r\nBEGIN\r\n  -- 1. Buscar os detalhes essenciais do contrato\r\n  SELECT *\r\n  INTO v_contrato\r\n  FROM public.contratos\r\n  WHERE id = p_contrato_id AND organizacao_id = p_organizacao_id;\r\n\r\n  IF v_contrato.id IS NULL THEN\r\n    RETURN 'Erro: Contrato n√£o encontrado.';\r\n  END IF;\r\n\r\n  IF v_contrato.contato_id IS NULL THEN\r\n    RETURN 'Erro: O contrato precisa ter um cliente (comprador) definido.';\r\n  END IF;\r\n\r\n  IF v_contrato.conta_bancaria_id IS NULL THEN\r\n    RETURN 'Erro: Defina uma \"Conta Banc√°ria para Pagamentos\" nos detalhes da venda do contrato.';\r\n  END IF;\r\n\r\n  -- Adiciona busca por detalhes do empreendimento para pegar o ID da empresa\r\n  SELECT *\r\n  INTO v_empreendimento\r\n  FROM public.empreendimentos\r\n  WHERE id = v_contrato.empreendimento_id;\r\n\r\n  IF v_empreendimento.id IS NULL THEN\r\n      RETURN 'Erro: Empreendimento associado ao contrato n√£o foi encontrado.';\r\n  END IF;\r\n  \r\n  -- =================================================================================\r\n  -- IN√çCIO DA MELHORIA: Buscar o nome do cliente\r\n  -- O PORQU√ä: Precisamos do nome do cliente para incluir na descri√ß√£o do lan√ßamento.\r\n  -- Usamos COALESCE para pegar o nome (pessoa f√≠sica) ou a raz√£o social (pessoa jur√≠dica).\r\n  -- =================================================================================\r\n  SELECT COALESCE(nome, razao_social)\r\n  INTO v_cliente_nome\r\n  FROM public.contatos\r\n  WHERE id = v_contrato.contato_id;\r\n  -- =================================================================================\r\n  -- FIM DA MELHORIA\r\n  -- =================================================================================\r\n\r\n  -- 2. Buscar o ID da categoria financeira\r\n  SELECT id INTO v_categoria_id\r\n  FROM public.categorias_financeiras\r\n  WHERE nome = 'Venda de Im√≥vel' AND tipo = 'Receita' AND organizacao_id = p_organizacao_id;\r\n\r\n  IF v_categoria_id IS NULL THEN\r\n    RETURN 'Erro: Categoria financeira \"Venda de Im√≥vel\" do tipo \"Receita\" n√£o encontrada.';\r\n  END IF;\r\n\r\n  -- 3. Inicia o loop para processar parcelas\r\n  FOR v_parcela IN\r\n    SELECT id, descricao, valor_parcela, data_vencimento\r\n    FROM public.contrato_parcelas\r\n    WHERE contrato_id = p_contrato_id\r\n      AND organizacao_id = p_organizacao_id\r\n      AND status_pagamento = 'Pendente'\r\n      AND lancamento_id IS NULL\r\n  LOOP\r\n    -- 4. Insere o novo lan√ßamento com a descri√ß√£o no novo padr√£o\r\n    INSERT INTO public.lancamentos (\r\n      descricao,\r\n      valor,\r\n      data_vencimento,\r\n      data_transacao,\r\n      tipo,\r\n      status,\r\n      conta_id,\r\n      categoria_id,\r\n      empreendimento_id,\r\n      empresa_id,\r\n      favorecido_contato_id,\r\n      organizacao_id,\r\n      criado_por_usuario_id\r\n    )\r\n    VALUES (\r\n      -- A MUDAN√áA EST√Å AQUI: Nova formata√ß√£o da descri√ß√£o\r\n      'Recebimento: ' || v_parcela.descricao || ' | Contrato #' || p_contrato_id || ' (' || COALESCE(v_cliente_nome, 'N/A') || ')',\r\n      v_parcela.valor_parcela,\r\n      v_parcela.data_vencimento,\r\n      CURRENT_DATE,\r\n      'Receita',\r\n      'Pendente',\r\n      v_contrato.conta_bancaria_id,\r\n      v_categoria_id,\r\n      v_contrato.empreendimento_id,\r\n      v_empreendimento.empresa_proprietaria_id,\r\n      v_contrato.contato_id,\r\n      p_organizacao_id,\r\n      auth.uid()\r\n    )\r\n    RETURNING id INTO v_lancamento_id;\r\n\r\n    -- 5. Atualiza a parcela\r\n    UPDATE public.contrato_parcelas\r\n    SET lancamento_id = v_lancamento_id\r\n    WHERE id = v_parcela.id;\r\n\r\n    v_parcelas_criadas_count := v_parcelas_criadas_count + 1;\r\n  END LOOP;\r\n\r\n  -- 6. Retorna uma mensagem de sucesso\r\n  IF v_parcelas_criadas_count > 0 THEN\r\n    RETURN 'Sucesso: ' || v_parcelas_criadas_count || ' lan√ßamento(s) financeiro(s) foram provisionados.';\r\n  ELSE\r\n    RETURN 'Nenhuma parcela pendente para sincronizar.';\r\n  END IF;\r\n\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "provisionar_parcelas_contrato",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.provisionar_parcelas_contrato(p_contrato_id bigint)\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_categoria_id BIGINT;\r\n    v_conta_id BIGINT;\r\n    v_contrato_info RECORD;\r\n    v_parcela_rec RECORD;\r\n    v_novo_lancamento_id BIGINT;\r\n    v_lancamentos_criados INT := 0;\r\nBEGIN\r\n    -- Etapa 1: Garante que a categoria \"Vendas\" exista e obt√©m seu ID.\r\n    -- Se n√£o existir, ela ser√° criada automaticamente.\r\n    -- ##### ALTERA√á√ÉO AQUI #####\r\n    SELECT id INTO v_categoria_id FROM categorias_financeiras WHERE nome = 'Vendas' AND tipo = 'Receita';\r\n    IF v_categoria_id IS NULL THEN\r\n        INSERT INTO categorias_financeiras (nome, tipo) VALUES ('Vendas', 'Receita') RETURNING id INTO v_categoria_id;\r\n    END IF;\r\n\r\n    -- Etapa 2: Garante que a conta \"Contas a Receber\" exista e obt√©m seu ID.\r\n    -- Se n√£o existir, ela ser√° criada automaticamente.\r\n    SELECT id INTO v_conta_id FROM contas_financeiras WHERE nome = 'Contas a Receber';\r\n    IF v_conta_id IS NULL THEN\r\n        INSERT INTO contas_financeiras (nome, tipo, saldo_inicial) VALUES ('Contas a Receber', 'Outro', 0) RETURNING id INTO v_conta_id;\r\n    END IF;\r\n\r\n    -- Etapa 3: Obt√©m informa√ß√µes do contrato, cliente, empreendimento e empresa propriet√°ria.\r\n    -- ##### L√ìGICA CONFIRMADA AQUI #####\r\n    -- Busca os dados diretamente do contrato que est√° sendo provisionado.\r\n    SELECT\r\n        c.contato_id,\r\n        c.empreendimento_id,\r\n        emp.empresa_proprietaria_id,\r\n        COALESCE(co.nome, co.razao_social) AS nome_cliente,\r\n        c.numero_contrato\r\n    INTO v_contrato_info\r\n    FROM contratos c\r\n    JOIN contatos co ON c.contato_id = co.id\r\n    JOIN empreendimentos emp ON c.empreendimento_id = emp.id\r\n    WHERE c.id = p_contrato_id;\r\n\r\n    IF v_contrato_info IS NULL THEN\r\n        RAISE EXCEPTION 'Contrato com ID % n√£o encontrado.', p_contrato_id;\r\n    END IF;\r\n\r\n    -- Etapa 4: Percorre apenas as parcelas PENDENTES que ainda n√£o foram enviadas ao financeiro.\r\n    FOR v_parcela_rec IN\r\n        SELECT * FROM contrato_parcelas\r\n        WHERE contrato_id = p_contrato_id AND lancamento_id IS NULL AND status_pagamento = 'Pendente'\r\n    LOOP\r\n        -- Etapa 5: Insere o lan√ßamento financeiro com os dados corretos.\r\n        INSERT INTO lancamentos (\r\n            descricao,\r\n            valor,\r\n            data_vencimento,\r\n            data_transacao,\r\n            tipo,\r\n            status,\r\n            conta_id,\r\n            categoria_id,\r\n            favorecido_contato_id,\r\n            empreendimento_id, -- Preenchido a partir do contrato\r\n            empresa_id, -- Preenchido a partir do empreendimento do contrato\r\n            observacao\r\n        )\r\n        VALUES (\r\n            'Recebimento: ' || v_parcela_rec.descricao || ' | Contrato #' || v_contrato_info.numero_contrato || ' (' || v_contrato_info.nome_cliente || ')',\r\n            v_parcela_rec.valor_parcela,\r\n            v_parcela_rec.data_vencimento,\r\n            v_parcela_rec.data_vencimento,\r\n            'Receita',\r\n            'Pendente',\r\n            v_conta_id,\r\n            v_categoria_id, -- Categoria \"Vendas\"\r\n            v_contrato_info.contato_id,\r\n            v_contrato_info.empreendimento_id, -- ID do Empreendimento do contrato\r\n            v_contrato_info.empresa_proprietaria_id, -- ID da Empresa do contrato\r\n            'Lan√ßamento provisionado do Contrato ID ' || p_contrato_id\r\n        )\r\n        RETURNING id INTO v_novo_lancamento_id;\r\n\r\n        -- Etapa 6: Atualiza a parcela com o ID do lan√ßamento, criando o v√≠nculo.\r\n        UPDATE contrato_parcelas\r\n        SET lancamento_id = v_novo_lancamento_id\r\n        WHERE id = v_parcela_rec.id;\r\n\r\n        v_lancamentos_criados := v_lancamentos_criados + 1;\r\n\r\n    END LOOP;\r\n\r\n    -- Etapa 7: Retorna uma mensagem de sucesso com a contagem de lan√ßamentos criados.\r\n    RETURN v_lancamentos_criados || ' lan√ßamento(s) foram provisionados no financeiro com sucesso!';\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "purgar_materiais_nao_utilizados",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.purgar_materiais_nao_utilizados()\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    deleted_count integer;\r\nBEGIN\r\n    WITH unused_materials AS (\r\n        SELECT id FROM public.materiais\r\n        EXCEPT\r\n        SELECT DISTINCT material_id FROM public.orcamento_itens WHERE material_id IS NOT NULL\r\n    )\r\n    DELETE FROM public.materiais\r\n    WHERE id IN (SELECT id FROM unused_materials);\r\n\r\n    GET DIAGNOSTICS deleted_count = ROW_COUNT;\r\n    RETURN deleted_count;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "reabrir_mes_ponto",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.reabrir_mes_ponto(p_funcionario_id bigint, p_mes_referencia date, p_organizacao_id bigint)\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    fechamento_rec record;\r\n    lancamento_rec record;\r\nBEGIN\r\n    -- 1. Encontrar o registro de fechamento em banco_de_horas\r\n    SELECT * INTO fechamento_rec\r\n    FROM public.banco_de_horas\r\n    WHERE funcionario_id = p_funcionario_id\r\n      AND mes_referencia = p_mes_referencia\r\n      AND organizacao_id = p_organizacao_id;\r\n\r\n    -- Se n√£o encontrar, informa que n√£o h√° o que reabrir\r\n    IF NOT FOUND THEN\r\n        RETURN 'Nenhum fechamento encontrado para este m√™s e funcion√°rio.';\r\n    END IF;\r\n\r\n    -- 2. Verificar se existe um lan√ßamento financeiro associado\r\n    IF fechamento_rec.lancamento_id IS NOT NULL THEN\r\n        -- Reverte o lan√ßamento para 'Pendente' se ele foi marcado como 'Pago'\r\n        UPDATE public.lancamentos\r\n        SET status = 'Pendente', data_pagamento = NULL\r\n        WHERE id = fechamento_rec.lancamento_id\r\n          AND organizacao_id = p_organizacao_id;\r\n    END IF;\r\n\r\n    -- 3. Excluir o registro de fechamento do banco de horas\r\n    DELETE FROM public.banco_de_horas\r\n    WHERE id = fechamento_rec.id;\r\n\r\n    RETURN 'M√™s reaberto com sucesso!';\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "reajustar_valor_base_produtos",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.reajustar_valor_base_produtos(p_empreendimento_id bigint, p_percentual_reajuste numeric)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    UPDATE public.produtos_empreendimento\r\n    SET\r\n        -- Aplica o reajuste ao valor_base existente\r\n        valor_base = valor_base * (1 + (p_percentual_reajuste / 100)),\r\n        -- Recalcula o valor de venda com base no NOVO valor_base\r\n        valor_venda_calculado = (valor_base * (1 + (p_percentual_reajuste / 100))) * (1 + (COALESCE(fator_reajuste_percentual, 0) / 100))\r\n    WHERE\r\n        empreendimento_id = p_empreendimento_id;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "realizar_transferencia",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.realizar_transferencia(p_descricao text, p_valor numeric, p_data_transacao date, p_conta_origem_id bigint, p_conta_destino_id bigint)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Valida√ß√£o para garantir que as contas s√£o diferentes\r\n    IF p_conta_origem_id = p_conta_destino_id THEN\r\n        RAISE EXCEPTION 'A conta de origem e destino n√£o podem ser a mesma.';\r\n    END IF;\r\n\r\n    -- Lan√ßamento de DESPESA na conta de origem\r\n    INSERT INTO public.lancamentos (descricao, valor, data_transacao, tipo, status, conta_id, categoria_id)\r\n    VALUES (\r\n        'Transfer√™ncia para ' || (SELECT nome FROM contas_financeiras WHERE id = p_conta_destino_id),\r\n        p_valor,\r\n        p_data_transacao,\r\n        'Despesa', -- Marcado como Despesa para a conta de origem\r\n        'Conciliado',\r\n        p_conta_origem_id,\r\n        NULL -- Categoria √© nula para transfer√™ncias\r\n    );\r\n\r\n    -- Lan√ßamento de RECEITA na conta de destino\r\n    INSERT INTO public.lancamentos (descricao, valor, data_transacao, tipo, status, conta_id, categoria_id)\r\n    VALUES (\r\n        'Transfer√™ncia de ' || (SELECT nome FROM contas_financeiras WHERE id = p_conta_origem_id),\r\n        p_valor,\r\n        p_data_transacao,\r\n        'Receita', -- Marcado como Receita para a conta de destino\r\n        'Conciliado',\r\n        p_conta_destino_id,\r\n        NULL -- Categoria √© nula para transfer√™ncias\r\n    );\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "recalcular_banco_horas_dia",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.recalcular_banco_horas_dia()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_funcionario_id BIGINT;\r\n    v_data_registro DATE;\r\n    v_jornada_id BIGINT;\r\n    v_dia_semana INT;\r\n    v_horas_previstas INTERVAL;\r\n    v_horas_trabalhadas INTERVAL;\r\n    v_saldo_calculado INTERVAL;\r\n    v_multiplicador NUMERIC(3, 1) := 1.0;\r\n    v_e_feriado BOOLEAN;\r\n    v_pontos_dia RECORD;\r\n    v_tolerancia INT;\r\nBEGIN\r\n    -- Identifica o funcion√°rio e a data a ser recalculada\r\n    IF TG_OP = 'DELETE' THEN\r\n        v_funcionario_id := OLD.funcionario_id;\r\n        v_data_registro := DATE(OLD.data_hora);\r\n    ELSE\r\n        v_funcionario_id := NEW.funcionario_id;\r\n        v_data_registro := DATE(NEW.data_hora);\r\n    END IF;\r\n\r\n    -- Busca a jornada do funcion√°rio e a toler√¢ncia\r\n    SELECT f.jornada_id, j.tolerancia_minutos INTO v_jornada_id, v_tolerancia\r\n    FROM public.funcionarios f\r\n    JOIN public.jornadas j ON f.jornada_id = j.id\r\n    WHERE f.id = v_funcionario_id;\r\n    \r\n    v_tolerancia := COALESCE(v_tolerancia, 0);\r\n    v_dia_semana := EXTRACT(ISODOW FROM v_data_registro); -- 1=Segunda, 7=Domingo\r\n\r\n    -- 1. BUSCA AS 4 PRINCIPAIS MARCA√á√ïES DO DIA\r\n    SELECT\r\n        MIN(CASE WHEN tipo_registro = 'Entrada' THEN data_hora END) as p_entrada,\r\n        MAX(CASE WHEN tipo_registro = 'In√≠cio Intervalo' THEN data_hora END) as p_saida_intervalo,\r\n        MIN(CASE WHEN tipo_registro = 'Fim Intervalo' THEN data_hora END) as p_volta_intervalo,\r\n        MAX(CASE WHEN tipo_registro = 'Sa√≠da' THEN data_hora END) as p_saida\r\n    INTO v_pontos_dia\r\n    FROM public.pontos\r\n    WHERE funcionario_id = v_funcionario_id AND DATE(data_hora) = v_data_registro;\r\n\r\n    -- 2. CALCULA HORAS PREVISTAS\r\n    SELECT (jd.horario_saida - jd.horario_entrada) - COALESCE((jd.horario_volta_intervalo - jd.horario_saida_intervalo), '00:00'::interval)\r\n    INTO v_horas_previstas\r\n    FROM public.jornada_detalhes jd\r\n    WHERE jd.jornada_id = v_jornada_id AND jd.dia_semana = v_dia_semana;\r\n    v_horas_previstas := COALESCE(v_horas_previstas, '0 hours');\r\n\r\n    -- 3. CALCULA HORAS TRABALHADAS (L√ìGICA CORRIGIDA)\r\n    v_horas_trabalhadas := '0 hours'::interval;\r\n    IF v_pontos_dia.p_entrada IS NOT NULL AND v_pontos_dia.p_saida IS NOT NULL THEN\r\n        IF v_pontos_dia.p_saida_intervalo IS NOT NULL AND v_pontos_dia.p_volta_intervalo IS NOT NULL THEN\r\n            -- Jornada com intervalo\r\n            v_horas_trabalhadas := (v_pontos_dia.p_saida - v_pontos_dia.p_entrada) - (v_pontos_dia.p_volta_intervalo - v_pontos_dia.p_saida_intervalo);\r\n        ELSE\r\n            -- Jornada sem intervalo\r\n            v_horas_trabalhadas := (v_pontos_dia.p_saida - v_pontos_dia.p_entrada);\r\n        END IF;\r\n    END IF;\r\n    v_horas_trabalhadas := GREATEST('0 hours'::interval, v_horas_trabalhadas);\r\n\r\n    -- 4. APLICA MULTIPLICADOR E CALCULA SALDO\r\n    SELECT EXISTS (SELECT 1 FROM public.feriados WHERE data_feriado = v_data_registro) INTO v_e_feriado;\r\n    IF (v_dia_semana IN (6, 7) OR v_e_feriado) AND v_horas_previstas = '0 hours'::interval THEN\r\n        v_multiplicador := 1.5;\r\n    END IF;\r\n    \r\n    v_saldo_calculado := (v_horas_trabalhadas * v_multiplicador) - v_horas_previstas;\r\n\r\n    -- 5. SALVA O RESULTADO NA NOVA TABELA (UPSERT)\r\n    INSERT INTO public.banco_horas_registros\r\n        (funcionario_id, data_registro, entrada_1, saida_1, entrada_2, saida_2, horas_previstas, horas_trabalhadas, saldo_dia, multiplicador_aplicado)\r\n    VALUES\r\n        (v_funcionario_id, v_data_registro, \r\n         CAST(v_pontos_dia.p_entrada AS TIME), \r\n         CAST(v_pontos_dia.p_saida_intervalo AS TIME), \r\n         CAST(v_pontos_dia.p_volta_intervalo AS TIME), \r\n         CAST(v_pontos_dia.p_saida AS TIME),\r\n         v_horas_previstas, v_horas_trabalhadas, v_saldo_calculado, v_multiplicador)\r\n    ON CONFLICT (funcionario_id, data_registro)\r\n    DO UPDATE SET\r\n        entrada_1 = EXCLUDED.entrada_1,\r\n        saida_1 = EXCLUDED.saida_1,\r\n        entrada_2 = EXCLUDED.entrada_2,\r\n        saida_2 = EXCLUDED.saida_2,\r\n        horas_previstas = EXCLUDED.horas_previstas,\r\n        horas_trabalhadas = EXCLUDED.horas_trabalhadas,\r\n        saldo_dia = EXCLUDED.saldo_dia,\r\n        multiplicador_aplicado = EXCLUDED.multiplicador_aplicado;\r\n\r\n    RETURN NULL;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "recalcular_precos_com_cub",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.recalcular_precos_com_cub(p_empreendimento_id bigint, p_novo_valor_cub numeric)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Atualiza todos os produtos do empreendimento, garantindo que\r\n    -- mesmo aqueles sem √°rea (ou com √°rea nula) n√£o causem erros.\r\n    UPDATE public.produtos_empreendimento\r\n    SET\r\n        -- Se a √°rea for nula, considera como 0 para n√£o quebrar o c√°lculo.\r\n        valor_base = COALESCE(area_m2, 0) * p_novo_valor_cub,\r\n        -- Recalcula o valor de venda com base no novo pre√ßo base.\r\n        valor_venda_calculado = (COALESCE(area_m2, 0) * p_novo_valor_cub) * (1 + (COALESCE(fator_reajuste_percentual, 0) / 100))\r\n    WHERE\r\n        empreendimento_id = p_empreendimento_id;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "regerar_parcelas_contrato",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.regerar_parcelas_contrato(p_contrato_id bigint, p_organizacao_id bigint)\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  v_simulacao RECORD;\r\n  v_contrato RECORD;\r\n  v_valor_parcela_entrada NUMERIC;\r\n  v_valor_parcela_obra NUMERIC;\r\n  v_total_gerado NUMERIC := 0;\r\n  v_saldo_remanescente NUMERIC;\r\n  v_ultima_data DATE;\r\n  i INT;\r\nBEGIN\r\n  -- 1. Obter dados do contrato e do plano de pagamento (simula√ß√£o) vinculado\r\n  SELECT * INTO v_contrato FROM public.contratos WHERE id = p_contrato_id AND organizacao_id = p_organizacao_id;\r\n  IF v_contrato.id IS NULL THEN RETURN 'Erro: Contrato n√£o encontrado.'; END IF;\r\n\r\n  SELECT * INTO v_simulacao FROM public.simulacoes WHERE contrato_id = v_contrato.id;\r\n  IF v_simulacao.id IS NULL THEN RETURN 'Erro: Plano de pagamento n√£o encontrado para este contrato.'; END IF;\r\n\r\n  -- 2. Limpar parcelas pendentes antigas para come√ßar do zero.\r\n  DELETE FROM public.contrato_parcelas WHERE contrato_id = p_contrato_id AND status_pagamento = 'Pendente';\r\n\r\n  -- 3. Gerar as parcelas da ENTRADA\r\n  IF v_simulacao.entrada_valor > 0 AND v_simulacao.num_parcelas_entrada > 0 AND v_simulacao.data_primeira_parcela_entrada IS NOT NULL THEN\r\n    v_valor_parcela_entrada := v_simulacao.entrada_valor / v_simulacao.num_parcelas_entrada;\r\n    FOR i IN 1..v_simulacao.num_parcelas_entrada LOOP\r\n      INSERT INTO public.contrato_parcelas (contrato_id, descricao, tipo, data_vencimento, valor_parcela, organizacao_id)\r\n      VALUES (\r\n        p_contrato_id,\r\n        'Entrada - Parcela ' || i || '/' || v_simulacao.num_parcelas_entrada,\r\n        'Entrada',\r\n        v_simulacao.data_primeira_parcela_entrada + ((i-1) || ' months')::interval,\r\n        v_valor_parcela_entrada,\r\n        p_organizacao_id\r\n      );\r\n    END LOOP;\r\n    v_total_gerado := v_total_gerado + v_simulacao.entrada_valor;\r\n  END IF;\r\n\r\n  -- 4. Gerar as parcelas de OBRA\r\n  IF v_simulacao.parcelas_obra_valor > 0 AND v_simulacao.num_parcelas_obra > 0 AND v_simulacao.data_primeira_parcela_obra IS NOT NULL THEN\r\n    v_valor_parcela_obra := v_simulacao.parcelas_obra_valor / v_simulacao.num_parcelas_obra;\r\n    FOR i IN 1..v_simulacao.num_parcelas_obra LOOP\r\n      INSERT INTO public.contrato_parcelas (contrato_id, descricao, tipo, data_vencimento, valor_parcela, organizacao_id)\r\n      VALUES (\r\n        p_contrato_id,\r\n        'Obra - Parcela ' || i || '/' || v_simulacao.num_parcelas_obra,\r\n        'Obra',\r\n        v_simulacao.data_primeira_parcela_obra + ((i-1) || ' months')::interval,\r\n        v_valor_parcela_obra,\r\n        p_organizacao_id\r\n      );\r\n    END LOOP;\r\n    v_total_gerado := v_total_gerado + v_simulacao.parcelas_obra_valor;\r\n  END IF;\r\n\r\n  -- 5. Calcular e gerar a parcela do SALDO REMANESCENTE\r\n  v_saldo_remanescente := v_contrato.valor_final_venda - v_total_gerado;\r\n\r\n  IF v_saldo_remanescente > 0.01 THEN\r\n    SELECT MAX(data_vencimento) INTO v_ultima_data\r\n    FROM public.contrato_parcelas\r\n    WHERE contrato_id = p_contrato_id;\r\n\r\n    IF v_ultima_data IS NULL THEN\r\n        v_ultima_data := v_contrato.data_venda + interval '30 days';\r\n    ELSE\r\n        v_ultima_data := v_ultima_data + interval '1 month';\r\n    END IF;\r\n\r\n    INSERT INTO public.contrato_parcelas (contrato_id, descricao, tipo, data_vencimento, valor_parcela, organizacao_id)\r\n    VALUES (\r\n      p_contrato_id,\r\n      'Saldo Remanescente (Chaves)',\r\n      'Saldo Remanescente',\r\n      v_ultima_data,\r\n      v_saldo_remanescente,\r\n      p_organizacao_id\r\n    );\r\n  END IF;\r\n\r\n  RETURN 'Cronograma de parcelas recalculado com sucesso, incluindo o Saldo Remanescente.';\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "regerar_parcelas_contrato",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.regerar_parcelas_contrato(p_contrato_id bigint)\n RETURNS TABLE(id bigint, contrato_id bigint, descricao text, tipo text, data_vencimento date, valor_parcela numeric, status_pagamento text, lancamento_id bigint, created_at timestamp with time zone, updated_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$DECLARE\r\n    v_simulacao RECORD;\r\n    v_valor_base NUMERIC;\r\n    v_valor_com_desconto NUMERIC;\r\n    v_valor_parcela_entrada NUMERIC;\r\n    v_valor_parcela_obra NUMERIC;\r\n    v_data_vencimento DATE;\r\nBEGIN\r\n    -- Encontrar a simula√ß√£o associada ao contrato\r\n    SELECT s.* INTO v_simulacao\r\n    FROM public.simulacoes s\r\n    JOIN public.contratos c ON s.id = c.simulacao_id\r\n    WHERE c.id = p_contrato_id;\r\n\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Nenhuma simula√ß√£o de pagamento individual encontrada para o contrato ID %', p_contrato_id;\r\n    END IF;\r\n\r\n    -- Deletar as parcelas antigas que ainda est√£o pendentes\r\n    -- *** CORRE√á√ÉO APLICADA AQUI: Especificando a tabela na condi√ß√£o WHERE ***\r\n    DELETE FROM public.contrato_parcelas\r\n    WHERE public.contrato_parcelas.contrato_id = p_contrato_id \r\n      AND public.contrato_parcelas.status_pagamento = 'Pendente';\r\n\r\n    -- Calcular valores base\r\n    v_valor_base := v_simulacao.valor_venda;\r\n    v_valor_com_desconto := v_valor_base - COALESCE(v_simulacao.desconto_valor, 0);\r\n\r\n    -- Gerar parcelas da ENTRADA\r\n    IF v_simulacao.num_parcelas_entrada > 0 AND v_simulacao.entrada_valor > 0 THEN\r\n        v_valor_parcela_entrada := v_simulacao.entrada_valor / v_simulacao.num_parcelas_entrada;\r\n        v_data_vencimento := v_simulacao.data_primeira_parcela_entrada;\r\n        FOR i IN 1..v_simulacao.num_parcelas_entrada LOOP\r\n            INSERT INTO public.contrato_parcelas (contrato_id, descricao, tipo, data_vencimento, valor_parcela, status_pagamento)\r\n            VALUES (p_contrato_id, 'Parcela de Entrada ' || i || '/' || v_simulacao.num_parcelas_entrada, 'Entrada', v_data_vencimento, v_valor_parcela_entrada, 'Pendente');\r\n            v_data_vencimento := v_data_vencimento + INTERVAL '1 month';\r\n        END LOOP;\r\n    END IF;\r\n\r\n    -- Gerar parcelas da OBRA\r\n    IF v_simulacao.num_parcelas_obra > 0 AND v_simulacao.parcelas_obra_valor > 0 THEN\r\n        v_valor_parcela_obra := v_simulacao.parcelas_obra_valor / v_simulacao.num_parcelas_obra;\r\n        v_data_vencimento := v_simulacao.data_primeira_parcela_obra;\r\n        FOR i IN 1..v_simulacao.num_parcelas_obra LOOP\r\n            INSERT INTO public.contrato_parcelas (contrato_id, descricao, tipo, data_vencimento, valor_parcela, status_pagamento)\r\n            VALUES (p_contrato_id, 'Parcela de Obra ' || i || '/' || v_simulacao.num_parcelas_obra, 'Obra', v_data_vencimento, v_valor_parcela_obra, 'Pendente');\r\n            v_data_vencimento := v_data_vencimento + INTERVAL '1 month';\r\n        END LOOP;\r\n    END IF;\r\n    \r\n    -- Retorna todas as parcelas (novas e as que j√° estavam pagas) do contrato\r\n    RETURN QUERY SELECT * FROM public.contrato_parcelas WHERE contrato_parcelas.contrato_id = p_contrato_id ORDER BY data_vencimento;\r\n\r\nEND;$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "registrar_movimentacao_funil",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.registrar_movimentacao_funil()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    -- Insere um novo registro na tabela de hist√≥rico com os dados da movimenta√ß√£o\r\n    INSERT INTO public.historico_movimentacao_funil (\r\n        contato_no_funil_id,\r\n        coluna_anterior_id,\r\n        coluna_nova_id,\r\n        usuario_id,\r\n        organizacao_id\r\n    )\r\n    VALUES (\r\n        NEW.id,                 -- O ID do card que foi movido\r\n        OLD.coluna_id,          -- A coluna em que ele estava ANTES\r\n        NEW.coluna_id,          -- A nova coluna para a qual ele foi\r\n        auth.uid(),             -- Pega automaticamente o ID do usu√°rio que fez a a√ß√£o\r\n        NEW.organizacao_id      -- A organiza√ß√£o do card\r\n    );\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "registrar_pagamento_pedido",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.registrar_pagamento_pedido(p_pedido_id bigint, p_conta_id bigint, p_data_pagamento date)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_valor_total NUMERIC;\r\n    v_empreendimento_id BIGINT;\r\n    v_descricao TEXT;\r\n    v_categoria_id BIGINT;\r\nBEGIN\r\n    -- 1. Calcula o valor total do pedido a partir dos seus itens\r\n    SELECT SUM(COALESCE(custo_total_real, 0))\r\n    INTO v_valor_total\r\n    FROM public.pedidos_compra_itens\r\n    WHERE pedido_compra_id = p_pedido_id;\r\n\r\n    -- Se n√£o houver valor, interrompe a fun√ß√£o\r\n    IF v_valor_total IS NULL OR v_valor_total <= 0 THEN\r\n        RETURN 'Erro: O pedido n√£o possui itens com valor para registrar o pagamento.';\r\n    END IF;\r\n\r\n    -- 2. Busca o ID do empreendimento e cria a descri√ß√£o\r\n    SELECT empreendimento_id, 'Pagamento referente ao Pedido de Compra #' || p_pedido_id\r\n    INTO v_empreendimento_id, v_descricao\r\n    FROM public.pedidos_compra\r\n    WHERE id = p_pedido_id;\r\n\r\n    -- 3. Encontra ou cria a categoria \"Material de Constru√ß√£o\"\r\n    SELECT id INTO v_categoria_id FROM public.categorias_financeiras WHERE nome = 'Material de Constru√ß√£o';\r\n    IF v_categoria_id IS NULL THEN\r\n        INSERT INTO public.categorias_financeiras (nome, tipo)\r\n        VALUES ('Material de Constru√ß√£o', 'Despesa')\r\n        RETURNING id INTO v_categoria_id;\r\n    END IF;\r\n\r\n    -- 4. Insere o novo lan√ßamento de despesa\r\n    INSERT INTO public.lancamentos (\r\n        descricao,\r\n        valor,\r\n        data_transacao,\r\n        tipo,\r\n        status,\r\n        conta_id,\r\n        categoria_id,\r\n        empreendimento_id,\r\n        pedido_compra_id\r\n    ) VALUES (\r\n        v_descricao,\r\n        v_valor_total,\r\n        p_data_pagamento,\r\n        'Despesa',\r\n        'Conciliado', -- Pagamento j√° √© considerado conciliado\r\n        p_conta_id,\r\n        v_categoria_id,\r\n        v_empreendimento_id,\r\n        p_pedido_id\r\n    );\r\n\r\n    RETURN 'Pagamento do pedido #' || p_pedido_id || ' registrado com sucesso no financeiro!';\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "reordenar_orcamento_itens",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.reordenar_orcamento_itens(itens_para_atualizar jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    item_data jsonb;\r\nBEGIN\r\n    FOR item_data IN SELECT * FROM jsonb_array_elements(itens_para_atualizar)\r\n    LOOP\r\n        UPDATE public.orcamento_itens\r\n        SET ordem = (item_data->>'ordem')::integer\r\n        WHERE id = (item_data->>'id')::bigint;\r\n    END LOOP;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "safe_cast_date",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.safe_cast_date(p_text text)\n RETURNS date\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\r\nBEGIN\r\n    BEGIN\r\n        RETURN p_text::date; -- Tenta formato padr√£o (YYYY-MM-DD)\r\n    EXCEPTION WHEN OTHERS THEN\r\n        BEGIN\r\n            RETURN to_date(p_text, 'DD/MM/YYYY'); -- Tenta formato BR\r\n        EXCEPTION WHEN OTHERS THEN\r\n            RETURN NULL; -- Se falhar, devolve NULL (n√£o trava)\r\n        END;\r\n    END;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "safe_cast_money",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.safe_cast_money(p_text text)\n RETURNS numeric\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\r\nDECLARE\r\n    v_clean_text text;\r\nBEGIN\r\n    IF p_text IS NULL OR p_text = '' THEN RETURN 0; END IF;\r\n    -- Remove tudo que n√£o √© n√∫mero, ponto ou v√≠rgula\r\n    v_clean_text := REGEXP_REPLACE(p_text, '[^0-9,.]', '', 'g');\r\n    -- Se tem v√≠rgula, trata como decimal brasileiro\r\n    IF position(',' in v_clean_text) > 0 THEN\r\n        v_clean_text := REPLACE(v_clean_text, '.', ''); -- Tira ponto de milhar\r\n        v_clean_text := REPLACE(v_clean_text, ',', '.'); -- Vira ponto decimal\r\n    END IF;\r\n    RETURN v_clean_text::numeric;\r\nEXCEPTION WHEN OTHERS THEN\r\n    RETURN 0;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "safe_date",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.safe_date(p_text text)\n RETURNS date\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\r\nBEGIN\r\n    RETURN p_text::date;\r\nEXCEPTION WHEN OTHERS THEN\r\n    RETURN NULL; -- Se der qualquer erro (ex: 2024-02-31), devolve NULL em vez de travar\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "salvar_anexo_whatsapp",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.salvar_anexo_whatsapp(p_contato_id bigint, p_storage_path text, p_public_url text, p_file_name text, p_file_type text, p_file_size bigint)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n  INSERT INTO public.whatsapp_attachments (\r\n    contato_id, storage_path, public_url, file_name, file_type, file_size\r\n  ) VALUES (\r\n    p_contato_id, p_storage_path, p_public_url, p_file_name, p_file_type, p_file_size\r\n  );\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "salvar_anexo_whatsapp",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.salvar_anexo_whatsapp(p_message_id bigint, p_contato_id bigint, p_enterprise_id bigint, p_storage_path text, p_public_url text, p_file_name text, p_file_type text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    INSERT INTO public.whatsapp_attachments(message_id, contato_id, enterprise_id, storage_path, public_url, file_name, file_type)\r\n    VALUES (p_message_id, p_contato_id, p_enterprise_id, p_storage_path, p_public_url, p_file_name, p_file_type);\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "salvar_mensagem_whatsapp",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.salvar_mensagem_whatsapp(p_contato_id bigint, p_enterprise_id bigint, p_message_id text, p_sender_id text, p_receiver_id text, p_content text, p_sent_at timestamp with time zone, p_direction text, p_status text, p_raw_payload jsonb)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n  INSERT INTO public.whatsapp_messages (\r\n    contato_id, enterprise_id, message_id, sender_id, receiver_id,\r\n    content, sent_at, direction, status, raw_payload\r\n  ) VALUES (\r\n    p_contato_id, p_enterprise_id, p_message_id, p_sender_id, p_receiver_id,\r\n    p_content, p_sent_at, p_direction, p_status, p_raw_payload\r\n  );\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "set_rdo_numero",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.set_rdo_numero()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Verifica se o rdo_numero j√° n√£o foi definido (para evitar sobrescrever em casos especiais)\r\n    IF NEW.rdo_numero IS NULL THEN\r\n        -- Pega o pr√≥ximo valor da sequ√™ncia e formata o campo\r\n        NEW.rdo_numero := 'RDO-' || nextval('public.rdo_numero_seq');\r\n    END IF;\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "sincronizar_parcela_com_lancamento",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.sincronizar_parcela_com_lancamento(p_parcela_id bigint)\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_categoria_id BIGINT;\r\n    v_conta_id BIGINT;\r\n    v_contrato_info RECORD;\r\n    v_parcela_info RECORD;\r\n    v_novo_lancamento_id BIGINT;\r\nBEGIN\r\n    -- Busca os dados da parcela que est√° sendo salva/editada\r\n    SELECT * INTO v_parcela_info FROM contrato_parcelas WHERE id = p_parcela_id;\r\n\r\n    -- Se a parcela n√£o for \"Pendente\", n√£o faz nada no financeiro.\r\n    IF v_parcela_info.status_pagamento <> 'Pendente' THEN\r\n        RETURN 'A√ß√£o n√£o necess√°ria para parcelas com status \"' || v_parcela_info.status_pagamento || '\".';\r\n    END IF;\r\n\r\n    -- Busca informa√ß√µes do contrato (cliente, empreendimento, empresa)\r\n    SELECT\r\n        c.contato_id,\r\n        c.empreendimento_id,\r\n        emp.empresa_proprietaria_id,\r\n        COALESCE(co.nome, co.razao_social) AS nome_cliente,\r\n        c.numero_contrato\r\n    INTO v_contrato_info\r\n    FROM contratos c\r\n    JOIN contatos co ON c.contato_id = co.id\r\n    JOIN empreendimentos emp ON c.empreendimento_id = emp.id\r\n    WHERE c.id = v_parcela_info.contrato_id;\r\n\r\n    -- Garante que a categoria \"Vendas\" exista\r\n    SELECT id INTO v_categoria_id FROM categorias_financeiras WHERE nome = 'Vendas' AND tipo = 'Receita';\r\n    IF v_categoria_id IS NULL THEN\r\n        INSERT INTO categorias_financeiras (nome, tipo) VALUES ('Vendas', 'Receita') RETURNING id INTO v_categoria_id;\r\n    END IF;\r\n\r\n    -- Garante que a conta \"Contas a Receber\" exista\r\n    SELECT id INTO v_conta_id FROM contas_financeiras WHERE nome = 'Contas a Receber';\r\n    IF v_conta_id IS NULL THEN\r\n        INSERT INTO contas_financeiras (nome, tipo, saldo_inicial) VALUES ('Contas a Receber', 'Outro', 0) RETURNING id INTO v_conta_id;\r\n    END IF;\r\n\r\n    -- L√≥gica principal: Verifica se a parcela J√Å TEM um lan√ßamento vinculado\r\n    IF v_parcela_info.lancamento_id IS NOT NULL THEN\r\n        -- SE TEM: ATUALIZA o lan√ßamento financeiro existente com os novos dados\r\n        UPDATE lancamentos\r\n        SET\r\n            descricao = 'Recebimento: ' || v_parcela_info.descricao || ' | Contrato #' || v_contrato_info.numero_contrato || ' (' || v_contrato_info.nome_cliente || ')',\r\n            valor = v_parcela_info.valor_parcela,\r\n            data_vencimento = v_parcela_info.data_vencimento\r\n        WHERE id = v_parcela_info.lancamento_id;\r\n        RETURN 'Lan√ßamento financeiro vinculado foi atualizado com sucesso!';\r\n    ELSE\r\n        -- SE N√ÉO TEM: CRIA um novo lan√ßamento financeiro\r\n        INSERT INTO lancamentos (\r\n            descricao, valor, data_vencimento, data_transacao, tipo, status, conta_id, categoria_id,\r\n            favorecido_contato_id, empreendimento_id, empresa_id, observacao\r\n        ) VALUES (\r\n            'Recebimento: ' || v_parcela_info.descricao || ' | Contrato #' || v_contrato_info.numero_contrato || ' (' || v_contrato_info.nome_cliente || ')',\r\n            v_parcela_info.valor_parcela, v_parcela_info.data_vencimento, v_parcela_info.data_vencimento, 'Receita', 'Pendente', v_conta_id, v_categoria_id,\r\n            v_contrato_info.contato_id, v_contrato_info.empreendimento_id, v_contrato_info.empresa_proprietaria_id, 'Lan√ßamento provisionado do Contrato ID ' || v_parcela_info.contrato_id\r\n        ) RETURNING id INTO v_novo_lancamento_id;\r\n\r\n        -- Atualiza a parcela com o ID do novo lan√ßamento, criando o v√≠nculo\r\n        UPDATE contrato_parcelas SET lancamento_id = v_novo_lancamento_id WHERE id = p_parcela_id;\r\n        RETURN 'Novo lan√ßamento financeiro criado e vinculado √† parcela!';\r\n    END IF;\r\n\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "sincronizar_status_produto_individual",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.sincronizar_status_produto_individual()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  v_status_contrato TEXT;\r\n  v_novo_status_produto TEXT;\r\nBEGIN\r\n  -- Busca o status do contrato principal\r\n  SELECT status_contrato INTO v_status_contrato FROM contratos WHERE id = COALESCE(NEW.contrato_id, OLD.contrato_id);\r\n\r\n  -- Se um produto for ADICIONADO (INSERT) a um contrato...\r\n  IF TG_OP = 'INSERT' THEN\r\n    IF v_status_contrato = 'Assinado' THEN\r\n      v_novo_status_produto := 'Vendido';\r\n    ELSE\r\n      v_novo_status_produto := 'Dispon√≠vel';\r\n    END IF;\r\n    \r\n    UPDATE produtos_empreendimento\r\n    SET status = v_novo_status_produto\r\n    WHERE id = NEW.produto_id;\r\n\r\n  -- Se um produto for REMOVIDO (DELETE) de um contrato...\r\n  ELSIF TG_OP = 'DELETE' THEN\r\n    -- O produto sempre volta a ser 'Dispon√≠vel' ao ser desvinculado.\r\n    UPDATE produtos_empreendimento\r\n    SET status = 'Dispon√≠vel'\r\n    WHERE id = OLD.produto_id;\r\n  END IF;\r\n\r\n  RETURN NULL;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "sincronizar_tabelas_do_banco",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.sincronizar_tabelas_do_banco()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- 1. SINCRONIZA TABELAS (O que j√° fizemos antes)\r\n    INSERT INTO public.tabelas_sistema (nome_tabela, nome_exibicao, modulo)\r\n    SELECT \r\n        table_name, \r\n        INITCAP(REPLACE(table_name, '_', ' ')), \r\n        'Sistema'\r\n    FROM information_schema.tables \r\n    WHERE table_schema = 'public' \r\n      AND table_type = 'BASE TABLE'\r\n      AND table_name NOT IN ('tabelas_sistema', 'campos_sistema', 'schema_migrations', '_prisma_migrations')\r\n    ON CONFLICT (nome_tabela) DO NOTHING;\r\n\r\n    -- 2. SINCRONIZA CAMPOS (A novidade!)\r\n    INSERT INTO public.campos_sistema (tabela_id, nome_coluna, nome_exibicao, tipo_dado)\r\n    SELECT \r\n        ts.id,                     -- ID da tabela pai (buscado via JOIN)\r\n        c.column_name,             -- Nome t√©cnico\r\n        INITCAP(REPLACE(c.column_name, '_', ' ')), -- Nome bonito autom√°tico\r\n        c.data_type                -- Tipo (text, bool, etc)\r\n    FROM information_schema.columns c\r\n    JOIN public.tabelas_sistema ts ON ts.nome_tabela = c.table_name\r\n    WHERE c.table_schema = 'public'\r\n    ON CONFLICT (tabela_id, nome_coluna) DO NOTHING; -- Se j√° existe, ignora\r\n    \r\n    -- 3. AJUSTES FINOS AUTOM√ÅTICOS (Opcional: Esconder colunas t√©cnicas)\r\n    -- Por exemplo: Ningu√©m precisa ver 'id' ou 'organizacao_id' em filtros visuais\r\n    UPDATE public.campos_sistema \r\n    SET visivel_listagem = false, visivel_filtro = false \r\n    WHERE nome_coluna IN ('id', 'organizacao_id', 'senha', 'password', 'deleted_at');\r\n\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "sobrescrever_registros_ponto",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.sobrescrever_registros_ponto(novos_registros tipo_ponto_import[])\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    -- Vari√°veis para guardar os IDs dos funcion√°rios e as datas do arquivo importado\r\n    func_ids bigint[];\r\n    min_data date;\r\n    max_data date;\r\nBEGIN\r\n    -- 1. Pega todos os IDs de funcion√°rios e o intervalo de datas dos novos registros\r\n    SELECT\r\n        array_agg(DISTINCT r.funcionario_id),\r\n        MIN(r.data_hora::date),\r\n        MAX(r.data_hora::date)\r\n    INTO\r\n        func_ids,\r\n        min_data,\r\n        max_data\r\n    FROM unnest(novos_registros) AS r;\r\n\r\n    -- 2. Se encontrou funcion√°rios e datas, apaga os registros antigos APENAS para eles e nesse per√≠odo\r\n    IF func_ids IS NOT NULL AND min_data IS NOT NULL AND max_data IS NOT NULL THEN\r\n        DELETE FROM public.pontos p\r\n        WHERE\r\n            p.funcionario_id = ANY(func_ids)\r\n            AND p.data_hora::date >= min_data\r\n            AND p.data_hora::date <= max_data;\r\n    END IF;\r\n\r\n    -- 3. Insere os novos registros que vieram do arquivo\r\n    INSERT INTO public.pontos (funcionario_id, data_hora, tipo_registro, observacao)\r\n    SELECT\r\n        r.funcionario_id,\r\n        r.data_hora,\r\n        r.tipo_registro,\r\n        r.observacao\r\n    FROM\r\n        unnest(novos_registros) AS r;\r\n\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "sparsevec",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.sparsevec(sparsevec, integer, boolean)\n RETURNS sparsevec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "sparsevec_cmp",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.sparsevec_cmp(sparsevec, sparsevec)\n RETURNS integer\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_cmp$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "sparsevec_eq",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.sparsevec_eq(sparsevec, sparsevec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_eq$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "sparsevec_ge",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.sparsevec_ge(sparsevec, sparsevec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_ge$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "sparsevec_gt",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.sparsevec_gt(sparsevec, sparsevec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_gt$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "sparsevec_in",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.sparsevec_in(cstring, oid, integer)\n RETURNS sparsevec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_in$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "sparsevec_l2_squared_distance",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.sparsevec_l2_squared_distance(sparsevec, sparsevec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_l2_squared_distance$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "sparsevec_le",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.sparsevec_le(sparsevec, sparsevec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_le$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "sparsevec_lt",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.sparsevec_lt(sparsevec, sparsevec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_lt$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "sparsevec_ne",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.sparsevec_ne(sparsevec, sparsevec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_ne$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "sparsevec_negative_inner_product",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.sparsevec_negative_inner_product(sparsevec, sparsevec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_negative_inner_product$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "sparsevec_out",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.sparsevec_out(sparsevec)\n RETURNS cstring\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_out$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "sparsevec_recv",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.sparsevec_recv(internal, oid, integer)\n RETURNS sparsevec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_recv$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "sparsevec_send",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.sparsevec_send(sparsevec)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_send$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "sparsevec_to_halfvec",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.sparsevec_to_halfvec(sparsevec, integer, boolean)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_to_halfvec$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "sparsevec_to_vector",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.sparsevec_to_vector(sparsevec, integer, boolean)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_to_vector$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "sparsevec_typmod_in",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.sparsevec_typmod_in(cstring[])\n RETURNS integer\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_typmod_in$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "subvector",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.subvector(halfvec, integer, integer)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_subvector$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "subvector",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.subvector(vector, integer, integer)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$subvector$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "sugerir_vinculo_funcionario_contato",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.sugerir_vinculo_funcionario_contato(p_cpf text, p_nome text, p_telefone text)\n RETURNS TABLE(id bigint, nome_exibicao text, motivo text)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_telefone_normalizado TEXT;\r\n    v_nome_normalizado TEXT;\r\nBEGIN\r\n    v_telefone_normalizado := normalizar_telefone(p_telefone);\r\n    v_nome_normalizado := trim(lower(p_nome));\r\n\r\n    RETURN QUERY\r\n    WITH possible_matches AS (\r\n        -- Match por CPF (maior prioridade, busca exata)\r\n        SELECT \r\n            c.id, \r\n            COALESCE(c.razao_social, c.nome) as nome_exibicao, \r\n            'CPF' as motivo\r\n        FROM public.contatos c\r\n        WHERE p_cpf IS NOT NULL AND p_cpf <> '' AND c.cpf = p_cpf\r\n\r\n        UNION\r\n\r\n        -- Match por Nome (agora compara sem espa√ßos extras e sem diferenciar mai√∫sculas/min√∫sculas)\r\n        SELECT \r\n            c.id, \r\n            COALESCE(c.razao_social, c.nome) as nome_exibicao, \r\n            'Nome' as motivo\r\n        FROM public.contatos c\r\n        WHERE v_nome_normalizado IS NOT NULL AND v_nome_normalizado <> '' \r\n          AND trim(lower(c.nome)) = v_nome_normalizado\r\n\r\n        UNION\r\n\r\n        -- Match por Telefone (agora verifica se um n√∫mero cont√©m o outro, resolvendo o problema do \"55\")\r\n        SELECT \r\n            c.id, \r\n            COALESCE(c.razao_social, c.nome) as nome_exibicao, \r\n            'Telefone' as motivo\r\n        FROM public.contatos c\r\n        JOIN public.telefones t ON c.id = t.contato_id\r\n        WHERE v_telefone_normalizado IS NOT NULL AND v_telefone_normalizado <> ''\r\n          AND (\r\n            normalizar_telefone(t.telefone) LIKE '%' || v_telefone_normalizado || '%' OR\r\n            v_telefone_normalizado LIKE '%' || normalizar_telefone(t.telefone) || '%'\r\n          )\r\n    )\r\n    -- Agrupa os resultados para n√£o mostrar o mesmo contato m√∫ltiplas vezes\r\n    SELECT \r\n        pm.id, \r\n        pm.nome_exibicao, \r\n        string_agg(DISTINCT pm.motivo, ', ') as motivo\r\n    FROM possible_matches pm\r\n    GROUP BY pm.id, pm.nome_exibicao;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "sync_pedido_com_atividade",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.sync_pedido_com_atividade()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_activity_id bigint;\r\n    v_empreendimento_id bigint;\r\n    v_empresa_id bigint;\r\nBEGIN\r\n    -- Se a data de entrega n√£o foi definida, n√£o faz nada\r\n    IF NEW.data_entrega_prevista IS NULL THEN\r\n        -- Opcional: deletar a atividade se a data for removida\r\n        DELETE FROM public.activities WHERE tipo_atividade = 'Entrega de Pedido' AND nome = 'Entrega Pedido #' || NEW.id;\r\n        RETURN NEW;\r\n    END IF;\r\n\r\n    -- Busca o ID da empresa e do empreendimento\r\n    SELECT empreendimento_id INTO v_empreendimento_id FROM public.pedidos_compra WHERE id = NEW.id;\r\n    SELECT empresa_proprietaria_id INTO v_empresa_id FROM public.empreendimentos WHERE id = v_empreendimento_id;\r\n\r\n    -- Verifica se j√° existe uma atividade para este pedido\r\n    SELECT id INTO v_activity_id FROM public.activities \r\n    WHERE tipo_atividade = 'Entrega de Pedido' AND nome = 'Entrega Pedido #' || NEW.id;\r\n\r\n    -- Se j√° existe, atualiza a data\r\n    IF v_activity_id IS NOT NULL THEN\r\n        UPDATE public.activities\r\n        SET \r\n            data_inicio_prevista = NEW.data_entrega_prevista,\r\n            data_fim_prevista = NEW.data_entrega_prevista\r\n        WHERE id = v_activity_id;\r\n    ELSE\r\n        -- Se n√£o existe, cria uma nova atividade\r\n        INSERT INTO public.activities \r\n            (nome, tipo_atividade, empreendimento_id, empresa_id, data_inicio_prevista, data_fim_prevista, duracao_dias, status, criado_por_usuario_id)\r\n        VALUES \r\n            ('Entrega Pedido #' || NEW.id, 'Entrega de Pedido', v_empreendimento_id, v_empresa_id, NEW.data_entrega_prevista, NEW.data_entrega_prevista, 1, 'N√£o Iniciado', auth.uid());\r\n    END IF;\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "trigger_agendar_salarios_novofuncionario",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.trigger_agendar_salarios_novofuncionario()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    i integer;\r\nBEGIN\r\n    -- Cria a provis√£o para os pr√≥ximos 12 meses a partir do m√™s atual\r\n    FOR i IN 0..11 LOOP\r\n        PERFORM public.agendar_salario_provisionado(NEW.id, (date_trunc('month', NOW()) + (i || ' months')::interval)::date);\r\n    END LOOP;\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "trigger_auto_assign_contact",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.trigger_auto_assign_contact()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  -- Se o contato_id n√£o veio preenchido, o vigia entra em a√ß√£o\r\n  IF NEW.contato_id IS NULL THEN\r\n     NEW.contato_id := find_contact_by_phone(NEW.phone_number);\r\n  END IF;\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "trigger_limpar_provisoes_demissao",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.trigger_limpar_provisoes_demissao()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_mes_competencia_demissao date;\r\nBEGIN\r\n    -- Define o primeiro dia do m√™s em que a demiss√£o ocorreu.\r\n    v_mes_competencia_demissao := date_trunc('month', NEW.demission_date)::date;\r\n\r\n    -- Deleta todos os lan√ßamentos de sal√°rio provisionados (status 'Pendente')\r\n    -- para este funcion√°rio, cujo m√™s de compet√™ncia seja POSTERIOR\r\n    -- ao m√™s da demiss√£o. O pagamento do √∫ltimo m√™s trabalhado √© mantido.\r\n    DELETE FROM public.lancamentos\r\n    WHERE funcionario_id = NEW.id\r\n      AND status = 'Pendente'\r\n      AND mes_competencia > v_mes_competencia_demissao;\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "trigger_link_message_to_conversation",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.trigger_link_message_to_conversation()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  -- Se a mensagem tem um contato, busca a conversa dele e salva o ID\r\n  IF NEW.contato_id IS NOT NULL THEN\r\n    NEW.conversation_record_id := (\r\n        SELECT id \r\n        FROM whatsapp_conversations \r\n        WHERE contato_id = NEW.contato_id \r\n        ORDER BY updated_at DESC -- Pega a mais recente se houver d√∫vida\r\n        LIMIT 1\r\n    );\r\n  END IF;\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "unaccent",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.unaccent(regdictionary, text)\n RETURNS text\n LANGUAGE c\n STABLE PARALLEL SAFE STRICT\nAS '$libdir/unaccent', $function$unaccent_dict$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "unaccent",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.unaccent(text)\n RETURNS text\n LANGUAGE c\n STABLE PARALLEL SAFE STRICT\nAS '$libdir/unaccent', $function$unaccent_dict$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "unaccent_init",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.unaccent_init(internal)\n RETURNS internal\n LANGUAGE c\n PARALLEL SAFE\nAS '$libdir/unaccent', $function$unaccent_init$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "unaccent_lexize",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.unaccent_lexize(internal, internal, internal, internal)\n RETURNS internal\n LANGUAGE c\n PARALLEL SAFE\nAS '$libdir/unaccent', $function$unaccent_lexize$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "update_broadcast_timestamp",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.update_broadcast_timestamp()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n   NEW.updated_at = now(); \r\n   RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "update_contact_meta_names",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.update_contact_meta_names()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_ad_name TEXT;\r\n    v_campaign_id TEXT;\r\n    v_campaign_name TEXT;\r\nBEGIN\r\n    -- Verifica se existe um ID de an√∫ncio no novo contato\r\n    IF NEW.meta_ad_id IS NOT NULL THEN\r\n        -- Fluxo 1: Busca o nome do an√∫ncio e o ID da campanha dele\r\n        SELECT\r\n            \"name\", \"campaign_id\"\r\n        INTO\r\n            v_ad_name, v_campaign_id\r\n        FROM\r\n            public.meta_ads\r\n        WHERE\r\n            id = NEW.meta_ad_id;\r\n\r\n        -- Se encontrou um ID de campanha, continua a investiga√ß√£o\r\n        IF v_campaign_id IS NOT NULL THEN\r\n            -- Fluxo 2: Busca o nome da campanha\r\n            SELECT\r\n                \"name\"\r\n            INTO\r\n                v_campaign_name\r\n            FROM\r\n                public.meta_campaigns\r\n            WHERE\r\n                id = v_campaign_id;\r\n        END IF;\r\n\r\n        -- Atualiza a linha do contato com os nomes encontrados\r\n        UPDATE public.contatos\r\n        SET\r\n            meta_ad_name = v_ad_name,\r\n            meta_campaign_name = v_campaign_name\r\n        WHERE\r\n            id = NEW.id;\r\n    END IF;\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "update_conversation_timestamp",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.update_conversation_timestamp()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Atualiza 'updated_at' na tabela 'whatsapp_conversations'\r\n    -- usando o 'contato_id' da nova mensagem\r\n    UPDATE public.whatsapp_conversations\r\n    SET updated_at = NEW.sent_at -- Ou NEW.created_at, dependendo de qual coluna reflete o timestamp da mensagem\r\n    WHERE phone_number = (SELECT telefones[1]->>'telefone' FROM public.contatos WHERE id = NEW.contato_id);\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "update_updated_at_column",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n   NEW.updated_at = now();\r\n   RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "update_whatsapp_conversation_timestamp",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.update_whatsapp_conversation_timestamp()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_phone_number TEXT;\r\nBEGIN\r\n    -- Obter o n√∫mero de telefone associado ao contato_id da nova mensagem\r\n    SELECT t.telefone INTO v_phone_number\r\n    FROM public.contatos c\r\n    JOIN public.telefones t ON c.id = t.contato_id\r\n    WHERE c.id = NEW.contato_id\r\n    LIMIT 1; -- Assegura que pegamos apenas um telefone, o principal se houver v√°rios\r\n\r\n    IF v_phone_number IS NOT NULL THEN\r\n        -- Insere ou atualiza o 'updated_at' da conversa correspondente\r\n        -- O GREATEST garante que 'updated_at' seja sempre a data mais recente\r\n        INSERT INTO public.whatsapp_conversations (phone_number, updated_at)\r\n        VALUES (v_phone_number, NEW.sent_at) -- Usando NEW.sent_at da nova mensagem\r\n        ON CONFLICT (phone_number) DO UPDATE\r\n        SET updated_at = GREATEST(whatsapp_conversations.updated_at, NEW.sent_at); \r\n    END IF;\r\n    \r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "vector",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.vector(vector, integer, boolean)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "vector_accum",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.vector_accum(double precision[], vector)\n RETURNS double precision[]\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_accum$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "vector_add",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.vector_add(vector, vector)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_add$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "vector_avg",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.vector_avg(double precision[])\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_avg$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "vector_cmp",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.vector_cmp(vector, vector)\n RETURNS integer\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_cmp$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "vector_combine",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.vector_combine(double precision[], double precision[])\n RETURNS double precision[]\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_combine$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "vector_concat",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.vector_concat(vector, vector)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_concat$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "vector_dims",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.vector_dims(vector)\n RETURNS integer\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_dims$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "vector_dims",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.vector_dims(halfvec)\n RETURNS integer\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_vector_dims$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "vector_eq",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.vector_eq(vector, vector)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_eq$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "vector_ge",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.vector_ge(vector, vector)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_ge$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "vector_gt",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.vector_gt(vector, vector)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_gt$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "vector_in",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.vector_in(cstring, oid, integer)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_in$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "vector_l2_squared_distance",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.vector_l2_squared_distance(vector, vector)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_l2_squared_distance$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "vector_le",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.vector_le(vector, vector)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_le$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "vector_lt",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.vector_lt(vector, vector)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_lt$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "vector_mul",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.vector_mul(vector, vector)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_mul$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "vector_ne",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.vector_ne(vector, vector)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_ne$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "vector_negative_inner_product",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.vector_negative_inner_product(vector, vector)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_negative_inner_product$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "vector_norm",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.vector_norm(vector)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_norm$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "vector_out",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.vector_out(vector)\n RETURNS cstring\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_out$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "vector_recv",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.vector_recv(internal, oid, integer)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_recv$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "vector_send",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.vector_send(vector)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_send$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "vector_spherical_distance",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.vector_spherical_distance(vector, vector)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_spherical_distance$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "vector_sub",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.vector_sub(vector, vector)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_sub$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "vector_to_float4",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.vector_to_float4(vector, integer, boolean)\n RETURNS real[]\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_to_float4$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "vector_to_halfvec",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.vector_to_halfvec(vector, integer, boolean)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_to_halfvec$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "vector_to_sparsevec",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.vector_to_sparsevec(vector, integer, boolean)\n RETURNS sparsevec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_to_sparsevec$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "vector_typmod_in",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.vector_typmod_in(cstring[])\n RETURNS integer\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_typmod_in$function$\n"
  },
  {
    "schema": "public",
    "nome_da_funcao": "vincular_conversas_orfas",
    "codigo_fonte": "CREATE OR REPLACE FUNCTION public.vincular_conversas_orfas(p_contato_id uuid, p_telefone text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_telefone_variacao TEXT;\r\nBEGIN\r\n    -- 1. Tenta vincular pelo n√∫mero EXATO\r\n    -- Verifica tanto na coluna 'customer_phone' quanto 'phone_number' (dependendo da sua estrutura)\r\n    UPDATE whatsapp_conversations\r\n    SET contato_id = p_contato_id\r\n    WHERE contato_id IS NULL\r\n    AND (\r\n        phone_number = p_telefone \r\n        OR customer_phone = p_telefone\r\n        OR id::text = p_telefone -- Caso o ID da tabela seja o pr√≥prio n√∫mero\r\n    );\r\n\r\n    -- 2. Calcula a Varia√ß√£o do 9¬∫ D√≠gito\r\n    v_telefone_variacao := NULL;\r\n\r\n    IF LENGTH(p_telefone) = 13 THEN\r\n        -- Se salvou '55 33 9 8888 8888' (13 d√≠gitos), tenta achar a vers√£o antiga SEM o 9\r\n        -- Remove o 9 que est√° na 5¬™ posi√ß√£o (ap√≥s o 55 + DDD)\r\n        v_telefone_variacao := LEFT(p_telefone, 4) || SUBSTRING(p_telefone FROM 6);\r\n        \r\n    ELSIF LENGTH(p_telefone) = 12 THEN\r\n        -- Se salvou '55 33 8888 8888' (12 d√≠gitos), tenta achar a vers√£o nova COM o 9\r\n        -- Adiciona o 9 na 5¬™ posi√ß√£o\r\n        v_telefone_variacao := LEFT(p_telefone, 4) || '9' || SUBSTRING(p_telefone FROM 5);\r\n    END IF;\r\n\r\n    -- 3. Se existe uma varia√ß√£o, tenta vincular tamb√©m\r\n    IF v_telefone_variacao IS NOT NULL THEN\r\n        UPDATE whatsapp_conversations\r\n        SET contato_id = p_contato_id\r\n        WHERE contato_id IS NULL\r\n        AND (\r\n            phone_number = v_telefone_variacao \r\n            OR customer_phone = v_telefone_variacao\r\n            OR id::text = v_telefone_variacao\r\n        );\r\n    END IF;\r\nEND;\r\n$function$\n"
  }
]